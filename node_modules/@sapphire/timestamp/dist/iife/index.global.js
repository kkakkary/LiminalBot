var SapphireTimestamp = (function (exports) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // src/lib/constants.ts
  var Time = /* @__PURE__ */ ((Time2) => {
    Time2[Time2["Nanosecond"] = 1e-6] = "Nanosecond";
    Time2[Time2["Microsecond"] = 1e-3] = "Microsecond";
    Time2[Time2["Millisecond"] = 1] = "Millisecond";
    Time2[Time2["Second"] = 1e3] = "Second";
    Time2[Time2["Minute"] = 6e4] = "Minute";
    Time2[Time2["Hour"] = 36e5] = "Hour";
    Time2[Time2["Day"] = 864e5] = "Day";
    Time2[Time2["Week"] = 6048e5] = "Week";
    Time2[Time2["Month"] = 2628e6] = "Month";
    Time2[Time2["Year"] = 31536e6] = "Year";
    return Time2;
  })(Time || {});
  var days = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
  var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
  var tokens = /* @__PURE__ */ new Map([
    ["Y", 4],
    ["Q", 1],
    ["M", 4],
    ["D", 4],
    ["d", 4],
    ["X", 1],
    ["x", 1],
    ["H", 2],
    ["h", 2],
    ["a", 1],
    ["A", 1],
    ["m", 2],
    ["s", 2],
    ["S", 3],
    ["Z", 2],
    ["l", 4],
    ["L", 4],
    ["T", 1],
    ["t", 1]
  ]);

  // src/lib/Timestamp.ts
  var tokenResolvers = /* @__PURE__ */ new Map([
    // Dates
    ["Y", (time) => String(time.getFullYear()).slice(2)],
    ["YY", (time) => String(time.getFullYear()).slice(2)],
    ["YYY", (time) => String(time.getFullYear())],
    ["YYYY", (time) => String(time.getFullYear())],
    ["Q", (time) => String((time.getMonth() + 1) / 3)],
    ["M", (time) => String(time.getMonth() + 1)],
    ["MM", (time) => String(time.getMonth() + 1).padStart(2, "0")],
    ["MMM", (time) => months[time.getMonth()]],
    ["MMMM", (time) => months[time.getMonth()]],
    ["D", (time) => String(time.getDate())],
    ["DD", (time) => String(time.getDate()).padStart(2, "0")],
    ["DDD", (time) => String(Math.floor((time.getTime() - new Date(time.getFullYear(), 0, 0).getTime()) / 864e5 /* Day */))],
    ["DDDD", (time) => String(Math.floor((time.getTime() - new Date(time.getFullYear(), 0, 0).getTime()) / 864e5 /* Day */))],
    [
      "d",
      (time) => {
        const day = String(time.getDate());
        if (day !== "11" && day.endsWith("1")) return `${day}st`;
        if (day !== "12" && day.endsWith("2")) return `${day}nd`;
        if (day !== "13" && day.endsWith("3")) return `${day}rd`;
        return `${day}th`;
      }
    ],
    ["dd", (time) => days[time.getDay()].slice(0, 2)],
    ["ddd", (time) => days[time.getDay()].slice(0, 3)],
    ["dddd", (time) => days[time.getDay()]],
    ["X", (time) => String(time.valueOf() / 1e3 /* Second */)],
    ["x", (time) => String(time.valueOf())],
    // Locales
    ["H", (time) => String(time.getHours())],
    ["HH", (time) => String(time.getHours()).padStart(2, "0")],
    ["h", (time) => String(time.getHours() % 12 || 12)],
    ["hh", (time) => String(time.getHours() % 12 || 12).padStart(2, "0")],
    ["a", (time) => time.getHours() < 12 ? "am" : "pm"],
    ["A", (time) => time.getHours() < 12 ? "AM" : "PM"],
    ["m", (time) => String(time.getMinutes())],
    ["mm", (time) => String(time.getMinutes()).padStart(2, "0")],
    ["s", (time) => String(time.getSeconds())],
    ["ss", (time) => String(time.getSeconds()).padStart(2, "0")],
    ["S", (time) => String(time.getMilliseconds())],
    ["SS", (time) => String(time.getMilliseconds()).padStart(2, "0")],
    ["SSS", (time) => String(time.getMilliseconds()).padStart(3, "0")],
    ["T", (time) => `${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`],
    [
      "t",
      (time) => `${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")}:${String(time.getSeconds()).padStart(2, "0")} ${time.getHours() < 12 ? "am" : "pm"}`
    ],
    ["L", (time) => `${String(time.getMonth() + 1).padStart(2, "0")}/${String(time.getDate()).padStart(2, "0")}/${String(time.getFullYear())}`],
    ["l", (time) => `${String(time.getMonth() + 1)}/${String(time.getDate()).padStart(2, "0")}/${String(time.getFullYear())}`],
    ["LL", (time) => `${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())}`],
    ["ll", (time) => `${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())}`],
    [
      "LLL",
      (time) => `${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(
      time.getHours() % 12 || 12
    )}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "lll",
      (time) => `${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(
      time.getHours() % 12 || 12
    )}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "LLLL",
      (time) => `${days[time.getDay()]}, ${months[time.getMonth()]} ${String(time.getDate()).padStart(2, "0")}, ${String(time.getFullYear())} ${String(
      time.getHours() % 12 || 12
    )}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "llll",
      (time) => `${days[time.getDay()].slice(0, 3)} ${months[time.getMonth()].slice(0, 3)} ${String(time.getDate()).padStart(2, "0")}, ${String(
      time.getFullYear()
    )} ${String(time.getHours() % 12 || 12)}:${String(time.getMinutes()).padStart(2, "0")} ${time.getHours() < 12 ? "AM" : "PM"}`
    ],
    [
      "Z",
      (time) => {
        const offset = time.getTimezoneOffset();
        const unsigned = offset >= 0;
        const absolute = Math.abs(offset);
        return `${unsigned ? "+" : "-"}${String(Math.floor(absolute / 60)).padStart(2, "0")}:${String(absolute % 60).padStart(2, "0")}`;
      }
    ],
    [
      "ZZ",
      (time) => {
        const offset = time.getTimezoneOffset();
        const unsigned = offset >= 0;
        const absolute = Math.abs(offset);
        return `${unsigned ? "+" : "-"}${String(Math.floor(absolute / 60)).padStart(2, "0")}:${String(absolute % 60).padStart(2, "0")}`;
      }
    ]
  ]);
  var _Timestamp = class _Timestamp {
    /**
     * Starts a new Timestamp and parses the pattern.
     * @since 1.0.0
     * @param pattern The pattern to parse
     */
    constructor(pattern) {
      /**
       * The raw pattern
       * @since 1.0.0
       */
      __publicField(this, "pattern");
      /**
       * @since 1.0.0
       */
      __publicField(this, "template");
      this.pattern = pattern;
      this.template = _Timestamp.parse(pattern);
    }
    /**
     * Display the current date with the current pattern.
     * @since 1.0.0
     * @param time The time to display
     */
    display(time = /* @__PURE__ */ new Date()) {
      return _Timestamp.display(this.template, time);
    }
    /**
     * Display the current date utc with the current pattern.
     * @since 1.0.0
     * @param time The time to display in utc
     */
    displayUTC(time) {
      return _Timestamp.display(this.template, _Timestamp.utc(time));
    }
    /**
     * Edits the current pattern.
     * @since 1.0.0
     * @param pattern The new pattern for this instance
     * @chainable
     */
    edit(pattern) {
      this.pattern = pattern;
      this.template = _Timestamp.parse(pattern);
      return this;
    }
    /**
     * Defines the toString behavior of Timestamp.
     */
    toString() {
      return this.display();
    }
    /**
     * Display the current date with the current pattern.
     * @since 1.0.0
     * @param pattern The pattern to parse
     * @param time The time to display
     */
    static displayArbitrary(pattern, time = /* @__PURE__ */ new Date()) {
      return _Timestamp.display(_Timestamp.parse(pattern), time);
    }
    /**
     * Display the current date utc with the current pattern.
     * @since 1.0.0
     * @param pattern The pattern to parse
     * @param time The time to display
     */
    static displayUTCArbitrary(pattern, time = /* @__PURE__ */ new Date()) {
      return _Timestamp.display(_Timestamp.parse(pattern), _Timestamp.utc(time));
    }
    /**
     * Creates a UTC Date object to work with.
     * @since 1.0.0
     * @param time The date to convert to utc
     */
    static utc(time = /* @__PURE__ */ new Date()) {
      time = _Timestamp.resolveDate(time);
      return new Date(time.valueOf() + time.getTimezoneOffset() * 6e4);
    }
    /**
     * Display the current date with the current pattern.
     * @since 1.0.0
     * @param template The pattern to parse
     * @param time The time to display
     */
    static display(template, time) {
      let output = "";
      const parsedTime = _Timestamp.resolveDate(time);
      for (const { content, type } of template) output += content || tokenResolvers.get(type)(parsedTime);
      return output;
    }
    /**
     * Parses the pattern.
     * @since 1.0.0
     * @param pattern The pattern to parse
     */
    static parse(pattern) {
      const template = [];
      for (let i = 0; i < pattern.length; i++) {
        let current = "";
        const currentChar = pattern[i];
        const tokenMax = tokens.get(currentChar);
        if (typeof tokenMax === "number") {
          current += currentChar;
          while (pattern[i + 1] === currentChar && current.length < tokenMax) current += pattern[++i];
          template.push({ type: current, content: null });
        } else if (currentChar === "[") {
          while (i + 1 < pattern.length && pattern[i + 1] !== "]") current += pattern[++i];
          i++;
          template.push({ type: "literal", content: current || "[" });
        } else {
          current += currentChar;
          while (i + 1 < pattern.length && !tokens.has(pattern[i + 1]) && pattern[i + 1] !== "[") current += pattern[++i];
          template.push({ type: "literal", content: current });
        }
      }
      return template;
    }
    /**
     * Resolves a date.
     * @since 1.0.0
     * @param time The time to parse
     */
    static resolveDate(time) {
      return time instanceof Date ? time : new Date(time);
    }
  };
  __name(_Timestamp, "Timestamp");
  var Timestamp = _Timestamp;

  exports.Time = Time;
  exports.Timestamp = Timestamp;
  exports.days = days;
  exports.months = months;
  exports.tokens = tokens;

  return exports;

})({});
//# sourceMappingURL=index.global.js.map
//# sourceMappingURL=index.global.js.map