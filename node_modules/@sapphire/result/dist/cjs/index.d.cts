type Awaitable<T> = PromiseLike<T> | T;
type If<Value extends boolean, TrueResult, FalseResult> = Value extends true ? TrueResult : Value extends false ? FalseResult : TrueResult | FalseResult;

declare const ValueProperty$1: unique symbol;
declare const SuccessProperty: unique symbol;
/**
 * A type used to express computations that can fail, it can be used for returning and propagating errors. This is a
 * type union with the variants `Ok(T)`, representing success and containing a value, and `Err(E)`, representing error
 * and containing an error value.
 *
 * @typeparam T The result's type.
 * @typeparam E The error's type.
 *
 * @see {@link https://doc.rust-lang.org/std/result/index.html}
 */
declare class Result<T, E, const Success extends boolean = boolean> {
    /**
     * Branded value to ensure `Success` is typed correctly.
     * @internal
     */
    protected __STATUS__: Success;
    private readonly [ValueProperty$1];
    private readonly [SuccessProperty];
    private constructor();
    /**
     * Returns `true` if the result is `Ok`.
     *
     * @example
     * ```typescript
     * const x = ok(-3);
     * assert.equal(x.isOk(), true);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.isOk(), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok}
     */
    isOk(): this is Ok<T, E>;
    /**
     * Returns `true` if the result is `Ok` and the value inside of it matches a predicate.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.isOkAnd((value) => value > 1), true);
     * ```
     * @example
     * ```typescript
     * const x = ok(0);
     * assert.equal(x.isOkAnd((value) => value > 1), false);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.isOkAnd((value) => value > 1), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok_and}
     */
    isOkAnd<R extends T>(cb: (value: T) => value is R): this is Ok<R, E>;
    isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R;
    /**
     * Returns `true` if the result is `Err`.
     *
     * @example
     * ```typescript
     * const x = ok(-3);
     * assert.equal(x.isErr(), false);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.isErr(), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err}
     */
    isErr(): this is Err<E, T>;
    /**
     * Returns `true` if the result is `Err` and the value inside of it matches a predicate.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);
     * ```
     * @example
     * ```typescript
     * const x = err(new Error('Some error message'));
     * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);
     * ```
     * @example
     * ```typescript
     * const x = err(new TypeError('Some error message'));
     * assert.equal(x.isErrAnd((error) => error instanceof TypeError), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err_and}
     */
    isErrAnd<R extends E>(cb: (error: E) => error is R): this is Err<R, T>;
    isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R;
    /**
     * Converts from `Result<T, E>` to `Option<T>`.
     *
     * Converts itself into an `Option<T>`, and discarding the error, if any.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.ok(), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.ok(), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.ok}
     */
    ok(): If<Success, Some<T>, None>;
    /**
     * Converts from `Result<T, E>` to `Option<E>`.
     *
     * Converts itself into an `Option<E>`, and discarding the successful value, if any.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.err(), none);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.err(), 'Some error message');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.err}
     */
    err(): If<Success, None, Some<E>>;
    /**
     * Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained `Ok` value, leaving an `Err` value
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.map((value) => value * 2), ok(4));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.map((value) => value * 2), err('Some error message'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map}
     */
    map<OutputValue>(cb: (value: T) => OutputValue): If<Success, Ok<OutputValue, E>, Err<E>>;
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Ok` value, leaving an `Err` value
     * untouched.
     *
     * Unlike {@link map}, this method does not wrap the returned value inside `Ok`, but instead, it returns the
     * returned value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.mapInto((value) => ok(value * value)), ok(4));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(0);
     * assert.equal(
     *   x.mapInto((value) => (value === 0 ? err('zero is not divisible') : ok(1 / value))),
     *   err('zero is not divisible')
     * );
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.mapInto((value) => ok(4)), err('Some error message'));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapInto<OutputResult extends AnyResult>(cb: (value: T) => OutputResult): If<Success, OutputResult, Err<E>>;
    /**
     * Returns the provided default (if `Err`), or applies a function to the contained value (if `Ok`),
     *
     * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use `mapOrElse`, which is lazily evaluated.
     * @param defaultValue The default value to use.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x = ok('hello');
     * assert.equal(x.mapOr(42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.mapOr(42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or}
     */
    mapOr<MappedOutputValue, DefaultOutputValue>(defaultValue: DefaultOutputValue, cb: (value: T) => MappedOutputValue): If<Success, MappedOutputValue, DefaultOutputValue>;
    /**
     * Maps a `Result<T, E>` to `U` by applying fallback function default to a contained `Err` value, or function `cb`
     * to a contained `Ok` value.
     *
     * This function can be used to unpack a successful result while handling an error.
     * @param op The predicate that is run on `Err`.
     * @param cb The predicate that is run on `Ok`.
     *
     * @example
     * ```typescript
     * const x: Result<string, string> = ok('hello');
     * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Result<string, string> = err('Some error message');
     * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 18);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else}
     */
    mapOrElse<OutputValue, OutputError>(op: (error: E) => OutputError, cb: (value: T) => OutputValue): If<Success, OutputValue, OutputError>;
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value
     * untouched.
     *
     * This function can be used to pass through a successful result while handling an error.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, Error> = ok(2);
     * assert.equal(x.mapErr((error) => error.message), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErr((error) => error.message), err('Some error message'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err}
     */
    mapErr<OutputError>(cb: (error: E) => OutputError): If<Success, Ok<T>, Err<OutputError>>;
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value
     * untouched.
     *
     * This function can be used to pass through a successful result while handling an error.
     *
     * Unlike {@link mapErr}, this method does not wrap the returned value inside `Err`, but instead, it returns the
     * returned value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, Error> = ok(2);
     * assert.equal(x.mapErrInto((error) => err(error.message)), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErrInto((error) => err(error.message)), err('Some error message'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErrInto((error) => ok(4)), ok(4));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapErrInto<OutputResult extends AnyResult>(cb: (error: E) => OutputResult): If<Success, Ok<T>, OutputResult>;
    /**
     * Calls the provided closure with a reference to the contained value (if `Ok`).
     * @param cb The predicate.
     * @seealso {@link inspectAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * ok(2).inspect(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * err('Some error message').inspect(console.log);
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect}
     */
    inspect(cb: (value: T) => unknown): this;
    /**
     * Calls the provided closure with a reference to the contained value (if `Ok`) and awaits it.
     * @param cb The predicate.
     * @seealso {@link inspect} for the sync version.
     *
     * @example
     * ```typescript
     * await ok(2).inspectAsync(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * await err('Some error message').inspectAsync(console.log);
     * // Doesn't log
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this>;
    /**
     * Calls the provided closure with a reference to the contained error (if `Err`).
     * @param cb The predicate.
     * @seealso {@link inspectErrAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * ok(2).inspectErr(console.log);
     * // Doesn't log
     * ```
     * @example
     * ```typescript
     * err('Some error message').inspectErr(console.log);
     * // Logs: Some error message
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err}
     */
    inspectErr(cb: (error: E) => unknown): this;
    /**
     * Calls the provided closure with a reference to the contained error (if `Err`) and awaits it.
     * @param cb The predicate.
     * @seealso {@link inspectErr} for the sync version.
     *
     * @example
     * ```typescript
     * await ok(2).inspectErrAsync(console.log);
     * // Doesn't log
     * ```
     * @example
     * ```typescript
     * await err('Some error message').inspectErrAsync(console.log);
     * // Logs: Some error message
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this>;
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Ok`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = ok(7);
     * for (const value of x.iter()) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = err('Nothing!');
     * for (const value of x.iter()) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}
     */
    iter(): Generator<T>;
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws a {@link ResultError} with the given message and the content of the `Err`.
     * @param message The message for the error.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.expect('Whoops!'), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.expect('Whoops!'), {
     *   name: 'ResultError',
     *   message: 'Whoops',
     *   value: 'Emergency failure'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect}
     */
    expect(message: string): If<Success, T, never>;
    /**
     * Returns the contained `Err` value.
     *
     * If the value is an `Ok`, it throws a {@link ResultError} with the given message and the content of the `Ok`.
     * @param message The message for the error.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.throws(() => x.expectErr('Whoops!'), {
     *   name: 'ResultError',
     *   message: 'Whoops',
     *   value: 2
     * });
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.equal(x.expectErr('Whoops!'), 'Emergency failure');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err}
     */
    expectErr(message: string): If<Success, never, E>;
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws a {@link ResultError} with the message, and the content of the `Err`.
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.unwrap(), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.unwrap(), {
     *   name: 'ResultError',
     *   message: 'Unwrap failed',
     *   value: 'Emergency failure'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap}
     */
    unwrap(): If<Success, T, never>;
    /**
     * Returns the contained `Err` value.
     *
     * If the value is an `Ok`, it throws a {@link ResultError} with the message, and the content of the `Ok`.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapRaw}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.throws(() => x.unwrapErr(), {
     *   name: 'ResultError',
     *   message: 'Unwrap failed',
     *   value: 2
     * });
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.equal(x.unwrapErr(), 'Emergency failure');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err}
     */
    unwrapErr(): If<Success, never, E>;
    /**
     * Returns the contained `Ok` value or the provided default.
     *
     * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link unwrapOrElse}, which is lazily evaluated.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @param defaultValue The default value.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(9);
     * assert.equal(x.unwrapOr(2), 9);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Error');
     * assert.equal(x.unwrapOr(2), 2);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or}
     */
    unwrapOr<OutputValue>(defaultValue: OutputValue): If<Success, T, OutputValue>;
    /**
     * Returns the contained `Ok` value or computes it from a closure.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @param op The predicate.
     *
     * @example
     * ```typescript
     * const count = (x: string) => x.length;
     *
     * assert.equal(ok(2).unwrapOrElse(count), 2);
     * assert.equal(err('hello').unwrapOrElse(count), 5);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else}
     */
    unwrapOrElse<OutputValue>(op: (error: E) => OutputValue): If<Success, T, OutputValue>;
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws the contained error.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.unwrapRaw(), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.unwrapRaw(), {
     *   name: 'Error',
     *   message: 'Unwrap failed',
     *   value: 'Emergency failure'
     * });
     * ```
     */
    unwrapRaw(): If<Success, T, never>;
    /**
     * Returns `result` if the result is `Ok`, otherwise returns the `Err` value of itself.
     * @param result The result to check.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<string, string> = err('Late error');
     * assert.equal(x.and(y), err('Late error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<string, string> = err('Late error');
     * assert.equal(x.and(y), err('Early error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<string, string> = ok('Hello');
     * assert.equal(x.and(y), ok('Hello'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and}
     */
    and<OutputResult extends AnyResult>(result: OutputResult): If<Success, OutputResult, Err<E>>;
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * function fractionOf4(value: number) {
     *   return value === 0 ? err('overflowed') : ok(4 / value);
     * }
     *
     * assert.equal(ok(2).andThen(fractionOf4), ok(4));
     * assert.equal(ok(0).andThen(fractionOf4), err('overflowed'));
     * assert.equal(err('not a number').andThen(fractionOf4), err('not a number'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}
     */
    andThen<OutputResult extends AnyResult>(cb: (value: T) => OutputResult): If<Success, OutputResult, Err<E>>;
    /**
     * Return `result` if the result is `Err`, otherwise returns the `Ok` value of self.
     *
     * Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended
     * to use {@link orElse}, which is lazily evaluated.
     * @param result The result to check.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<number, string> = err('Late error');
     * assert.equal(x.or(y), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<number, string> = ok(2);
     * assert.equal(x.or(y), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<number, string> = err('Late error');
     * assert.equal(x.or(y), err('Late error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<number, string> = ok(100);
     * assert.equal(x.or(y), ok(2));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or}
     */
    or<OutputResult extends AnyResult>(result: OutputResult): If<Success, Ok<T>, OutputResult>;
    /**
     * Calls `cb` if the result is `Err`, otherwise returns the `Ok` value of self.
     *
     * This function can be used for control flow based on result values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const square = (x: number): Result<number, string> => ok(x * x);
     * const wrapErr = (x: number): Result<number, string> => err(x);
     *
     * assert.equal(ok(2).orElse(square).orElse(square), ok(2));
     * assert.equal(ok(2).orElse(wrapErr).orElse(square), ok(2));
     * assert.equal(err(3).orElse(square).orElse(wrapErr), ok(9));
     * assert.equal(err(3).orElse(wrapErr).orElse(wrapErr), err(3));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else}
     */
    orElse<OutputResult extends AnyResult>(cb: (error: E) => OutputResult): If<Success, Ok<T>, OutputResult>;
    /**
     * Returns `true` if the result is an `Ok` and the given value strict equals it.
     * @param value The value to compare.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.contains(2), true);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(3);
     * assert.equal(x.contains(2), false);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.contains(2), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains}
     */
    contains<const Value extends T>(this: Ok<T>, value: Value): this is Ok<Value>;
    contains(this: Err<E>, value: T): false;
    /**
     * Returns `true` if the result is an `Err` and the given error strict equals it.
     * @param error The error to compare.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.containsErr('Some error message'), false);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.containsErr('Some error message'), true);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some other error message');
     * assert.equal(x.containsErr('Some error message'), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains_err}
     */
    containsErr(this: Ok<T>, error: E): false;
    containsErr<const Value extends E>(this: Err<E>, error: Value): this is Err<Value>;
    /**
     * Transposes a `Result` of an `Option` into an `Option` of a `Result`.
     *
     * `ok(none)` will be mapped to `none`. `ok(some(v))` and `err(e)` will be mapped to `some(ok(v))` and `some(err(e))`.
     *
     * @example
     * ```typescript
     * const x: Result<Option<number>, Error> = ok(some(5));
     * const y: Option<Result<number, Error>> = some(ok(5));
     * assert.equal(x.transpose(), y);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose}
     */
    transpose<InnerValue>(this: Result<Option<InnerValue>, E, Success>): If<Success, Option<Ok<InnerValue>>, Some<Err<E>>>;
    /**
     * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.
     *
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = ok(ok('Hello'));
     * assert.equal(x.flatten(), ok('Hello'));
     * ```
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = ok(err(6));
     * assert.equal(x.flatten(), err(6));
     * ```
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = err(6);
     * assert.equal(x.flatten(), err(6));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}
     */
    flatten<InnerResult extends AnyResult>(this: Result<InnerResult, E, Success>): If<Success, InnerResult, Err<E>>;
    /**
     * Returns the `Ok` value if self is `Ok`, and the `Err` value if self is `Err`.
     *
     * @example
     * ```typescript
     * let x: Result<number, number> = ok(3);
     * assert.equal(x.intoOkOrErr(), 3);
     * ```
     * @example
     * ```typescript
     * let x: Result<number, number> = err(4);
     * assert.equal(x.intoOkOrErr(), 4);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.into_ok_or_err}
     */
    intoOkOrErr(): If<Success, T, E>;
    /**
     * Returns a `Promise` object with the awaited value (if `Ok`) or the awaited error (if `Err`).
     *
     * @example
     * ```typescript
     * let x = ok(Promise.resolve(3));
     * assert.equal(await x.intoPromise(), ok(3));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    intoPromise(): If<Success, Promise<Ok<Awaited<T>>>, Promise<Err<Awaited<E>>>>;
    /**
     * Checks whether or not `other` equals with self.
     * @param other The other result to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}
     */
    eq<OtherValue extends T, OtherError extends E, OtherSuccess extends boolean>(other: Result<OtherValue, OtherError, OtherSuccess>): this is Result<OtherValue, OtherError, OtherSuccess>;
    /**
     * Checks whether or not `other` doesn't equal with self.
     * @param other The other result to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}
     */
    ne(other: Result<T, E>): boolean;
    /**
     * Runs `ok` function if self is `Ok`, otherwise runs `err` function.
     * @param branches The branches to match.
     *
     * @example
     * ```typescript
     * const result = ok(4).match({
     *   ok: (v) => v,
     *   err: () => 0
     * });
     * assert.equal(result, 4);
     * ```
     * @example
     * ```typescript
     * const result = err('Hello').match({
     *   ok: (v) => v,
     *   err: () => 0
     * });
     * assert.equal(result, 0);
     * ```
     */
    match<OkValue, ErrValue>(branches: {
        ok(this: Ok<T>, value: T): OkValue;
        err(this: Err<E>, error: E): ErrValue;
    }): If<Success, OkValue, ErrValue>;
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Ok`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = ok(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = err('Nothing!');
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link IResult.iter}
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}
     */
    [Symbol.iterator](): Generator<T>;
    get [Symbol.toStringTag](): If<Success, 'Ok', 'Err'>;
    static ok<T = undefined, E = any>(this: void, value?: T): Ok<T, E>;
    static err<E = undefined, T = any>(this: void, value?: E): Err<E, T>;
    /**
     * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object. This override
     * exists to interoperate with other versions of this class, such as the one coming from another version of this
     * library or from a different build.
     *
     * @param instance The instance to check.
     * @returns Whether or not the instance is a `Result`.
     *
     * @example
     * ```typescript
     * import { Result } from '@sapphire/result';
     * const { ok } = require('@sapphire/result');
     *
     * ok(2) instanceof Result; // true
     * ```
     */
    static [Symbol.hasInstance](instance: unknown): boolean;
    /**
     * @deprecated Use {@link Result.isResult} instead.
     *
     * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.
     *
     * @param instance The instance to check.
     * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.
     *
     * @example
     * ```typescript
     * import { Result } from '@sapphire/result';
     * const { ok } = require('@sapphire/result');
     *
     * Result.isResult(ok(2)); // true
     * ```
     */
    static is(instance: unknown): instance is AnyResult;
    /**
     * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.
     *
     * @param instance The instance to check.
     * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.
     *
     * @example
     * ```typescript
     * import { Result } from '@sapphire/result';
     * const { ok } = require('@sapphire/result');
     *
     * Result.isResult(ok(2)); // true
     * ```
     */
    static isResult(instance: unknown): instance is AnyResult;
    /**
     * Creates a {@link Result} out of a callback.
     *
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    static from<T, E = unknown>(this: void, op: ResultResolvable<T, E> | (() => ResultResolvable<T, E>)): Result<T, E>;
    /**
     * Creates a {@link Result} out of a promise or async callback.
     *
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    static fromAsync<T, E = unknown>(this: void, op: Awaitable<ResultResolvable<T, E>> | (() => Awaitable<ResultResolvable<T, E>>)): Promise<Result<T, E>>;
    /**
     * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first
     * {@link Err} encountered.
     *
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    static all<const Entries extends readonly AnyResult[]>(this: void, results: Entries): Result<UnwrapOkArray<Entries>, UnwrapErrArray<Entries>[number]>;
    /**
     * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.
     *
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    static any<const Entries extends readonly AnyResult[]>(this: void, results: Entries): Result<UnwrapOk<Entries[number]>, UnwrapErrArray<Entries>>;
}
declare namespace Result {
    type Ok<T, E = any> = Result<T, E, true>;
    type Err<E, T = any> = Result<T, E, false>;
    type Any = Result<any, any>;
    type Resolvable<T, E = any, Success extends boolean = boolean> = T | Result<T, E, Success>;
    type UnwrapOk<T extends AnyResult> = T extends Ok<infer S> ? S : never;
    type UnwrapErr<T extends AnyResult> = T extends Err<infer S> ? S : never;
    type UnwrapOkArray<T extends readonly AnyResult[] | []> = {
        -readonly [P in keyof T]: UnwrapOk<T[P]>;
    };
    type UnwrapErrArray<T extends readonly AnyResult[] | []> = {
        -readonly [P in keyof T]: UnwrapErr<T[P]>;
    };
}
declare const ok: typeof Result.ok;
declare const err: typeof Result.err;
type ResultResolvable<T, E = any, Success extends boolean = boolean> = Result.Resolvable<T, E, Success>;
type Ok<T, E = any> = Result.Ok<T, E>;
type Err<E, T = any> = Result.Err<E, T>;
type AnyResult = Result.Any;
type UnwrapOk<T extends AnyResult> = Result.UnwrapOk<T>;
type UnwrapErr<T extends AnyResult> = Result.UnwrapErr<T>;
type UnwrapOkArray<T extends readonly AnyResult[] | []> = Result.UnwrapOkArray<T>;
type UnwrapErrArray<T extends readonly AnyResult[] | []> = Result.UnwrapErrArray<T>;

declare const ValueProperty: unique symbol;
declare const ExistsProperty: unique symbol;
declare class Option<T, Exists extends boolean = boolean> {
    /**
     * Branded value to ensure `Success` is typed correctly.
     * @internal
     */
    protected __STATUS__: Exists;
    private readonly [ValueProperty];
    private readonly [ExistsProperty];
    private constructor();
    /**
     * Returns `true` if the option is a `Some` value.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isSome(), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isSome(), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some}
     */
    isSome(): this is Some<T>;
    /**
     * Returns `true` if the option is a `Some` and the value inside of it matches a predicate.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isSomeAnd((x) => x > 1), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(0);
     * assert.equal(x.isSomeAnd((x) => x > 1), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isSomeAnd((x) => x > 1), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some_and}
     */
    isSomeAnd<R extends T>(cb: (value: T) => value is R): this is Some<R>;
    isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R;
    /**
     * Returns `true` if the option is a `None` value.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isNone(), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isNone(), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none}
     */
    isNone(): this is None;
    /**
     * Returns `true` if the option is a `None` value or the value inside of it matches a predicate.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isNoneOr((x) => x > 1), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(0);
     * assert.equal(x.isNoneOr((x) => x > 1), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isNoneOr((x) => x > 1), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none_or}
     */
    isNoneOr<R extends T>(cb: (value: T) => value is R): this is None | Some<R>;
    isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true>;
    /**
     * Returns the contained `Some` value.
     * @param message The message for the error.
     * If the value is an `Err`, it throws an {@link OptionError} with the given message.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some(2);
     * assert.equal(x.expect('Whoops!'), 2);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.throws(() => x.expect('Whoops!'), {
     *   name: 'OptionError',
     *   message: 'Whoops'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.expect}
     */
    expect(message: string): If<Exists, T, never>;
    /**
     * Returns the contained `Some` value.
     *
     * If the value is an `Err`, it throws an {@link OptionError} with the message.
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     *
     * @example
     * ```typescript
     * const x: Option<string> = some(2);
     * assert.equal(x.unwrap(), 2);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.throws(() => x.unwrap(), {
     *   name: 'OptionError',
     *   message: 'Unwrap failed'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap}
     */
    unwrap(): If<Exists, T, never>;
    /**
     * Returns the contained `Some` value or a provided default.
     *
     * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link unwrapOrElse}, which is lazily evaluated.
     *
     * @example
     * ```typescript
     * assert.equal(some(2).unwrapOr(0), 2);
     * ```
     * @example
     * ```typescript
     * assert.equal(none.unwrapOr(0), 0);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or}
     */
    unwrapOr<OutputValue>(defaultValue: OutputValue): If<Exists, T, OutputValue>;
    /**
     * Returns the contained Some value or computes it from a closure.
     *
     * @example
     * ```typescript
     * assert.equal(some(2).unwrapOrElse(() => 0), 2);
     * ```
     * @example
     * ```typescript
     * assert.equal(none.unwrapOrElse(() => 0), 0);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else}
     */
    unwrapOrElse<OutputValue>(cb: () => OutputValue): If<Exists, T, OutputValue>;
    /**
     * Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const maybeSomeString = some('Hello, world!');
     * const maybeSomeLength = maybeSomeString.map((value) => value.length);
     *
     * assert.equal(maybeSomeLength, some(13));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map}
     */
    map<U>(cb: (value: T) => U): If<Exists, Some<U>, None>;
    /**
     * Maps a `Some<T>` to the returned `Option<U>` by applying a function to a contained value, leaving `None`
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const input: Option<string> = some('Hello, world!');
     * const result = input.mapInto((value) => some(value.length));
     *
     * assert.equal(result, some(13));
     * ```
     * @example
     * ```typescript
     * const input: Option<string> = none;
     * const result = input.mapInto((value) => some(value.length));
     *
     * assert.equal(result, none);
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapInto<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None>;
    /**
     * Returns the provided default result (if none), or applies a function to the contained value (if any).
     *
     * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link mapOrElse}, which is lazily evaluated.
     * @param defaultValue The default value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.mapOr(42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.mapOr(42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or}
     */
    mapOr<MappedOutputValue, DefaultOutputValue>(defaultValue: DefaultOutputValue, cb: (value: T) => MappedOutputValue): If<Exists, MappedOutputValue, DefaultOutputValue>;
    /**
     * Computes a default function result (if none), or applies a different function to the contained value (if any).
     * @param defaultValue The default value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else}
     */
    mapOrElse<OutputValue, OutputNone>(defaultValue: () => OutputNone, cb: (value: T) => OutputValue): If<Exists, OutputValue, OutputNone>;
    /**
     * Maps a `None` to the returned `Option<U>` by applying a function to a contained value, leaving `Some<T>`
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const input: Option<string> = some('Hello, world!');
     * const result = input.mapNoneInto(() => some(13));
     *
     * assert.equal(result, some('Hello, world!'));
     * ```
     * @example
     * ```typescript
     * const input: Option<string> = none;
     * const result = input.mapNoneInto(() => some(13));
     *
     * assert.equal(result, some(13));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapNoneInto<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption>;
    /**
     * Calls the provided closure with a reference to the contained value (if `Some`).
     * @param cb The predicate.
     * @seealso {@link inspectAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * some(2).inspect(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * none.inspect(console.log);
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.inspect}
     */
    inspect(cb: (value: T) => void): this;
    /**
     * Calls the provided closure with a reference to the contained value (if `Some`).
     * @param cb The predicate.
     * @seealso {@link inspect} for the sync version.
     *
     * @example
     * ```typescript
     * await some(2).inspectAsync(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * await none.inspectAsync(console.log);
     * // Doesn't log
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this>;
    /**
     * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err)`.
     *
     * Arguments passed to `okOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link okOrElse}, which is lazily evaluated.
     * @param err The error to be used.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.okOr(0), ok('hello'));
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.okOr(0), err(0));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or}
     */
    okOr<ErrorValue>(error: ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>>;
    /**
     * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err())`.
     * @param cb The error to be used.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.okOrElse(() => 0), ok('hello'));
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.okOrElse(() => 0), err(0));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else}
     */
    okOrElse<ErrorValue>(cb: () => ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>>;
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Some`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = some(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = none;
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link Option.iter}
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}
     */
    iter(): Generator<T>;
    /**
     * Returns `None` if the option is `None`, otherwise returns `option`.
     * @param option The option.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<string> = none;
     * assert.equal(x.and(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<string> = some('foo');
     * assert.equal(x.and(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<string> = some('foo');
     * assert.equal(x.and(y), some('foo'));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<string> = none;
     * assert.equal(x.and(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.and}
     */
    and<OutputOption extends AnyOption>(option: OutputOption): If<Exists, OutputOption, None>;
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * function fractionOf4(value: number) {
     *   return value === 0 ? none : some(4 / value);
     * }
     *
     * assert.equal(some(2).andThen(fractionOf4), some(4));
     * assert.equal(some(0).andThen(fractionOf4), none);
     * assert.equal(none.andThen(fractionOf4), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}
     */
    andThen<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None>;
    /**
     * Returns the option if it contains a value, otherwise returns `option`.
     * @param option The option.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = none;
     * assert.equal(x.or(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = some(100);
     * assert.equal(x.or(y), some(100));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = some(100);
     * assert.equal(x.or(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = none;
     * assert.equal(x.or(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or}
     */
    or<OutputOption extends AnyOption>(option: OutputOption): If<Exists, Some<T>, OutputOption>;
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const nobody = (): Option<string> => none;
     * const vikings = (): Option<string> => some('vikings');
     *
     * assert.equal(some('barbarians').orElse(vikings), some('barbarians'));
     * assert.equal(none.orElse(vikings), some('vikings'));
     * assert.equal(none.orElse(nobody), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or_else}
     */
    orElse<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption>;
    /**
     * Returns `Some` if exactly one of self or `option` is `Some`, otherwise returns `None`.
     * @param option The option to compare.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = none;
     * assert.equal(x.xor(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = some(2);
     * assert.equal(x.xor(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = some(2);
     * assert.equal(x.xor(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = none;
     * assert.equal(x.xor(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.xor}
     */
    xor<OtherValue, OtherExists extends boolean>(option: Option<OtherValue, OtherExists>): If<Exists, If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>>;
    /**
     * Returns None if the option is None, otherwise calls `predicate` with the wrapped value and returns:
     *
     * - `Some(t)` if `predicate` returns `true` (where t is the wrapped value), and
     * - `None` if `predicate` returns `false`.
     * @param predicate The predicate.
     *
     * @example
     * ```typescript
     * function isEven(value: number) {
     *   return n % 2 === 0;
     * }
     *
     * assert.equal(none.filter(isEven), none);
     * assert.equal(some(3).filter(isEven), none);
     * assert.equal(some(4).filter(isEven), some(4));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.filter}
     */
    filter<R extends T>(predicate: (value: T) => value is R): Option<R>;
    filter(predicate: (value: T) => boolean): Option<T>;
    /**
     * Returns `true` if the option is a `Some` value containing the given value.
     * @param value The value to compare.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.contains(2), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(3);
     * assert.equal(x.contains(2), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.contains(2), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.contains}
     */
    contains<const Value extends T>(value: If<Exists, Value, unknown>): this is Some<Value>;
    /**
     * Zips self with another `Option`.
     *
     * If self is `Some(s)` and `other` is `Some(o)`, this method returns `Some([s, o])`. Otherwise, `None` is returned.
     * @param other The option to zip self with.
     *
     * @example
     * ```typescript
     * const x = some(1);
     * const y = some('hi');
     * const z = none;
     *
     * assert.equal(x.zip(y), some([1, 'hi']));
     * assert.equal(x.zip(z), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip}
     */
    zip<OtherValue, OtherExists extends boolean>(other: Option<OtherValue, OtherExists>): Option<[T, OtherValue], If<Exists, OtherExists, false>>;
    /**
     * Zips self and another `Option` with function `f`.
     *
     * If self is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`. Otherwise, `None` is returned.
     * @param other The option to zip self with.
     * @param f The function that computes the returned value.
     *
     * @example
     * ```typescript
     * class Point {
     *   public readonly x: number;
     *   public readonly y: number;
     *
     *   public constructor(x: number, y: number) {
     *     this.x = x;
     *     this.y = y;
     *   }
     * }
     *
     * const x = some(17.5);
     * const y = some(42.7);
     *
     * assert.equal(x.zipWith(y, (s, o) => new Point(s, o)), some(new Point(17.5, 42.7)));
     * assert.equal(x.zipWith(none, (s, o) => new Point(s, o)), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip_with}
     */
    zipWith<OtherValue, OtherExists extends boolean, ReturnValue>(other: Option<OtherValue, OtherExists>, f: (value0: T, value1: OtherValue) => ReturnValue): Option<ReturnValue, If<Exists, OtherExists, false>>;
    /**
     * Unzips an option containing a tuple of two options.
     *
     * If self is `Some([a, b])` this method returns `[Some(a), Some(b)]`. Otherwise, `[None, None]` is returned.
     *
     * @example
     * ```typescript
     * const x: Option<[number, string]> = some([1, 'hi']);
     * assert.equal(x.unzip(), [some(1), some('hi')]);
     * ```
     * @example
     * ```typescript
     * const x: Option<[number, string]> = none;
     * assert.equal(x.unzip(), [none, none]);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unzip}
     */
    unzip<Value0, Value1, Exists extends boolean>(this: Option<readonly [Value0, Value1], Exists>): [Option<Value0, Exists>, Option<Value1, Exists>];
    /**
     * Transposes an `Option` of a `Result` into a `Result` of an `Option`.
     *
     * `none` will be mapped to `ok(none)`. `some(ok(v))` and `some(err(e))` will be mapped to `ok(some(v))` and `err(e)`.
     *
     * @example
     * ```typescript
     * const x: Option<Result<number, Error>> = some(ok(5));
     * const y: Result<Option<number>, Error> = ok(some(5));
     * assert.equal(x.transpose(), y);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose}
     */
    transpose<ResultValue, ResultError, ResultSuccess extends boolean, Exists extends boolean>(this: Option<Result<ResultValue, ResultError, ResultSuccess>, Exists>): If<Exists, Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>>;
    /**
     * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.
     *
     * @example
     * ```typescript
     * const x: Option<Option<number>> = some(some(6));
     * assert.equal(x.flatten(), some(6));
     * ```
     * @example
     * ```typescript
     * const x: Option<Option<number>> = some(none);
     * assert.equal(x.flatten(), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<Option<number>> = none;
     * assert.equal(x.flatten(), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}
     */
    flatten<InnerOption extends AnyOption, Exists extends boolean>(this: Option<InnerOption, Exists>): If<Exists, InnerOption, None>;
    /**
     * Returns a `Promise` object with the awaited value (if `Some`).
     *
     * @example
     * ```typescript
     * let x = some(Promise.resolve(3));
     * assert.equal(await x.intoPromise(), some(3));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    intoPromise(): Promise<Option<Awaited<T>, Exists>>;
    /**
     * Checks whether or not `other` equals with self.
     * @param other The other option to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}
     */
    eq<OtherValue extends T, OtherExists extends boolean>(other: Option<OtherValue, OtherExists>): this is Option<OtherValue, OtherExists>;
    /**
     * Checks whether or not `other` doesn't equal with self.
     * @param other The other option to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}
     */
    ne(other: Option<T, boolean>): boolean;
    /**
     * Runs `ok` function if self is `Ok`, otherwise runs `err` function.
     * @param branches The branches to match.
     *
     * @example
     * ```typescript
     * const option = some(4).match({
     *   some: (v) => v,
     *   none: () => 0
     * });
     * assert.equal(option, 4);
     * ```
     * @example
     * ```typescript
     * const option = none.match({
     *   some: (v) => v,
     *   none: () => 0
     * });
     * assert.equal(option, 0);
     * ```
     */
    match<SomeValue, NoneValue>(branches: {
        some(this: Some<T>, value: T): SomeValue;
        none(this: None): NoneValue;
    }): If<Exists, SomeValue, NoneValue>;
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Some`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = some(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = none;
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link IOption.iter}
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}
     */
    [Symbol.iterator](): Generator<T>;
    get [Symbol.toStringTag](): If<Exists, 'Some', 'None'>;
    static readonly none: Option<any, false>;
    static some<T = undefined>(this: void, value?: T): Some<T>;
    /**
     * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object. This override
     * exists to interoperate with other versions of this class, such as the one coming from another version of this
     * library or from a different build.
     *
     * @param instance The instance to check.
     * @returns Whether or not the instance is a `Option`.
     *
     * @example
     * ```typescript
     * import { Option } from '@sapphire/result';
     * const { some } = require('@sapphire/result');
     *
     * some(2) instanceof Option; // true
     * ```
     */
    static [Symbol.hasInstance](instance: unknown): boolean;
    /**
     * @deprecated Use {@link Option.isOption} instead.
     *
     * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.
     *
     * @param instance The instance to check.
     * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.
     *
     * @example
     * ```typescript
     * import { Option } from '@sapphire/result';
     * const { some } = require('@sapphire/result');
     *
     * Option.isOption(some(2)); // true
     * ```
     */
    static is(instance: unknown): instance is AnyOption;
    /**
     * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.
     *
     * @param instance The instance to check.
     * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.
     *
     * @example
     * ```typescript
     * import { Option } from '@sapphire/result';
     * const { some } = require('@sapphire/result');
     *
     * Option.isOption(some(2)); // true
     * ```
     */
    static isOption(instance: unknown): instance is AnyOption;
    /**
     * Creates a {@link Result} out of a callback.
     *
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    static from<T>(this: void, op: OptionResolvable<T> | (() => OptionResolvable<T>)): Option<T>;
    /**
     * Creates a {@link Result} out of a promise or async callback.
     *
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    static fromAsync<T>(this: void, op: Awaitable<OptionResolvable<T>> | (() => Awaitable<OptionResolvable<T>>)): Promise<Option<T>>;
    /**
     * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first
     * {@link Err} encountered.
     *
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    static all<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSomeArray<Entries>>;
    /**
     * Returns the first encountered {@link Some}, or a {@link None} if none was found.
     *
     * @param options An array of {@link Option}s.
     * @returns A new {@link Option}.
     */
    static any<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSome<Entries[number]>>;
}
declare namespace Option {
    type Some<T> = Option<T, true>;
    type None<T = any> = Option<T, false>;
    type Any = Option<any>;
    type Resolvable<T, Exists extends boolean = boolean> = T | null | undefined | Option<T, Exists>;
    type UnwrapSome<T extends AnyOption> = T extends Some<infer S> ? S : never;
    type UnwrapSomeArray<T extends readonly AnyOption[] | []> = {
        -readonly [P in keyof T]: UnwrapSome<T[P]>;
    };
}
declare const some: typeof Option.some;
declare const none: Option<any, false>;
type OptionResolvable<T, Exists extends boolean = boolean> = Option.Resolvable<T, Exists>;
type Some<T> = Option.Some<T>;
type None<T = any> = Option.None<T>;
type AnyOption = Option.Any;
type UnwrapSome<T extends AnyOption> = Option.UnwrapSome<T>;
type UnwrapSomeArray<T extends readonly AnyOption[] | []> = Option.UnwrapSomeArray<T>;

declare class OptionError extends Error {
    get name(): string;
}

declare class ResultError<E> extends Error {
    readonly value: E;
    constructor(message: string, value: E);
    get name(): string;
}

export { type AnyOption, type AnyResult, type Err, type None, type Ok, Option, OptionError, type OptionResolvable, Result, ResultError, type ResultResolvable, type Some, type UnwrapErr, type UnwrapErrArray, type UnwrapOk, type UnwrapOkArray, type UnwrapSome, type UnwrapSomeArray, err, none, ok, some };
