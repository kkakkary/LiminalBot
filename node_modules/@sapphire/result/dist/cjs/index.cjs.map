{"version":3,"sources":["../../src/lib/common/utils.ts","../../src/lib/OptionError.ts","../../src/lib/ResultError.ts","../../src/lib/Result.ts","../../src/lib/Option.ts"],"names":["value","ValueProperty","_a","_b","resolve"],"mappings":"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","file":"index.cjs","sourcesContent":["export type Awaitable<T> = PromiseLike<T> | T;\n\nexport type If<Value extends boolean, TrueResult, FalseResult> = Value extends true\n\t? TrueResult\n\t: Value extends false\n\t\t? FalseResult\n\t\t: TrueResult | FalseResult;\n\nexport function isFunction<A extends readonly any[], R>(cb: (...args: A) => R): true;\nexport function isFunction(input: any): input is (...args: readonly any[]) => any;\nexport function isFunction(input: any) {\n\treturn typeof input === 'function';\n}\n\nexport function isPromise<T>(input: PromiseLike<T>): true;\nexport function isPromise(input: any): input is PromiseLike<any>;\nexport function isPromise(input: any) {\n\treturn typeof input === 'object' && input !== null && typeof input.then === 'function';\n}\n\nexport function returnThis<U>(this: U): U {\n\treturn this;\n}\n","export class OptionError extends Error {\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","export class ResultError<E> extends Error {\n\tpublic readonly value: E;\n\n\tpublic constructor(message: string, value: E) {\n\t\tsuper(message);\n\t\tthis.value = value;\n\t}\n\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import { isFunction, returnThis, type Awaitable, type If } from './common/utils';\nimport { none, some, type None, type Option, type Some } from './Option';\nimport { ResultError } from './ResultError';\n\nconst ValueProperty = Symbol.for('@sapphire/result:Result.value');\nconst SuccessProperty = Symbol.for('@sapphire/result:Result.success');\n\n/**\n * A type used to express computations that can fail, it can be used for returning and propagating errors. This is a\n * type union with the variants `Ok(T)`, representing success and containing a value, and `Err(E)`, representing error\n * and containing an error value.\n *\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n *\n * @see {@link https://doc.rust-lang.org/std/result/index.html}\n */\nexport class Result<T, E, const Success extends boolean = boolean> {\n\t/**\n\t * Branded value to ensure `Success` is typed correctly.\n\t * @internal\n\t */\n\tprotected declare __STATUS__: Success;\n\n\tprivate readonly [ValueProperty]: If<Success, T, E>;\n\tprivate readonly [SuccessProperty]: Success;\n\n\tprivate constructor(value: If<Success, T, E>, success: Success) {\n\t\tthis[ValueProperty] = value;\n\t\tthis[SuccessProperty] = success;\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Ok`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(-3);\n\t * assert.equal(x.isOk(), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isOk(), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok}\n\t */\n\tpublic isOk(): this is Ok<T, E> {\n\t\treturn this[SuccessProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Ok` and the value inside of it matches a predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.isOkAnd((value) => value > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = ok(0);\n\t * assert.equal(x.isOkAnd((value) => value > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isOkAnd((value) => value > 1), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok_and}\n\t */\n\tpublic isOkAnd<R extends T>(cb: (value: T) => value is R): this is Ok<R, E>;\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R;\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R {\n\t\treturn this.isOk() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Err`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(-3);\n\t * assert.equal(x.isErr(), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isErr(), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err}\n\t */\n\tpublic isErr(): this is Err<E, T> {\n\t\treturn !this[SuccessProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Err` and the value inside of it matches a predicate.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err(new Error('Some error message'));\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err(new TypeError('Some error message'));\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err_and}\n\t */\n\tpublic isErrAnd<R extends E>(cb: (error: E) => error is R): this is Err<R, T>;\n\tpublic isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R;\n\tpublic isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R {\n\t\treturn this.isErr() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Converts from `Result<T, E>` to `Option<T>`.\n\t *\n\t * Converts itself into an `Option<T>`, and discarding the error, if any.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.ok(), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.ok(), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.ok}\n\t */\n\tpublic ok(): If<Success, Some<T>, None> {\n\t\treturn this.match({ ok: (value) => some(value), err: () => none });\n\t}\n\n\t/**\n\t * Converts from `Result<T, E>` to `Option<E>`.\n\t *\n\t * Converts itself into an `Option<E>`, and discarding the successful value, if any.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.err(), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.err(), 'Some error message');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.err}\n\t */\n\tpublic err(): If<Success, None, Some<E>> {\n\t\treturn this.match({ ok: () => none, err: (error) => some(error) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained `Ok` value, leaving an `Err` value\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.map((value) => value * 2), ok(4));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.map((value) => value * 2), err('Some error message'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map}\n\t */\n\tpublic map<OutputValue>(cb: (value: T) => OutputValue): If<Success, Ok<OutputValue, E>, Err<E>> {\n\t\treturn this.match({ ok: (value) => ok(cb(value)), err: returnThis });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Ok` value, leaving an `Err` value\n\t * untouched.\n\t *\n\t * Unlike {@link map}, this method does not wrap the returned value inside `Ok`, but instead, it returns the\n\t * returned value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.mapInto((value) => ok(value * value)), ok(4));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(0);\n\t * assert.equal(\n\t *   x.mapInto((value) => (value === 0 ? err('zero is not divisible') : ok(1 / value))),\n\t *   err('zero is not divisible')\n\t * );\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.mapInto((value) => ok(4)), err('Some error message'));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapInto<OutputResult extends AnyResult>(cb: (value: T) => OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => cb(value), err: returnThis });\n\t}\n\n\t/**\n\t * Returns the provided default (if `Err`), or applies a function to the contained value (if `Ok`),\n\t *\n\t * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use `mapOrElse`, which is lazily evaluated.\n\t * @param defaultValue The default value to use.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok('hello');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or}\n\t */\n\tpublic mapOr<MappedOutputValue, DefaultOutputValue>(\n\t\tdefaultValue: DefaultOutputValue,\n\t\tcb: (value: T) => MappedOutputValue\n\t): If<Success, MappedOutputValue, DefaultOutputValue> {\n\t\treturn this.match({ ok: (value) => cb(value), err: () => defaultValue });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `U` by applying fallback function default to a contained `Err` value, or function `cb`\n\t * to a contained `Ok` value.\n\t *\n\t * This function can be used to unpack a successful result while handling an error.\n\t * @param op The predicate that is run on `Err`.\n\t * @param cb The predicate that is run on `Ok`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<string, string> = ok('hello');\n\t * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<string, string> = err('Some error message');\n\t * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 18);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else}\n\t */\n\tpublic mapOrElse<OutputValue, OutputError>(op: (error: E) => OutputError, cb: (value: T) => OutputValue): If<Success, OutputValue, OutputError> {\n\t\treturn this.match({ ok: (value) => cb(value), err: (error) => op(error) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value\n\t * untouched.\n\t *\n\t * This function can be used to pass through a successful result while handling an error.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = ok(2);\n\t * assert.equal(x.mapErr((error) => error.message), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErr((error) => error.message), err('Some error message'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err}\n\t */\n\tpublic mapErr<OutputError>(cb: (error: E) => OutputError): If<Success, Ok<T>, Err<OutputError>> {\n\t\treturn this.match({ ok: returnThis, err: (error) => err(cb(error)) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value\n\t * untouched.\n\t *\n\t * This function can be used to pass through a successful result while handling an error.\n\t *\n\t * Unlike {@link mapErr}, this method does not wrap the returned value inside `Err`, but instead, it returns the\n\t * returned value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = ok(2);\n\t * assert.equal(x.mapErrInto((error) => err(error.message)), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErrInto((error) => err(error.message)), err('Some error message'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErrInto((error) => ok(4)), ok(4));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapErrInto<OutputResult extends AnyResult>(cb: (error: E) => OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: (error) => cb(error) });\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Ok`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * ok(2).inspect(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * err('Some error message').inspect(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect}\n\t */\n\tpublic inspect(cb: (value: T) => unknown): this {\n\t\tif (this.isOk()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Ok`) and awaits it.\n\t * @param cb The predicate.\n\t * @seealso {@link inspect} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await ok(2).inspectAsync(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await err('Some error message').inspectAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isOk()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained error (if `Err`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectErrAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * ok(2).inspectErr(console.log);\n\t * // Doesn't log\n\t * ```\n\t * @example\n\t * ```typescript\n\t * err('Some error message').inspectErr(console.log);\n\t * // Logs: Some error message\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err}\n\t */\n\tpublic inspectErr(cb: (error: E) => unknown): this {\n\t\tif (this.isErr()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained error (if `Err`) and awaits it.\n\t * @param cb The predicate.\n\t * @seealso {@link inspectErr} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await ok(2).inspectErrAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await err('Some error message').inspectErrAsync(console.log);\n\t * // Logs: Some error message\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isErr()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Ok`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(7);\n\t * for (const value of x.iter()) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Nothing!');\n\t * for (const value of x.iter()) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}\n\t */\n\tpublic *iter(): Generator<T> {\n\t\tif (this.isOk()) yield this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws a {@link ResultError} with the given message and the content of the `Err`.\n\t * @param message The message for the error.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.expect('Whoops!'), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.expect('Whoops!'), {\n\t *   name: 'ResultError',\n\t *   message: 'Whoops',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect}\n\t */\n\tpublic expect(message: string): If<Success, T, never> {\n\t\tif (this.isErr()) throw new ResultError(message, this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, T, never>;\n\t}\n\n\t/**\n\t * Returns the contained `Err` value.\n\t *\n\t * If the value is an `Ok`, it throws a {@link ResultError} with the given message and the content of the `Ok`.\n\t * @param message The message for the error.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.throws(() => x.expectErr('Whoops!'), {\n\t *   name: 'ResultError',\n\t *   message: 'Whoops',\n\t *   value: 2\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.equal(x.expectErr('Whoops!'), 'Emergency failure');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err}\n\t */\n\tpublic expectErr(message: string): If<Success, never, E> {\n\t\tif (this.isOk()) throw new ResultError(message, this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, never, E>;\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws a {@link ResultError} with the message, and the content of the `Err`.\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.unwrap(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.unwrap(), {\n\t *   name: 'ResultError',\n\t *   message: 'Unwrap failed',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap}\n\t */\n\tpublic unwrap(): If<Success, T, never> {\n\t\tif (this.isErr()) throw new ResultError('Unwrap failed', this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, T, never>;\n\t}\n\n\t/**\n\t * Returns the contained `Err` value.\n\t *\n\t * If the value is an `Ok`, it throws a {@link ResultError} with the message, and the content of the `Ok`.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.throws(() => x.unwrapErr(), {\n\t *   name: 'ResultError',\n\t *   message: 'Unwrap failed',\n\t *   value: 2\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.equal(x.unwrapErr(), 'Emergency failure');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err}\n\t */\n\tpublic unwrapErr(): If<Success, never, E> {\n\t\tif (this.isOk()) throw new ResultError('Unwrap failed', this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, never, E>;\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value or the provided default.\n\t *\n\t * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link unwrapOrElse}, which is lazily evaluated.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @param defaultValue The default value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(9);\n\t * assert.equal(x.unwrapOr(2), 9);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Error');\n\t * assert.equal(x.unwrapOr(2), 2);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or}\n\t */\n\tpublic unwrapOr<OutputValue>(defaultValue: OutputValue): If<Success, T, OutputValue> {\n\t\treturn this.match({ ok: (value) => value, err: () => defaultValue });\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value or computes it from a closure.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @param op The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const count = (x: string) => x.length;\n\t *\n\t * assert.equal(ok(2).unwrapOrElse(count), 2);\n\t * assert.equal(err('hello').unwrapOrElse(count), 5);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else}\n\t */\n\tpublic unwrapOrElse<OutputValue>(op: (error: E) => OutputValue): If<Success, T, OutputValue> {\n\t\treturn this.match({ ok: (value) => value, err: (error) => op(error) });\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws the contained error.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.unwrapRaw(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.unwrapRaw(), {\n\t *   name: 'Error',\n\t *   message: 'Unwrap failed',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t */\n\tpublic unwrapRaw(): If<Success, T, never> {\n\t\t// eslint-disable-next-line @typescript-eslint/no-throw-literal\n\t\tif (this.isErr()) throw this[ValueProperty];\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty] as T;\n\t}\n\n\t/**\n\t * Returns `result` if the result is `Ok`, otherwise returns the `Err` value of itself.\n\t * @param result The result to check.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<string, string> = err('Late error');\n\t * assert.equal(x.and(y), err('Late error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<string, string> = err('Late error');\n\t * assert.equal(x.and(y), err('Early error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<string, string> = ok('Hello');\n\t * assert.equal(x.and(y), ok('Hello'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and}\n\t */\n\tpublic and<OutputResult extends AnyResult>(result: OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: () => result, err: returnThis });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function fractionOf4(value: number) {\n\t *   return value === 0 ? err('overflowed') : ok(4 / value);\n\t * }\n\t *\n\t * assert.equal(ok(2).andThen(fractionOf4), ok(4));\n\t * assert.equal(ok(0).andThen(fractionOf4), err('overflowed'));\n\t * assert.equal(err('not a number').andThen(fractionOf4), err('not a number'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}\n\t */\n\tpublic andThen<OutputResult extends AnyResult>(cb: (value: T) => OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => cb(value), err: returnThis });\n\t}\n\n\t/**\n\t * Return `result` if the result is `Err`, otherwise returns the `Ok` value of self.\n\t *\n\t * Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended\n\t * to use {@link orElse}, which is lazily evaluated.\n\t * @param result The result to check.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<number, string> = err('Late error');\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<number, string> = ok(2);\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<number, string> = err('Late error');\n\t * assert.equal(x.or(y), err('Late error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<number, string> = ok(100);\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or}\n\t */\n\tpublic or<OutputResult extends AnyResult>(result: OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: () => result });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Err`, otherwise returns the `Ok` value of self.\n\t *\n\t * This function can be used for control flow based on result values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const square = (x: number): Result<number, string> => ok(x * x);\n\t * const wrapErr = (x: number): Result<number, string> => err(x);\n\t *\n\t * assert.equal(ok(2).orElse(square).orElse(square), ok(2));\n\t * assert.equal(ok(2).orElse(wrapErr).orElse(square), ok(2));\n\t * assert.equal(err(3).orElse(square).orElse(wrapErr), ok(9));\n\t * assert.equal(err(3).orElse(wrapErr).orElse(wrapErr), err(3));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else}\n\t */\n\tpublic orElse<OutputResult extends AnyResult>(cb: (error: E) => OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: (error) => cb(error) });\n\t}\n\n\t/**\n\t * Returns `true` if the result is an `Ok` and the given value strict equals it.\n\t * @param value The value to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.contains(2), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(3);\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains}\n\t */\n\tpublic contains<const Value extends T>(this: Ok<T>, value: Value): this is Ok<Value>;\n\tpublic contains(this: Err<E>, value: T): false;\n\tpublic contains(value: T): boolean {\n\t\treturn this.isOkAnd((inner) => inner === value);\n\t}\n\n\t/**\n\t * Returns `true` if the result is an `Err` and the given error strict equals it.\n\t * @param error The error to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.containsErr('Some error message'), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.containsErr('Some error message'), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some other error message');\n\t * assert.equal(x.containsErr('Some error message'), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains_err}\n\t */\n\tpublic containsErr(this: Ok<T>, error: E): false;\n\tpublic containsErr<const Value extends E>(this: Err<E>, error: Value): this is Err<Value>;\n\tpublic containsErr(error: E): boolean {\n\t\treturn this.isErrAnd((inner) => inner === error);\n\t}\n\n\t/**\n\t * Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n\t *\n\t * `ok(none)` will be mapped to `none`. `ok(some(v))` and `err(e)` will be mapped to `some(ok(v))` and `some(err(e))`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<Option<number>, Error> = ok(some(5));\n\t * const y: Option<Result<number, Error>> = some(ok(5));\n\t * assert.equal(x.transpose(), y);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose}\n\t */\n\tpublic transpose<InnerValue>(this: Result<Option<InnerValue>, E, Success>): If<Success, Option<Ok<InnerValue>>, Some<Err<E>>> {\n\t\treturn this.match({\n\t\t\tok: (value) => value.map((value) => ok(value)),\n\t\t\terr() {\n\t\t\t\treturn some(this);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = ok(ok('Hello'));\n\t * assert.equal(x.flatten(), ok('Hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = ok(err(6));\n\t * assert.equal(x.flatten(), err(6));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = err(6);\n\t * assert.equal(x.flatten(), err(6));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}\n\t */\n\tpublic flatten<InnerResult extends AnyResult>(this: Result<InnerResult, E, Success>): If<Success, InnerResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => value, err: returnThis });\n\t}\n\n\t/**\n\t * Returns the `Ok` value if self is `Ok`, and the `Err` value if self is `Err`.\n\t *\n\t * @example\n\t * ```typescript\n\t * let x: Result<number, number> = ok(3);\n\t * assert.equal(x.intoOkOrErr(), 3);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * let x: Result<number, number> = err(4);\n\t * assert.equal(x.intoOkOrErr(), 4);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.into_ok_or_err}\n\t */\n\tpublic intoOkOrErr(): If<Success, T, E> {\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns a `Promise` object with the awaited value (if `Ok`) or the awaited error (if `Err`).\n\t *\n\t * @example\n\t * ```typescript\n\t * let x = ok(Promise.resolve(3));\n\t * assert.equal(await x.intoPromise(), ok(3));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic intoPromise(): If<Success, Promise<Ok<Awaited<T>>>, Promise<Err<Awaited<E>>>> {\n\t\treturn this.match({\n\t\t\tok: async (value) => ok(await value), // NOSONAR\n\t\t\terr: async (error) => err(await error) // NOSONAR\n\t\t});\n\t}\n\n\t/**\n\t * Checks whether or not `other` equals with self.\n\t * @param other The other result to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}\n\t */\n\tpublic eq<OtherValue extends T, OtherError extends E, OtherSuccess extends boolean>(\n\t\tother: Result<OtherValue, OtherError, OtherSuccess>\n\t): this is Result<OtherValue, OtherError, OtherSuccess> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isOk() === other.isOk() && this[ValueProperty] === other[ValueProperty];\n\t}\n\n\t/**\n\t * Checks whether or not `other` doesn't equal with self.\n\t * @param other The other result to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}\n\t */\n\tpublic ne(other: Result<T, E>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\t/**\n\t * Runs `ok` function if self is `Ok`, otherwise runs `err` function.\n\t * @param branches The branches to match.\n\t *\n\t * @example\n\t * ```typescript\n\t * const result = ok(4).match({\n\t *   ok: (v) => v,\n\t *   err: () => 0\n\t * });\n\t * assert.equal(result, 4);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const result = err('Hello').match({\n\t *   ok: (v) => v,\n\t *   err: () => 0\n\t * });\n\t * assert.equal(result, 0);\n\t * ```\n\t */\n\tpublic match<OkValue, ErrValue>(branches: {\n\t\tok(this: Ok<T>, value: T): OkValue;\n\t\terr(this: Err<E>, error: E): ErrValue;\n\t}): If<Success, OkValue, ErrValue> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isOk() ? branches.ok.call(this, this[ValueProperty]) : branches.err.call(this, this[ValueProperty] as E);\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Ok`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Nothing!');\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link IResult.iter}\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}\n\t */\n\tpublic [Symbol.iterator](): Generator<T> {\n\t\treturn this.iter();\n\t}\n\n\tpublic get [Symbol.toStringTag](): If<Success, 'Ok', 'Err'> {\n\t\treturn this.match({ ok: () => 'Ok', err: () => 'Err' });\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static ok<T = undefined, E = any>(this: void, value?: T): Ok<T, E>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static ok<T, E = any>(this: void, value: T): Ok<T, E> {\n\t\treturn new Result<T, E, true>(value, true);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static err<E = undefined, T = any>(this: void, value?: E): Err<E, T>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static err<E, T = any>(this: void, value: E): Err<E, T> {\n\t\treturn new Result<T, E, false>(value, false);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object. This override\n\t * exists to interoperate with other versions of this class, such as the one coming from another version of this\n\t * library or from a different build.\n\t *\n\t * @param instance The instance to check.\n\t * @returns Whether or not the instance is a `Result`.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * ok(2) instanceof Result; // true\n\t * ```\n\t */\n\tpublic static [Symbol.hasInstance](instance: unknown): boolean {\n\t\treturn typeof instance === 'object' && instance !== null && ValueProperty in instance && SuccessProperty in instance;\n\t}\n\n\t/**\n\t * @deprecated Use {@link Result.isResult} instead.\n\t *\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * Result.isResult(ok(2)); // true\n\t * ```\n\t */\n\tpublic static is(instance: unknown): instance is AnyResult {\n\t\treturn Result[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * Result.isResult(ok(2)); // true\n\t * ```\n\t */\n\tpublic static isResult(instance: unknown): instance is AnyResult {\n\t\treturn Result[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static from<T, E = unknown>(this: void, op: ResultResolvable<T, E> | (() => ResultResolvable<T, E>)): Result<T, E> {\n\t\ttry {\n\t\t\treturn resolve(isFunction(op) ? op() : op);\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\tpublic static async fromAsync<T, E = unknown>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\top: Awaitable<ResultResolvable<T, E>> | (() => Awaitable<ResultResolvable<T, E>>)\n\t): Promise<Result<T, E>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\tpublic static all<const Entries extends readonly AnyResult[]>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\tresults: Entries\n\t): Result<UnwrapOkArray<Entries>, UnwrapErrArray<Entries>[number]> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isErr()) return result;\n\n\t\t\tvalues.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn ok(values as UnwrapOkArray<Entries>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\tpublic static any<const Entries extends readonly AnyResult[]>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\tresults: Entries\n\t): Result<UnwrapOk<Entries[number]>, UnwrapErrArray<Entries>> {\n\t\tconst errors: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isOk()) return result;\n\n\t\t\terrors.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn err(errors as UnwrapErrArray<Entries>);\n\t}\n}\n\nexport namespace Result {\n\texport type Ok<T, E = any> = Result<T, E, true>;\n\texport type Err<E, T = any> = Result<T, E, false>;\n\texport type Any = Result<any, any>;\n\texport type Resolvable<T, E = any, Success extends boolean = boolean> = T | Result<T, E, Success>;\n\texport type UnwrapOk<T extends AnyResult> = T extends Ok<infer S> ? S : never;\n\texport type UnwrapErr<T extends AnyResult> = T extends Err<infer S> ? S : never;\n\n\texport type UnwrapOkArray<T extends readonly AnyResult[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapOk<T[P]>;\n\t};\n\texport type UnwrapErrArray<T extends readonly AnyResult[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapErr<T[P]>;\n\t};\n}\n\nexport const { ok, err } = Result;\n\nfunction resolve<T, E>(value: Result.Resolvable<T, E>): Result<T, E> {\n\treturn Result.isResult(value) ? value : ok(value);\n}\n\nexport type ResultResolvable<T, E = any, Success extends boolean = boolean> = Result.Resolvable<T, E, Success>;\n\nexport type Ok<T, E = any> = Result.Ok<T, E>;\nexport type Err<E, T = any> = Result.Err<E, T>;\nexport type AnyResult = Result.Any;\n\nexport type UnwrapOk<T extends AnyResult> = Result.UnwrapOk<T>;\nexport type UnwrapErr<T extends AnyResult> = Result.UnwrapErr<T>;\n\nexport type UnwrapOkArray<T extends readonly AnyResult[] | []> = Result.UnwrapOkArray<T>;\nexport type UnwrapErrArray<T extends readonly AnyResult[] | []> = Result.UnwrapErrArray<T>;\n","import { isFunction, returnThis, type Awaitable, type If } from './common/utils';\nimport { OptionError } from './OptionError';\nimport { err, ok, Result, type Err, type Ok } from './Result';\n\nconst ValueProperty = Symbol.for('@sapphire/result:Option.value');\nconst ExistsProperty = Symbol.for('@sapphire/result:Option.exists');\n\nexport class Option<T, Exists extends boolean = boolean> {\n\t/**\n\t * Branded value to ensure `Success` is typed correctly.\n\t * @internal\n\t */\n\tprotected declare __STATUS__: Exists;\n\n\tprivate readonly [ValueProperty]: If<Exists, T, null>;\n\tprivate readonly [ExistsProperty]: Exists;\n\n\tprivate constructor(value: If<Exists, T, null>, exists: Exists) {\n\t\tthis[ValueProperty] = value;\n\t\tthis[ExistsProperty] = exists;\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isSome(), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isSome(), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some}\n\t */\n\tpublic isSome(): this is Some<T> {\n\t\treturn this[ExistsProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` and the value inside of it matches a predicate.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isSomeAnd((x) => x > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(0);\n\t * assert.equal(x.isSomeAnd((x) => x > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isSomeAnd((x) => x > 1), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some_and}\n\t */\n\tpublic isSomeAnd<R extends T>(cb: (value: T) => value is R): this is Some<R>;\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R;\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R {\n\t\treturn this.isSome() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `None` value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isNone(), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isNone(), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none}\n\t */\n\tpublic isNone(): this is None {\n\t\treturn !this[ExistsProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `None` value or the value inside of it matches a predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isNoneOr((x) => x > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(0);\n\t * assert.equal(x.isNoneOr((x) => x > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isNoneOr((x) => x > 1), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none_or}\n\t */\n\tpublic isNoneOr<R extends T>(cb: (value: T) => value is R): this is None | Some<R>;\n\tpublic isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true>;\n\tpublic isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => true });\n\t}\n\n\t/**\n\t * Returns the contained `Some` value.\n\t * @param message The message for the error.\n\t * If the value is an `Err`, it throws an {@link OptionError} with the given message.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some(2);\n\t * assert.equal(x.expect('Whoops!'), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.throws(() => x.expect('Whoops!'), {\n\t *   name: 'OptionError',\n\t *   message: 'Whoops'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.expect}\n\t */\n\tpublic expect(message: string): If<Exists, T, never> {\n\t\tif (this.isNone()) throw new OptionError(message);\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Some` value.\n\t *\n\t * If the value is an `Err`, it throws an {@link OptionError} with the message.\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some(2);\n\t * assert.equal(x.unwrap(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.throws(() => x.unwrap(), {\n\t *   name: 'OptionError',\n\t *   message: 'Unwrap failed'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap}\n\t */\n\tpublic unwrap(): If<Exists, T, never> {\n\t\tif (this.isNone()) throw new OptionError('Unwrap failed');\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Some` value or a provided default.\n\t *\n\t * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link unwrapOrElse}, which is lazily evaluated.\n\t *\n\t * @example\n\t * ```typescript\n\t * assert.equal(some(2).unwrapOr(0), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * assert.equal(none.unwrapOr(0), 0);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or}\n\t */\n\tpublic unwrapOr<OutputValue>(defaultValue: OutputValue): If<Exists, T, OutputValue> {\n\t\treturn this.match({ some: (value) => value, none: () => defaultValue });\n\t}\n\n\t/**\n\t * Returns the contained Some value or computes it from a closure.\n\t *\n\t * @example\n\t * ```typescript\n\t * assert.equal(some(2).unwrapOrElse(() => 0), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * assert.equal(none.unwrapOrElse(() => 0), 0);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else}\n\t */\n\tpublic unwrapOrElse<OutputValue>(cb: () => OutputValue): If<Exists, T, OutputValue> {\n\t\treturn this.match({ some: (value) => value, none: cb });\n\t}\n\n\t/**\n\t * Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const maybeSomeString = some('Hello, world!');\n\t * const maybeSomeLength = maybeSomeString.map((value) => value.length);\n\t *\n\t * assert.equal(maybeSomeLength, some(13));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map}\n\t */\n\tpublic map<U>(cb: (value: T) => U): If<Exists, Some<U>, None> {\n\t\treturn this.match({ some: (value) => some(cb(value)), none: returnThis });\n\t}\n\n\t/**\n\t * Maps a `Some<T>` to the returned `Option<U>` by applying a function to a contained value, leaving `None`\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = some('Hello, world!');\n\t * const result = input.mapInto((value) => some(value.length));\n\t *\n\t * assert.equal(result, some(13));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = none;\n\t * const result = input.mapInto((value) => some(value.length));\n\t *\n\t * assert.equal(result, none);\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapInto<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: (value) => cb(value), none: returnThis });\n\t}\n\n\t/**\n\t * Returns the provided default result (if none), or applies a function to the contained value (if any).\n\t *\n\t * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link mapOrElse}, which is lazily evaluated.\n\t * @param defaultValue The default value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.mapOr(42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or}\n\t */\n\tpublic mapOr<MappedOutputValue, DefaultOutputValue>(\n\t\tdefaultValue: DefaultOutputValue,\n\t\tcb: (value: T) => MappedOutputValue\n\t): If<Exists, MappedOutputValue, DefaultOutputValue> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => defaultValue });\n\t}\n\n\t/**\n\t * Computes a default function result (if none), or applies a different function to the contained value (if any).\n\t * @param defaultValue The default value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else}\n\t */\n\tpublic mapOrElse<OutputValue, OutputNone>(defaultValue: () => OutputNone, cb: (value: T) => OutputValue): If<Exists, OutputValue, OutputNone> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => defaultValue() });\n\t}\n\n\t/**\n\t * Maps a `None` to the returned `Option<U>` by applying a function to a contained value, leaving `Some<T>`\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = some('Hello, world!');\n\t * const result = input.mapNoneInto(() => some(13));\n\t *\n\t * assert.equal(result, some('Hello, world!'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = none;\n\t * const result = input.mapNoneInto(() => some(13));\n\t *\n\t * assert.equal(result, some(13));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapNoneInto<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: cb });\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Some`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * some(2).inspect(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * none.inspect(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.inspect}\n\t */\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tif (this.isSome()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Some`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspect} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await some(2).inspectAsync(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await none.inspectAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isSome()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err)`.\n\t *\n\t * Arguments passed to `okOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link okOrElse}, which is lazily evaluated.\n\t * @param err The error to be used.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.okOr(0), ok('hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.okOr(0), err(0));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or}\n\t */\n\tpublic okOr<ErrorValue>(error: ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>> {\n\t\treturn this.match({ some: (value) => ok(value), none: () => err(error) });\n\t}\n\n\t/**\n\t * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err())`.\n\t * @param cb The error to be used.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.okOrElse(() => 0), ok('hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.okOrElse(() => 0), err(0));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else}\n\t */\n\tpublic okOrElse<ErrorValue>(cb: () => ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>> {\n\t\treturn this.match({ some: (value) => ok(value), none: () => err(cb()) });\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Some`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = none;\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link Option.iter}\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}\n\t */\n\tpublic *iter(): Generator<T> {\n\t\tif (this.isSome()) yield this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns `None` if the option is `None`, otherwise returns `option`.\n\t * @param option The option.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<string> = none;\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<string> = some('foo');\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<string> = some('foo');\n\t * assert.equal(x.and(y), some('foo'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<string> = none;\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.and}\n\t */\n\tpublic and<OutputOption extends AnyOption>(option: OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: () => option, none: returnThis });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function fractionOf4(value: number) {\n\t *   return value === 0 ? none : some(4 / value);\n\t * }\n\t *\n\t * assert.equal(some(2).andThen(fractionOf4), some(4));\n\t * assert.equal(some(0).andThen(fractionOf4), none);\n\t * assert.equal(none.andThen(fractionOf4), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}\n\t */\n\tpublic andThen<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: (value) => cb(value), none: returnThis });\n\t}\n\n\t/**\n\t * Returns the option if it contains a value, otherwise returns `option`.\n\t * @param option The option.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = none;\n\t * assert.equal(x.or(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = some(100);\n\t * assert.equal(x.or(y), some(100));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = some(100);\n\t * assert.equal(x.or(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = none;\n\t * assert.equal(x.or(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or}\n\t */\n\tpublic or<OutputOption extends AnyOption>(option: OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: () => option });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const nobody = (): Option<string> => none;\n\t * const vikings = (): Option<string> => some('vikings');\n\t *\n\t * assert.equal(some('barbarians').orElse(vikings), some('barbarians'));\n\t * assert.equal(none.orElse(vikings), some('vikings'));\n\t * assert.equal(none.orElse(nobody), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or_else}\n\t */\n\tpublic orElse<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: () => cb() });\n\t}\n\n\t/**\n\t * Returns `Some` if exactly one of self or `option` is `Some`, otherwise returns `None`.\n\t * @param option The option to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = none;\n\t * assert.equal(x.xor(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = some(2);\n\t * assert.equal(x.xor(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = some(2);\n\t * assert.equal(x.xor(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = none;\n\t * assert.equal(x.xor(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.xor}\n\t */\n\tpublic xor<OtherValue, OtherExists extends boolean>(\n\t\toption: Option<OtherValue, OtherExists>\n\t): If<Exists, If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>> {\n\t\treturn this.match<If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>>({\n\t\t\tsome() {\n\t\t\t\treturn (option.isNone() ? this : none) as If<OtherExists, None, Some<T>>;\n\t\t\t},\n\t\t\tnone: () => option\n\t\t});\n\t}\n\n\t/**\n\t * Returns None if the option is None, otherwise calls `predicate` with the wrapped value and returns:\n\t *\n\t * - `Some(t)` if `predicate` returns `true` (where t is the wrapped value), and\n\t * - `None` if `predicate` returns `false`.\n\t * @param predicate The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function isEven(value: number) {\n\t *   return n % 2 === 0;\n\t * }\n\t *\n\t * assert.equal(none.filter(isEven), none);\n\t * assert.equal(some(3).filter(isEven), none);\n\t * assert.equal(some(4).filter(isEven), some(4));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.filter}\n\t */\n\tpublic filter<R extends T>(predicate: (value: T) => value is R): Option<R>;\n\tpublic filter(predicate: (value: T) => boolean): Option<T>;\n\tpublic filter(predicate: (value: T) => boolean): Option<T> {\n\t\treturn this.isSomeAnd(predicate) ? this : none;\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` value containing the given value.\n\t * @param value The value to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.contains(2), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(3);\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.contains}\n\t */\n\tpublic contains<const Value extends T>(value: If<Exists, Value, unknown>): this is Some<Value> {\n\t\treturn this.isSomeAnd((inner) => inner === value);\n\t}\n\n\t/**\n\t * Zips self with another `Option`.\n\t *\n\t * If self is `Some(s)` and `other` is `Some(o)`, this method returns `Some([s, o])`. Otherwise, `None` is returned.\n\t * @param other The option to zip self with.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(1);\n\t * const y = some('hi');\n\t * const z = none;\n\t *\n\t * assert.equal(x.zip(y), some([1, 'hi']));\n\t * assert.equal(x.zip(z), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip}\n\t */\n\tpublic zip<OtherValue, OtherExists extends boolean>(\n\t\tother: Option<OtherValue, OtherExists>\n\t): Option<[T, OtherValue], If<Exists, OtherExists, false>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() && other.isSome() ? some([this[ValueProperty], other[ValueProperty]] as [T, OtherValue]) : none;\n\t}\n\n\t/**\n\t * Zips self and another `Option` with function `f`.\n\t *\n\t * If self is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`. Otherwise, `None` is returned.\n\t * @param other The option to zip self with.\n\t * @param f The function that computes the returned value.\n\t *\n\t * @example\n\t * ```typescript\n\t * class Point {\n\t *   public readonly x: number;\n\t *   public readonly y: number;\n\t *\n\t *   public constructor(x: number, y: number) {\n\t *     this.x = x;\n\t *     this.y = y;\n\t *   }\n\t * }\n\t *\n\t * const x = some(17.5);\n\t * const y = some(42.7);\n\t *\n\t * assert.equal(x.zipWith(y, (s, o) => new Point(s, o)), some(new Point(17.5, 42.7)));\n\t * assert.equal(x.zipWith(none, (s, o) => new Point(s, o)), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip_with}\n\t */\n\tpublic zipWith<OtherValue, OtherExists extends boolean, ReturnValue>(\n\t\tother: Option<OtherValue, OtherExists>,\n\t\tf: (value0: T, value1: OtherValue) => ReturnValue\n\t): Option<ReturnValue, If<Exists, OtherExists, false>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() && other.isSome() ? some(f(this[ValueProperty], other[ValueProperty])) : none;\n\t}\n\n\t/**\n\t * Unzips an option containing a tuple of two options.\n\t *\n\t * If self is `Some([a, b])` this method returns `[Some(a), Some(b)]`. Otherwise, `[None, None]` is returned.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<[number, string]> = some([1, 'hi']);\n\t * assert.equal(x.unzip(), [some(1), some('hi')]);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<[number, string]> = none;\n\t * assert.equal(x.unzip(), [none, none]);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unzip}\n\t */\n\tpublic unzip<Value0, Value1, Exists extends boolean>(\n\t\tthis: Option<readonly [Value0, Value1], Exists>\n\t): [Option<Value0, Exists>, Option<Value1, Exists>] {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({\n\t\t\tsome: ([value0, value1]) => [some(value0), some(value1)],\n\t\t\tnone: () => [none, none]\n\t\t});\n\t}\n\n\t/**\n\t * Transposes an `Option` of a `Result` into a `Result` of an `Option`.\n\t *\n\t * `none` will be mapped to `ok(none)`. `some(ok(v))` and `some(err(e))` will be mapped to `ok(some(v))` and `err(e)`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<Result<number, Error>> = some(ok(5));\n\t * const y: Result<Option<number>, Error> = ok(some(5));\n\t * assert.equal(x.transpose(), y);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose}\n\t */\n\tpublic transpose<ResultValue, ResultError, ResultSuccess extends boolean, Exists extends boolean>(\n\t\tthis: Option<Result<ResultValue, ResultError, ResultSuccess>, Exists>\n\t): If<Exists, Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>> {\n\t\treturn this.match<Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>>({\n\t\t\t// @ts-expect-error Complex types\n\t\t\tsome: (result) => result.map(some),\n\t\t\tnone: () => ok(none)\n\t\t});\n\t}\n\n\t/**\n\t * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = some(some(6));\n\t * assert.equal(x.flatten(), some(6));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = some(none);\n\t * assert.equal(x.flatten(), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = none;\n\t * assert.equal(x.flatten(), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}\n\t */\n\tpublic flatten<InnerOption extends AnyOption, Exists extends boolean>(this: Option<InnerOption, Exists>): If<Exists, InnerOption, None> {\n\t\treturn this.match({ some: (inner) => inner, none: returnThis });\n\t}\n\n\t/**\n\t * Returns a `Promise` object with the awaited value (if `Some`).\n\t *\n\t * @example\n\t * ```typescript\n\t * let x = some(Promise.resolve(3));\n\t * assert.equal(await x.intoPromise(), some(3));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic intoPromise(): Promise<Option<Awaited<T>, Exists>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({\n\t\t\tsome: async (value) => some(await value), // NOSONAR\n\t\t\tnone: () => Promise.resolve(none)\n\t\t});\n\t}\n\n\t/**\n\t * Checks whether or not `other` equals with self.\n\t * @param other The other option to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}\n\t */\n\tpublic eq<OtherValue extends T, OtherExists extends boolean>(other: Option<OtherValue, OtherExists>): this is Option<OtherValue, OtherExists> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() === other.isSome() && this[ValueProperty] === other[ValueProperty];\n\t}\n\n\t/**\n\t * Checks whether or not `other` doesn't equal with self.\n\t * @param other The other option to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}\n\t */\n\tpublic ne(other: Option<T, boolean>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\t/**\n\t * Runs `ok` function if self is `Ok`, otherwise runs `err` function.\n\t * @param branches The branches to match.\n\t *\n\t * @example\n\t * ```typescript\n\t * const option = some(4).match({\n\t *   some: (v) => v,\n\t *   none: () => 0\n\t * });\n\t * assert.equal(option, 4);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const option = none.match({\n\t *   some: (v) => v,\n\t *   none: () => 0\n\t * });\n\t * assert.equal(option, 0);\n\t * ```\n\t */\n\tpublic match<SomeValue, NoneValue>(branches: {\n\t\tsome(this: Some<T>, value: T): SomeValue;\n\t\tnone(this: None): NoneValue;\n\t}): If<Exists, SomeValue, NoneValue> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() ? branches.some.call(this, this[ValueProperty]) : branches.none.call(this);\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Some`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = none;\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link IOption.iter}\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}\n\t */\n\tpublic [Symbol.iterator](): Generator<T> {\n\t\treturn this.iter();\n\t}\n\n\tpublic get [Symbol.toStringTag](): If<Exists, 'Some', 'None'> {\n\t\treturn this.match({ some: () => 'Some', none: () => 'None' });\n\t}\n\n\tpublic static readonly none = new Option<any, false>(null, false);\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static some<T = undefined>(this: void, value?: T): Some<T>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static some<T>(this: void, value: T): Some<T> {\n\t\treturn new Option<T, true>(value, true);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object. This override\n\t * exists to interoperate with other versions of this class, such as the one coming from another version of this\n\t * library or from a different build.\n\t *\n\t * @param instance The instance to check.\n\t * @returns Whether or not the instance is a `Option`.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * some(2) instanceof Option; // true\n\t * ```\n\t */\n\tpublic static [Symbol.hasInstance](instance: unknown): boolean {\n\t\treturn typeof instance === 'object' && instance !== null && ValueProperty in instance && ExistsProperty in instance;\n\t}\n\n\t/**\n\t * @deprecated Use {@link Option.isOption} instead.\n\t *\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * Option.isOption(some(2)); // true\n\t * ```\n\t */\n\tpublic static is(instance: unknown): instance is AnyOption {\n\t\treturn Option[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * Option.isOption(some(2)); // true\n\t * ```\n\t */\n\tpublic static isOption(instance: unknown): instance is AnyOption {\n\t\treturn Option[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static from<T>(this: void, op: OptionResolvable<T> | (() => OptionResolvable<T>)): Option<T> {\n\t\ttry {\n\t\t\treturn resolve(isFunction(op) ? op() : op);\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static async fromAsync<T>(this: void, op: Awaitable<OptionResolvable<T>> | (() => Awaitable<OptionResolvable<T>>)): Promise<Option<T>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static all<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSomeArray<Entries>> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isNone()) return result;\n\n\t\t\tvalues.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn some(values as UnwrapSomeArray<Entries>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Some}, or a {@link None} if none was found.\n\t *\n\t * @param options An array of {@link Option}s.\n\t * @returns A new {@link Option}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static any<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSome<Entries[number]>> {\n\t\tfor (const result of results) {\n\t\t\tif (result.isSome()) return result;\n\t\t}\n\n\t\treturn none;\n\t}\n}\n\nexport namespace Option {\n\texport type Some<T> = Option<T, true>;\n\texport type None<T = any> = Option<T, false>;\n\texport type Any = Option<any>;\n\texport type Resolvable<T, Exists extends boolean = boolean> = T | null | undefined | Option<T, Exists>;\n\texport type UnwrapSome<T extends AnyOption> = T extends Some<infer S> ? S : never;\n\texport type UnwrapSomeArray<T extends readonly AnyOption[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapSome<T[P]>;\n\t};\n}\n\nexport const { some, none } = Option;\n\nfunction resolve<T>(value: Option.Resolvable<T>): Option<T> {\n\tif (value === null || value === undefined) return none;\n\tif (Option.isOption(value)) return value;\n\treturn some(value);\n}\n\nexport type OptionResolvable<T, Exists extends boolean = boolean> = Option.Resolvable<T, Exists>;\n\nexport type Some<T> = Option.Some<T>;\nexport type None<T = any> = Option.None<T>;\nexport type AnyOption = Option.Any;\n\nexport type UnwrapSome<T extends AnyOption> = Option.UnwrapSome<T>;\nexport type UnwrapSomeArray<T extends readonly AnyOption[] | []> = Option.UnwrapSomeArray<T>;\n"]}