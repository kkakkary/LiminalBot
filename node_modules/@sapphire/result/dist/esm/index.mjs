var __defProp = Object.defineProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// src/lib/common/utils.ts
function isFunction(input) {
  return typeof input === "function";
}
__name(isFunction, "isFunction");
function returnThis() {
  return this;
}
__name(returnThis, "returnThis");

// src/lib/OptionError.ts
var _OptionError = class _OptionError extends Error {
  get name() {
    return this.constructor.name;
  }
};
__name(_OptionError, "OptionError");
var OptionError = _OptionError;

// src/lib/ResultError.ts
var _ResultError = class _ResultError extends Error {
  constructor(message, value) {
    super(message);
    __publicField(this, "value");
    this.value = value;
  }
  get name() {
    return this.constructor.name;
  }
};
__name(_ResultError, "ResultError");
var ResultError = _ResultError;

// src/lib/Result.ts
var ValueProperty = Symbol.for("@sapphire/result:Result.value");
var SuccessProperty = Symbol.for("@sapphire/result:Result.success");
var _a, _b;
var _Result = class _Result {
  constructor(value, success) {
    __publicField(this, _b);
    __publicField(this, _a);
    this[ValueProperty] = value;
    this[SuccessProperty] = success;
  }
  /**
   * Returns `true` if the result is `Ok`.
   *
   * @example
   * ```typescript
   * const x = ok(-3);
   * assert.equal(x.isOk(), true);
   * ```
   * @example
   * ```typescript
   * const x = err('Some error message');
   * assert.equal(x.isOk(), false);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok}
   */
  isOk() {
    return this[SuccessProperty];
  }
  isOkAnd(cb) {
    return this.isOk() && cb(this[ValueProperty]);
  }
  /**
   * Returns `true` if the result is `Err`.
   *
   * @example
   * ```typescript
   * const x = ok(-3);
   * assert.equal(x.isErr(), false);
   * ```
   * @example
   * ```typescript
   * const x = err('Some error message');
   * assert.equal(x.isErr(), true);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err}
   */
  isErr() {
    return !this[SuccessProperty];
  }
  isErrAnd(cb) {
    return this.isErr() && cb(this[ValueProperty]);
  }
  /**
   * Converts from `Result<T, E>` to `Option<T>`.
   *
   * Converts itself into an `Option<T>`, and discarding the error, if any.
   *
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(2);
   * assert.equal(x.ok(), some(2));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = err('Some error message');
   * assert.equal(x.ok(), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.ok}
   */
  ok() {
    return this.match({ ok: /* @__PURE__ */ __name((value) => some(value), "ok"), err: /* @__PURE__ */ __name(() => none, "err") });
  }
  /**
   * Converts from `Result<T, E>` to `Option<E>`.
   *
   * Converts itself into an `Option<E>`, and discarding the successful value, if any.
   *
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(2);
   * assert.equal(x.err(), none);
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = err('Some error message');
   * assert.equal(x.err(), 'Some error message');
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.err}
   */
  err() {
    return this.match({ ok: /* @__PURE__ */ __name(() => none, "ok"), err: /* @__PURE__ */ __name((error) => some(error), "err") });
  }
  /**
   * Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained `Ok` value, leaving an `Err` value
   * untouched.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(2);
   * assert.equal(x.map((value) => value * 2), ok(4));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = err('Some error message');
   * assert.equal(x.map((value) => value * 2), err('Some error message'));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map}
   */
  map(cb) {
    return this.match({ ok: /* @__PURE__ */ __name((value) => ok(cb(value)), "ok"), err: returnThis });
  }
  /**
   * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Ok` value, leaving an `Err` value
   * untouched.
   *
   * Unlike {@link map}, this method does not wrap the returned value inside `Ok`, but instead, it returns the
   * returned value.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(2);
   * assert.equal(x.mapInto((value) => ok(value * value)), ok(4));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(0);
   * assert.equal(
   *   x.mapInto((value) => (value === 0 ? err('zero is not divisible') : ok(1 / value))),
   *   err('zero is not divisible')
   * );
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = err('Some error message');
   * assert.equal(x.mapInto((value) => ok(4)), err('Some error message'));
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  mapInto(cb) {
    return this.match({ ok: /* @__PURE__ */ __name((value) => cb(value), "ok"), err: returnThis });
  }
  /**
   * Returns the provided default (if `Err`), or applies a function to the contained value (if `Ok`),
   *
   * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is
   * recommended to use `mapOrElse`, which is lazily evaluated.
   * @param defaultValue The default value to use.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const x = ok('hello');
   * assert.equal(x.mapOr(42, (value) => value.length), 5);
   * ```
   * @example
   * ```typescript
   * const x = err('Some error message');
   * assert.equal(x.mapOr(42, (value) => value.length), 42);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or}
   */
  mapOr(defaultValue, cb) {
    return this.match({ ok: /* @__PURE__ */ __name((value) => cb(value), "ok"), err: /* @__PURE__ */ __name(() => defaultValue, "err") });
  }
  /**
   * Maps a `Result<T, E>` to `U` by applying fallback function default to a contained `Err` value, or function `cb`
   * to a contained `Ok` value.
   *
   * This function can be used to unpack a successful result while handling an error.
   * @param op The predicate that is run on `Err`.
   * @param cb The predicate that is run on `Ok`.
   *
   * @example
   * ```typescript
   * const x: Result<string, string> = ok('hello');
   * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 5);
   * ```
   * @example
   * ```typescript
   * const x: Result<string, string> = err('Some error message');
   * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 18);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else}
   */
  mapOrElse(op, cb) {
    return this.match({ ok: /* @__PURE__ */ __name((value) => cb(value), "ok"), err: /* @__PURE__ */ __name((error) => op(error), "err") });
  }
  /**
   * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value
   * untouched.
   *
   * This function can be used to pass through a successful result while handling an error.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const x: Result<number, Error> = ok(2);
   * assert.equal(x.mapErr((error) => error.message), ok(2));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, Error> = err(new Error('Some error message'));
   * assert.equal(x.mapErr((error) => error.message), err('Some error message'));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err}
   */
  mapErr(cb) {
    return this.match({ ok: returnThis, err: /* @__PURE__ */ __name((error) => err(cb(error)), "err") });
  }
  /**
   * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value
   * untouched.
   *
   * This function can be used to pass through a successful result while handling an error.
   *
   * Unlike {@link mapErr}, this method does not wrap the returned value inside `Err`, but instead, it returns the
   * returned value.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const x: Result<number, Error> = ok(2);
   * assert.equal(x.mapErrInto((error) => err(error.message)), ok(2));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, Error> = err(new Error('Some error message'));
   * assert.equal(x.mapErrInto((error) => err(error.message)), err('Some error message'));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, Error> = err(new Error('Some error message'));
   * assert.equal(x.mapErrInto((error) => ok(4)), ok(4));
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  mapErrInto(cb) {
    return this.match({ ok: returnThis, err: /* @__PURE__ */ __name((error) => cb(error), "err") });
  }
  /**
   * Calls the provided closure with a reference to the contained value (if `Ok`).
   * @param cb The predicate.
   * @seealso {@link inspectAsync} for the awaitable version.
   *
   * @example
   * ```typescript
   * ok(2).inspect(console.log);
   * // Logs: 2
   * ```
   * @example
   * ```typescript
   * err('Some error message').inspect(console.log);
   * // Doesn't log
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect}
   */
  inspect(cb) {
    if (this.isOk()) cb(this[ValueProperty]);
    return this;
  }
  /**
   * Calls the provided closure with a reference to the contained value (if `Ok`) and awaits it.
   * @param cb The predicate.
   * @seealso {@link inspect} for the sync version.
   *
   * @example
   * ```typescript
   * await ok(2).inspectAsync(console.log);
   * // Logs: 2
   * ```
   * @example
   * ```typescript
   * await err('Some error message').inspectAsync(console.log);
   * // Doesn't log
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  async inspectAsync(cb) {
    if (this.isOk()) await cb(this[ValueProperty]);
    return this;
  }
  /**
   * Calls the provided closure with a reference to the contained error (if `Err`).
   * @param cb The predicate.
   * @seealso {@link inspectErrAsync} for the awaitable version.
   *
   * @example
   * ```typescript
   * ok(2).inspectErr(console.log);
   * // Doesn't log
   * ```
   * @example
   * ```typescript
   * err('Some error message').inspectErr(console.log);
   * // Logs: Some error message
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err}
   */
  inspectErr(cb) {
    if (this.isErr()) cb(this[ValueProperty]);
    return this;
  }
  /**
   * Calls the provided closure with a reference to the contained error (if `Err`) and awaits it.
   * @param cb The predicate.
   * @seealso {@link inspectErr} for the sync version.
   *
   * @example
   * ```typescript
   * await ok(2).inspectErrAsync(console.log);
   * // Doesn't log
   * ```
   * @example
   * ```typescript
   * await err('Some error message').inspectErrAsync(console.log);
   * // Logs: Some error message
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  async inspectErrAsync(cb) {
    if (this.isErr()) await cb(this[ValueProperty]);
    return this;
  }
  /**
   * Returns an iterator over the possibly contained value.
   *
   * The iterator yields one value if the result is `Ok`, otherwise none.
   *
   * @example
   * ```typescript
   * const x = ok(7);
   * for (const value of x.iter()) {
   *   console.log(value);
   * }
   * // Logs 7
   * ```
   * @example
   * ```typescript
   * const x = err('Nothing!');
   * for (const value of x.iter()) {
   *   console.log(value);
   * }
   * // Doesn't log
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}
   */
  *iter() {
    if (this.isOk()) yield this[ValueProperty];
  }
  /**
   * Returns the contained `Ok` value.
   *
   * If the value is an `Err`, it throws a {@link ResultError} with the given message and the content of the `Err`.
   * @param message The message for the error.
   *
   * @example
   * ```typescript
   * const x = ok(2);
   * assert.equal(x.expect('Whoops!'), 2);
   * ```
   * @example
   * ```typescript
   * const x = err('Emergency failure');
   * assert.throws(() => x.expect('Whoops!'), {
   *   name: 'ResultError',
   *   message: 'Whoops',
   *   value: 'Emergency failure'
   * });
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect}
   */
  expect(message) {
    if (this.isErr()) throw new ResultError(message, this[ValueProperty]);
    return this[ValueProperty];
  }
  /**
   * Returns the contained `Err` value.
   *
   * If the value is an `Ok`, it throws a {@link ResultError} with the given message and the content of the `Ok`.
   * @param message The message for the error.
   *
   * @example
   * ```typescript
   * const x = ok(2);
   * assert.throws(() => x.expectErr('Whoops!'), {
   *   name: 'ResultError',
   *   message: 'Whoops',
   *   value: 2
   * });
   * ```
   * @example
   * ```typescript
   * const x = err('Emergency failure');
   * assert.equal(x.expectErr('Whoops!'), 'Emergency failure');
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err}
   */
  expectErr(message) {
    if (this.isOk()) throw new ResultError(message, this[ValueProperty]);
    return this[ValueProperty];
  }
  /**
   * Returns the contained `Ok` value.
   *
   * If the value is an `Err`, it throws a {@link ResultError} with the message, and the content of the `Err`.
   * @seealso {@link unwrapOr}
   * @seealso {@link unwrapOrElse}
   * @seealso {@link unwrapErr}
   * @seealso {@link unwrapRaw}
   *
   * @example
   * ```typescript
   * const x = ok(2);
   * assert.equal(x.unwrap(), 2);
   * ```
   * @example
   * ```typescript
   * const x = err('Emergency failure');
   * assert.throws(() => x.unwrap(), {
   *   name: 'ResultError',
   *   message: 'Unwrap failed',
   *   value: 'Emergency failure'
   * });
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap}
   */
  unwrap() {
    if (this.isErr()) throw new ResultError("Unwrap failed", this[ValueProperty]);
    return this[ValueProperty];
  }
  /**
   * Returns the contained `Err` value.
   *
   * If the value is an `Ok`, it throws a {@link ResultError} with the message, and the content of the `Ok`.
   * @seealso {@link unwrap}
   * @seealso {@link unwrapOr}
   * @seealso {@link unwrapOrElse}
   * @seealso {@link unwrapRaw}
   *
   * @example
   * ```typescript
   * const x = ok(2);
   * assert.throws(() => x.unwrapErr(), {
   *   name: 'ResultError',
   *   message: 'Unwrap failed',
   *   value: 2
   * });
   * ```
   * @example
   * ```typescript
   * const x = err('Emergency failure');
   * assert.equal(x.unwrapErr(), 'Emergency failure');
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err}
   */
  unwrapErr() {
    if (this.isOk()) throw new ResultError("Unwrap failed", this[ValueProperty]);
    return this[ValueProperty];
  }
  /**
   * Returns the contained `Ok` value or the provided default.
   *
   * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is
   * recommended to use {@link unwrapOrElse}, which is lazily evaluated.
   * @seealso {@link unwrap}
   * @seealso {@link unwrapOrElse}
   * @seealso {@link unwrapErr}
   * @seealso {@link unwrapRaw}
   *
   * @param defaultValue The default value.
   *
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(9);
   * assert.equal(x.unwrapOr(2), 9);
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = err('Error');
   * assert.equal(x.unwrapOr(2), 2);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or}
   */
  unwrapOr(defaultValue) {
    return this.match({ ok: /* @__PURE__ */ __name((value) => value, "ok"), err: /* @__PURE__ */ __name(() => defaultValue, "err") });
  }
  /**
   * Returns the contained `Ok` value or computes it from a closure.
   * @seealso {@link unwrap}
   * @seealso {@link unwrapOr}
   * @seealso {@link unwrapErr}
   * @seealso {@link unwrapRaw}
   *
   * @param op The predicate.
   *
   * @example
   * ```typescript
   * const count = (x: string) => x.length;
   *
   * assert.equal(ok(2).unwrapOrElse(count), 2);
   * assert.equal(err('hello').unwrapOrElse(count), 5);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else}
   */
  unwrapOrElse(op) {
    return this.match({ ok: /* @__PURE__ */ __name((value) => value, "ok"), err: /* @__PURE__ */ __name((error) => op(error), "err") });
  }
  /**
   * Returns the contained `Ok` value.
   *
   * If the value is an `Err`, it throws the contained error.
   * @seealso {@link unwrap}
   * @seealso {@link unwrapOr}
   * @seealso {@link unwrapOrElse}
   * @seealso {@link unwrapErr}
   *
   * @example
   * ```typescript
   * const x = ok(2);
   * assert.equal(x.unwrapRaw(), 2);
   * ```
   * @example
   * ```typescript
   * const x = err('Emergency failure');
   * assert.throws(() => x.unwrapRaw(), {
   *   name: 'Error',
   *   message: 'Unwrap failed',
   *   value: 'Emergency failure'
   * });
   * ```
   */
  unwrapRaw() {
    if (this.isErr()) throw this[ValueProperty];
    return this[ValueProperty];
  }
  /**
   * Returns `result` if the result is `Ok`, otherwise returns the `Err` value of itself.
   * @param result The result to check.
   *
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(2);
   * const y: Result<string, string> = err('Late error');
   * assert.equal(x.and(y), err('Late error'));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = err('Early error');
   * const y: Result<string, string> = err('Late error');
   * assert.equal(x.and(y), err('Early error'));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(2);
   * const y: Result<string, string> = ok('Hello');
   * assert.equal(x.and(y), ok('Hello'));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and}
   */
  and(result) {
    return this.match({ ok: /* @__PURE__ */ __name(() => result, "ok"), err: returnThis });
  }
  /**
   * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
   *
   * This function can be used for control flow based on `Result` values.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * function fractionOf4(value: number) {
   *   return value === 0 ? err('overflowed') : ok(4 / value);
   * }
   *
   * assert.equal(ok(2).andThen(fractionOf4), ok(4));
   * assert.equal(ok(0).andThen(fractionOf4), err('overflowed'));
   * assert.equal(err('not a number').andThen(fractionOf4), err('not a number'));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}
   */
  andThen(cb) {
    return this.match({ ok: /* @__PURE__ */ __name((value) => cb(value), "ok"), err: returnThis });
  }
  /**
   * Return `result` if the result is `Err`, otherwise returns the `Ok` value of self.
   *
   * Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended
   * to use {@link orElse}, which is lazily evaluated.
   * @param result The result to check.
   *
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(2);
   * const y: Result<number, string> = err('Late error');
   * assert.equal(x.or(y), ok(2));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = err('Early error');
   * const y: Result<number, string> = ok(2);
   * assert.equal(x.or(y), ok(2));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = err('Early error');
   * const y: Result<number, string> = err('Late error');
   * assert.equal(x.or(y), err('Late error'));
   * ```
   * @example
   * ```typescript
   * const x: Result<number, string> = ok(2);
   * const y: Result<number, string> = ok(100);
   * assert.equal(x.or(y), ok(2));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or}
   */
  or(result) {
    return this.match({ ok: returnThis, err: /* @__PURE__ */ __name(() => result, "err") });
  }
  /**
   * Calls `cb` if the result is `Err`, otherwise returns the `Ok` value of self.
   *
   * This function can be used for control flow based on result values.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const square = (x: number): Result<number, string> => ok(x * x);
   * const wrapErr = (x: number): Result<number, string> => err(x);
   *
   * assert.equal(ok(2).orElse(square).orElse(square), ok(2));
   * assert.equal(ok(2).orElse(wrapErr).orElse(square), ok(2));
   * assert.equal(err(3).orElse(square).orElse(wrapErr), ok(9));
   * assert.equal(err(3).orElse(wrapErr).orElse(wrapErr), err(3));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else}
   */
  orElse(cb) {
    return this.match({ ok: returnThis, err: /* @__PURE__ */ __name((error) => cb(error), "err") });
  }
  contains(value) {
    return this.isOkAnd((inner) => inner === value);
  }
  containsErr(error) {
    return this.isErrAnd((inner) => inner === error);
  }
  /**
   * Transposes a `Result` of an `Option` into an `Option` of a `Result`.
   *
   * `ok(none)` will be mapped to `none`. `ok(some(v))` and `err(e)` will be mapped to `some(ok(v))` and `some(err(e))`.
   *
   * @example
   * ```typescript
   * const x: Result<Option<number>, Error> = ok(some(5));
   * const y: Option<Result<number, Error>> = some(ok(5));
   * assert.equal(x.transpose(), y);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose}
   */
  transpose() {
    return this.match({
      ok: /* @__PURE__ */ __name((value) => value.map((value2) => ok(value2)), "ok"),
      err() {
        return some(this);
      }
    });
  }
  /**
   * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.
   *
   * @example
   * ```typescript
   * const x: Result<Result<string, number>, number> = ok(ok('Hello'));
   * assert.equal(x.flatten(), ok('Hello'));
   * ```
   * @example
   * ```typescript
   * const x: Result<Result<string, number>, number> = ok(err(6));
   * assert.equal(x.flatten(), err(6));
   * ```
   * @example
   * ```typescript
   * const x: Result<Result<string, number>, number> = err(6);
   * assert.equal(x.flatten(), err(6));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}
   */
  flatten() {
    return this.match({ ok: /* @__PURE__ */ __name((value) => value, "ok"), err: returnThis });
  }
  /**
   * Returns the `Ok` value if self is `Ok`, and the `Err` value if self is `Err`.
   *
   * @example
   * ```typescript
   * let x: Result<number, number> = ok(3);
   * assert.equal(x.intoOkOrErr(), 3);
   * ```
   * @example
   * ```typescript
   * let x: Result<number, number> = err(4);
   * assert.equal(x.intoOkOrErr(), 4);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.into_ok_or_err}
   */
  intoOkOrErr() {
    return this[ValueProperty];
  }
  /**
   * Returns a `Promise` object with the awaited value (if `Ok`) or the awaited error (if `Err`).
   *
   * @example
   * ```typescript
   * let x = ok(Promise.resolve(3));
   * assert.equal(await x.intoPromise(), ok(3));
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  intoPromise() {
    return this.match({
      ok: /* @__PURE__ */ __name(async (value) => ok(await value), "ok"),
      // NOSONAR
      err: /* @__PURE__ */ __name(async (error) => err(await error), "err")
      // NOSONAR
    });
  }
  /**
   * Checks whether or not `other` equals with self.
   * @param other The other result to compare.
   *
   * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}
   */
  eq(other) {
    return this.isOk() === other.isOk() && this[ValueProperty] === other[ValueProperty];
  }
  /**
   * Checks whether or not `other` doesn't equal with self.
   * @param other The other result to compare.
   *
   * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}
   */
  ne(other) {
    return !this.eq(other);
  }
  /**
   * Runs `ok` function if self is `Ok`, otherwise runs `err` function.
   * @param branches The branches to match.
   *
   * @example
   * ```typescript
   * const result = ok(4).match({
   *   ok: (v) => v,
   *   err: () => 0
   * });
   * assert.equal(result, 4);
   * ```
   * @example
   * ```typescript
   * const result = err('Hello').match({
   *   ok: (v) => v,
   *   err: () => 0
   * });
   * assert.equal(result, 0);
   * ```
   */
  match(branches) {
    return this.isOk() ? branches.ok.call(this, this[ValueProperty]) : branches.err.call(this, this[ValueProperty]);
  }
  /**
   * Returns an iterator over the possibly contained value.
   *
   * The iterator yields one value if the result is `Ok`, otherwise none.
   *
   * @example
   * ```typescript
   * const x = ok(7);
   * for (const value of x) {
   *   console.log(value);
   * }
   * // Logs 7
   * ```
   * @example
   * ```typescript
   * const x = err('Nothing!');
   * for (const value of x) {
   *   console.log(value);
   * }
   * // Doesn't log
   * ```
   *
   * @see {@link IResult.iter}
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}
   */
  [(_b = ValueProperty, _a = SuccessProperty, Symbol.iterator)]() {
    return this.iter();
  }
  get [Symbol.toStringTag]() {
    return this.match({ ok: /* @__PURE__ */ __name(() => "Ok", "ok"), err: /* @__PURE__ */ __name(() => "Err", "err") });
  }
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  static ok(value) {
    return new _Result(value, true);
  }
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  static err(value) {
    return new _Result(value, false);
  }
  /**
   * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object. This override
   * exists to interoperate with other versions of this class, such as the one coming from another version of this
   * library or from a different build.
   *
   * @param instance The instance to check.
   * @returns Whether or not the instance is a `Result`.
   *
   * @example
   * ```typescript
   * import { Result } from '@sapphire/result';
   * const { ok } = require('@sapphire/result');
   *
   * ok(2) instanceof Result; // true
   * ```
   */
  static [Symbol.hasInstance](instance) {
    return typeof instance === "object" && instance !== null && ValueProperty in instance && SuccessProperty in instance;
  }
  /**
   * @deprecated Use {@link Result.isResult} instead.
   *
   * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.
   *
   * @param instance The instance to check.
   * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.
   *
   * @example
   * ```typescript
   * import { Result } from '@sapphire/result';
   * const { ok } = require('@sapphire/result');
   *
   * Result.isResult(ok(2)); // true
   * ```
   */
  static is(instance) {
    return _Result[Symbol.hasInstance](instance);
  }
  /**
   * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.
   *
   * @param instance The instance to check.
   * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.
   *
   * @example
   * ```typescript
   * import { Result } from '@sapphire/result';
   * const { ok } = require('@sapphire/result');
   *
   * Result.isResult(ok(2)); // true
   * ```
   */
  static isResult(instance) {
    return _Result[Symbol.hasInstance](instance);
  }
  /**
   * Creates a {@link Result} out of a callback.
   *
   * @typeparam T The result's type.
   * @typeparam E The error's type.
   */
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  static from(op) {
    try {
      return resolve(isFunction(op) ? op() : op);
    } catch (error) {
      return err(error);
    }
  }
  /**
   * Creates a {@link Result} out of a promise or async callback.
   *
   * @typeparam T The result's type.
   * @typeparam E The error's type.
   */
  static async fromAsync(op) {
    try {
      return resolve(await (isFunction(op) ? op() : op));
    } catch (error) {
      return err(error);
    }
  }
  /**
   * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first
   * {@link Err} encountered.
   *
   * @param results An array of {@link Result}s.
   * @returns A new {@link Result}.
   */
  static all(results) {
    const values = [];
    for (const result of results) {
      if (result.isErr()) return result;
      values.push(result[ValueProperty]);
    }
    return ok(values);
  }
  /**
   * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.
   *
   * @param results An array of {@link Result}s.
   * @returns A new {@link Result}.
   */
  static any(results) {
    const errors = [];
    for (const result of results) {
      if (result.isOk()) return result;
      errors.push(result[ValueProperty]);
    }
    return err(errors);
  }
};
__name(_Result, "Result");
var Result = _Result;
var { ok, err } = Result;
function resolve(value) {
  return Result.isResult(value) ? value : ok(value);
}
__name(resolve, "resolve");

// src/lib/Option.ts
var ValueProperty2 = Symbol.for("@sapphire/result:Option.value");
var ExistsProperty = Symbol.for("@sapphire/result:Option.exists");
var _a2, _b2;
var _Option = class _Option {
  constructor(value, exists) {
    __publicField(this, _b2);
    __publicField(this, _a2);
    this[ValueProperty2] = value;
    this[ExistsProperty] = exists;
  }
  /**
   * Returns `true` if the option is a `Some` value.
   *
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * assert.equal(x.isSome(), true);
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * assert.equal(x.isSome(), false);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some}
   */
  isSome() {
    return this[ExistsProperty];
  }
  isSomeAnd(cb) {
    return this.isSome() && cb(this[ValueProperty2]);
  }
  /**
   * Returns `true` if the option is a `None` value.
   *
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * assert.equal(x.isNone(), false);
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * assert.equal(x.isNone(), true);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none}
   */
  isNone() {
    return !this[ExistsProperty];
  }
  isNoneOr(cb) {
    return this.match({ some: /* @__PURE__ */ __name((value) => cb(value), "some"), none: /* @__PURE__ */ __name(() => true, "none") });
  }
  /**
   * Returns the contained `Some` value.
   * @param message The message for the error.
   * If the value is an `Err`, it throws an {@link OptionError} with the given message.
   *
   * @example
   * ```typescript
   * const x: Option<string> = some(2);
   * assert.equal(x.expect('Whoops!'), 2);
   * ```
   * @example
   * ```typescript
   * const x: Option<string> = none;
   * assert.throws(() => x.expect('Whoops!'), {
   *   name: 'OptionError',
   *   message: 'Whoops'
   * });
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.expect}
   */
  expect(message) {
    if (this.isNone()) throw new OptionError(message);
    return this[ValueProperty2];
  }
  /**
   * Returns the contained `Some` value.
   *
   * If the value is an `Err`, it throws an {@link OptionError} with the message.
   * @seealso {@link unwrapOr}
   * @seealso {@link unwrapOrElse}
   *
   * @example
   * ```typescript
   * const x: Option<string> = some(2);
   * assert.equal(x.unwrap(), 2);
   * ```
   * @example
   * ```typescript
   * const x: Option<string> = none;
   * assert.throws(() => x.unwrap(), {
   *   name: 'OptionError',
   *   message: 'Unwrap failed'
   * });
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap}
   */
  unwrap() {
    if (this.isNone()) throw new OptionError("Unwrap failed");
    return this[ValueProperty2];
  }
  /**
   * Returns the contained `Some` value or a provided default.
   *
   * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is
   * recommended to use {@link unwrapOrElse}, which is lazily evaluated.
   *
   * @example
   * ```typescript
   * assert.equal(some(2).unwrapOr(0), 2);
   * ```
   * @example
   * ```typescript
   * assert.equal(none.unwrapOr(0), 0);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or}
   */
  unwrapOr(defaultValue) {
    return this.match({ some: /* @__PURE__ */ __name((value) => value, "some"), none: /* @__PURE__ */ __name(() => defaultValue, "none") });
  }
  /**
   * Returns the contained Some value or computes it from a closure.
   *
   * @example
   * ```typescript
   * assert.equal(some(2).unwrapOrElse(() => 0), 2);
   * ```
   * @example
   * ```typescript
   * assert.equal(none.unwrapOrElse(() => 0), 0);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else}
   */
  unwrapOrElse(cb) {
    return this.match({ some: /* @__PURE__ */ __name((value) => value, "some"), none: cb });
  }
  /**
   * Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const maybeSomeString = some('Hello, world!');
   * const maybeSomeLength = maybeSomeString.map((value) => value.length);
   *
   * assert.equal(maybeSomeLength, some(13));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map}
   */
  map(cb) {
    return this.match({ some: /* @__PURE__ */ __name((value) => some(cb(value)), "some"), none: returnThis });
  }
  /**
   * Maps a `Some<T>` to the returned `Option<U>` by applying a function to a contained value, leaving `None`
   * untouched.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const input: Option<string> = some('Hello, world!');
   * const result = input.mapInto((value) => some(value.length));
   *
   * assert.equal(result, some(13));
   * ```
   * @example
   * ```typescript
   * const input: Option<string> = none;
   * const result = input.mapInto((value) => some(value.length));
   *
   * assert.equal(result, none);
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  mapInto(cb) {
    return this.match({ some: /* @__PURE__ */ __name((value) => cb(value), "some"), none: returnThis });
  }
  /**
   * Returns the provided default result (if none), or applies a function to the contained value (if any).
   *
   * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is
   * recommended to use {@link mapOrElse}, which is lazily evaluated.
   * @param defaultValue The default value.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const x: Option<string> = some('hello');
   * assert.equal(x.mapOr(42, (value) => value.length), 5);
   * ```
   * @example
   * ```typescript
   * const x: Option<string> = none;
   * assert.equal(x.mapOr(42, (value) => value.length), 42);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or}
   */
  mapOr(defaultValue, cb) {
    return this.match({ some: /* @__PURE__ */ __name((value) => cb(value), "some"), none: /* @__PURE__ */ __name(() => defaultValue, "none") });
  }
  /**
   * Computes a default function result (if none), or applies a different function to the contained value (if any).
   * @param defaultValue The default value.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const x: Option<string> = some('hello');
   * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 5);
   * ```
   * @example
   * ```typescript
   * const x: Option<string> = none;
   * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 42);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else}
   */
  mapOrElse(defaultValue, cb) {
    return this.match({ some: /* @__PURE__ */ __name((value) => cb(value), "some"), none: /* @__PURE__ */ __name(() => defaultValue(), "none") });
  }
  /**
   * Maps a `None` to the returned `Option<U>` by applying a function to a contained value, leaving `Some<T>`
   * untouched.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const input: Option<string> = some('Hello, world!');
   * const result = input.mapNoneInto(() => some(13));
   *
   * assert.equal(result, some('Hello, world!'));
   * ```
   * @example
   * ```typescript
   * const input: Option<string> = none;
   * const result = input.mapNoneInto(() => some(13));
   *
   * assert.equal(result, some(13));
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  mapNoneInto(cb) {
    return this.match({ some: returnThis, none: cb });
  }
  /**
   * Calls the provided closure with a reference to the contained value (if `Some`).
   * @param cb The predicate.
   * @seealso {@link inspectAsync} for the awaitable version.
   *
   * @example
   * ```typescript
   * some(2).inspect(console.log);
   * // Logs: 2
   * ```
   * @example
   * ```typescript
   * none.inspect(console.log);
   * // Doesn't log
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.inspect}
   */
  inspect(cb) {
    if (this.isSome()) cb(this[ValueProperty2]);
    return this;
  }
  /**
   * Calls the provided closure with a reference to the contained value (if `Some`).
   * @param cb The predicate.
   * @seealso {@link inspect} for the sync version.
   *
   * @example
   * ```typescript
   * await some(2).inspectAsync(console.log);
   * // Logs: 2
   * ```
   * @example
   * ```typescript
   * await none.inspectAsync(console.log);
   * // Doesn't log
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  async inspectAsync(cb) {
    if (this.isSome()) await cb(this[ValueProperty2]);
    return this;
  }
  /**
   * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err)`.
   *
   * Arguments passed to `okOr` are eagerly evaluated; if you are passing the result of a function call, it is
   * recommended to use {@link okOrElse}, which is lazily evaluated.
   * @param err The error to be used.
   *
   * @example
   * ```typescript
   * const x: Option<string> = some('hello');
   * assert.equal(x.okOr(0), ok('hello'));
   * ```
   * @example
   * ```typescript
   * const x: Option<string> = none;
   * assert.equal(x.okOr(0), err(0));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or}
   */
  okOr(error) {
    return this.match({ some: /* @__PURE__ */ __name((value) => ok(value), "some"), none: /* @__PURE__ */ __name(() => err(error), "none") });
  }
  /**
   * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err())`.
   * @param cb The error to be used.
   *
   * @example
   * ```typescript
   * const x: Option<string> = some('hello');
   * assert.equal(x.okOrElse(() => 0), ok('hello'));
   * ```
   * @example
   * ```typescript
   * const x: Option<string> = none;
   * assert.equal(x.okOrElse(() => 0), err(0));
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else}
   */
  okOrElse(cb) {
    return this.match({ some: /* @__PURE__ */ __name((value) => ok(value), "some"), none: /* @__PURE__ */ __name(() => err(cb()), "none") });
  }
  /**
   * Returns an iterator over the possibly contained value.
   *
   * The iterator yields one value if the result is `Some`, otherwise none.
   *
   * @example
   * ```typescript
   * const x = some(7);
   * for (const value of x) {
   *   console.log(value);
   * }
   * // Logs 7
   * ```
   * @example
   * ```typescript
   * const x = none;
   * for (const value of x) {
   *   console.log(value);
   * }
   * // Doesn't log
   * ```
   *
   * @see {@link Option.iter}
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}
   */
  *iter() {
    if (this.isSome()) yield this[ValueProperty2];
  }
  /**
   * Returns `None` if the option is `None`, otherwise returns `option`.
   * @param option The option.
   *
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * const y: Option<string> = none;
   * assert.equal(x.and(y), none);
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * const y: Option<string> = some('foo');
   * assert.equal(x.and(y), none);
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * const y: Option<string> = some('foo');
   * assert.equal(x.and(y), some('foo'));
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * const y: Option<string> = none;
   * assert.equal(x.and(y), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.and}
   */
  and(option) {
    return this.match({ some: /* @__PURE__ */ __name(() => option, "some"), none: returnThis });
  }
  /**
   * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
   *
   * This function can be used for control flow based on `Result` values.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * function fractionOf4(value: number) {
   *   return value === 0 ? none : some(4 / value);
   * }
   *
   * assert.equal(some(2).andThen(fractionOf4), some(4));
   * assert.equal(some(0).andThen(fractionOf4), none);
   * assert.equal(none.andThen(fractionOf4), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}
   */
  andThen(cb) {
    return this.match({ some: /* @__PURE__ */ __name((value) => cb(value), "some"), none: returnThis });
  }
  /**
   * Returns the option if it contains a value, otherwise returns `option`.
   * @param option The option.
   *
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * const y: Option<number> = none;
   * assert.equal(x.or(y), some(2));
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * const y: Option<number> = some(100);
   * assert.equal(x.or(y), some(100));
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * const y: Option<number> = some(100);
   * assert.equal(x.or(y), some(2));
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * const y: Option<number> = none;
   * assert.equal(x.or(y), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or}
   */
  or(option) {
    return this.match({ some: returnThis, none: /* @__PURE__ */ __name(() => option, "none") });
  }
  /**
   * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
   *
   * This function can be used for control flow based on `Result` values.
   * @param cb The predicate.
   *
   * @example
   * ```typescript
   * const nobody = (): Option<string> => none;
   * const vikings = (): Option<string> => some('vikings');
   *
   * assert.equal(some('barbarians').orElse(vikings), some('barbarians'));
   * assert.equal(none.orElse(vikings), some('vikings'));
   * assert.equal(none.orElse(nobody), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or_else}
   */
  orElse(cb) {
    return this.match({ some: returnThis, none: /* @__PURE__ */ __name(() => cb(), "none") });
  }
  /**
   * Returns `Some` if exactly one of self or `option` is `Some`, otherwise returns `None`.
   * @param option The option to compare.
   *
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * const y: Option<number> = none;
   * assert.equal(x.xor(y), some(2));
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * const y: Option<number> = some(2);
   * assert.equal(x.xor(y), some(2));
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * const y: Option<number> = some(2);
   * assert.equal(x.xor(y), none);
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * const y: Option<number> = none;
   * assert.equal(x.xor(y), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.xor}
   */
  xor(option) {
    return this.match({
      some() {
        return option.isNone() ? this : none;
      },
      none: /* @__PURE__ */ __name(() => option, "none")
    });
  }
  filter(predicate) {
    return this.isSomeAnd(predicate) ? this : none;
  }
  /**
   * Returns `true` if the option is a `Some` value containing the given value.
   * @param value The value to compare.
   *
   * @example
   * ```typescript
   * const x: Option<number> = some(2);
   * assert.equal(x.contains(2), true);
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = some(3);
   * assert.equal(x.contains(2), false);
   * ```
   * @example
   * ```typescript
   * const x: Option<number> = none;
   * assert.equal(x.contains(2), false);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.contains}
   */
  contains(value) {
    return this.isSomeAnd((inner) => inner === value);
  }
  /**
   * Zips self with another `Option`.
   *
   * If self is `Some(s)` and `other` is `Some(o)`, this method returns `Some([s, o])`. Otherwise, `None` is returned.
   * @param other The option to zip self with.
   *
   * @example
   * ```typescript
   * const x = some(1);
   * const y = some('hi');
   * const z = none;
   *
   * assert.equal(x.zip(y), some([1, 'hi']));
   * assert.equal(x.zip(z), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip}
   */
  zip(other) {
    return this.isSome() && other.isSome() ? some([this[ValueProperty2], other[ValueProperty2]]) : none;
  }
  /**
   * Zips self and another `Option` with function `f`.
   *
   * If self is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`. Otherwise, `None` is returned.
   * @param other The option to zip self with.
   * @param f The function that computes the returned value.
   *
   * @example
   * ```typescript
   * class Point {
   *   public readonly x: number;
   *   public readonly y: number;
   *
   *   public constructor(x: number, y: number) {
   *     this.x = x;
   *     this.y = y;
   *   }
   * }
   *
   * const x = some(17.5);
   * const y = some(42.7);
   *
   * assert.equal(x.zipWith(y, (s, o) => new Point(s, o)), some(new Point(17.5, 42.7)));
   * assert.equal(x.zipWith(none, (s, o) => new Point(s, o)), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip_with}
   */
  zipWith(other, f) {
    return this.isSome() && other.isSome() ? some(f(this[ValueProperty2], other[ValueProperty2])) : none;
  }
  /**
   * Unzips an option containing a tuple of two options.
   *
   * If self is `Some([a, b])` this method returns `[Some(a), Some(b)]`. Otherwise, `[None, None]` is returned.
   *
   * @example
   * ```typescript
   * const x: Option<[number, string]> = some([1, 'hi']);
   * assert.equal(x.unzip(), [some(1), some('hi')]);
   * ```
   * @example
   * ```typescript
   * const x: Option<[number, string]> = none;
   * assert.equal(x.unzip(), [none, none]);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unzip}
   */
  unzip() {
    return this.match({
      some: /* @__PURE__ */ __name(([value0, value1]) => [some(value0), some(value1)], "some"),
      none: /* @__PURE__ */ __name(() => [none, none], "none")
    });
  }
  /**
   * Transposes an `Option` of a `Result` into a `Result` of an `Option`.
   *
   * `none` will be mapped to `ok(none)`. `some(ok(v))` and `some(err(e))` will be mapped to `ok(some(v))` and `err(e)`.
   *
   * @example
   * ```typescript
   * const x: Option<Result<number, Error>> = some(ok(5));
   * const y: Result<Option<number>, Error> = ok(some(5));
   * assert.equal(x.transpose(), y);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose}
   */
  transpose() {
    return this.match({
      // @ts-expect-error Complex types
      some: /* @__PURE__ */ __name((result) => result.map(some), "some"),
      none: /* @__PURE__ */ __name(() => ok(none), "none")
    });
  }
  /**
   * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.
   *
   * @example
   * ```typescript
   * const x: Option<Option<number>> = some(some(6));
   * assert.equal(x.flatten(), some(6));
   * ```
   * @example
   * ```typescript
   * const x: Option<Option<number>> = some(none);
   * assert.equal(x.flatten(), none);
   * ```
   * @example
   * ```typescript
   * const x: Option<Option<number>> = none;
   * assert.equal(x.flatten(), none);
   * ```
   *
   * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}
   */
  flatten() {
    return this.match({ some: /* @__PURE__ */ __name((inner) => inner, "some"), none: returnThis });
  }
  /**
   * Returns a `Promise` object with the awaited value (if `Some`).
   *
   * @example
   * ```typescript
   * let x = some(Promise.resolve(3));
   * assert.equal(await x.intoPromise(), some(3));
   * ```
   *
   * @note This is an extension not supported in Rust
   */
  intoPromise() {
    return this.match({
      some: /* @__PURE__ */ __name(async (value) => some(await value), "some"),
      // NOSONAR
      none: /* @__PURE__ */ __name(() => Promise.resolve(none), "none")
    });
  }
  /**
   * Checks whether or not `other` equals with self.
   * @param other The other option to compare.
   *
   * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}
   */
  eq(other) {
    return this.isSome() === other.isSome() && this[ValueProperty2] === other[ValueProperty2];
  }
  /**
   * Checks whether or not `other` doesn't equal with self.
   * @param other The other option to compare.
   *
   * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}
   */
  ne(other) {
    return !this.eq(other);
  }
  /**
   * Runs `ok` function if self is `Ok`, otherwise runs `err` function.
   * @param branches The branches to match.
   *
   * @example
   * ```typescript
   * const option = some(4).match({
   *   some: (v) => v,
   *   none: () => 0
   * });
   * assert.equal(option, 4);
   * ```
   * @example
   * ```typescript
   * const option = none.match({
   *   some: (v) => v,
   *   none: () => 0
   * });
   * assert.equal(option, 0);
   * ```
   */
  match(branches) {
    return this.isSome() ? branches.some.call(this, this[ValueProperty2]) : branches.none.call(this);
  }
  /**
   * Returns an iterator over the possibly contained value.
   *
   * The iterator yields one value if the result is `Some`, otherwise none.
   *
   * @example
   * ```typescript
   * const x = some(7);
   * for (const value of x) {
   *   console.log(value);
   * }
   * // Logs 7
   * ```
   * @example
   * ```typescript
   * const x = none;
   * for (const value of x) {
   *   console.log(value);
   * }
   * // Doesn't log
   * ```
   *
   * @see {@link IOption.iter}
   * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}
   */
  [(_b2 = ValueProperty2, _a2 = ExistsProperty, Symbol.iterator)]() {
    return this.iter();
  }
  get [Symbol.toStringTag]() {
    return this.match({ some: /* @__PURE__ */ __name(() => "Some", "some"), none: /* @__PURE__ */ __name(() => "None", "none") });
  }
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  static some(value) {
    return new _Option(value, true);
  }
  /**
   * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object. This override
   * exists to interoperate with other versions of this class, such as the one coming from another version of this
   * library or from a different build.
   *
   * @param instance The instance to check.
   * @returns Whether or not the instance is a `Option`.
   *
   * @example
   * ```typescript
   * import { Option } from '@sapphire/result';
   * const { some } = require('@sapphire/result');
   *
   * some(2) instanceof Option; // true
   * ```
   */
  static [Symbol.hasInstance](instance) {
    return typeof instance === "object" && instance !== null && ValueProperty2 in instance && ExistsProperty in instance;
  }
  /**
   * @deprecated Use {@link Option.isOption} instead.
   *
   * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.
   *
   * @param instance The instance to check.
   * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.
   *
   * @example
   * ```typescript
   * import { Option } from '@sapphire/result';
   * const { some } = require('@sapphire/result');
   *
   * Option.isOption(some(2)); // true
   * ```
   */
  static is(instance) {
    return _Option[Symbol.hasInstance](instance);
  }
  /**
   * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.
   *
   * @param instance The instance to check.
   * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.
   *
   * @example
   * ```typescript
   * import { Option } from '@sapphire/result';
   * const { some } = require('@sapphire/result');
   *
   * Option.isOption(some(2)); // true
   * ```
   */
  static isOption(instance) {
    return _Option[Symbol.hasInstance](instance);
  }
  /**
   * Creates a {@link Result} out of a callback.
   *
   * @typeparam T The result's type.
   * @typeparam E The error's type.
   */
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  static from(op) {
    try {
      return resolve2(isFunction(op) ? op() : op);
    } catch {
      return none;
    }
  }
  /**
   * Creates a {@link Result} out of a promise or async callback.
   *
   * @typeparam T The result's type.
   * @typeparam E The error's type.
   */
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  static async fromAsync(op) {
    try {
      return resolve2(await (isFunction(op) ? op() : op));
    } catch {
      return none;
    }
  }
  /**
   * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first
   * {@link Err} encountered.
   *
   * @param results An array of {@link Result}s.
   * @returns A new {@link Result}.
   */
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  static all(results) {
    const values = [];
    for (const result of results) {
      if (result.isNone()) return result;
      values.push(result[ValueProperty2]);
    }
    return some(values);
  }
  /**
   * Returns the first encountered {@link Some}, or a {@link None} if none was found.
   *
   * @param options An array of {@link Option}s.
   * @returns A new {@link Option}.
   */
  // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
  static any(results) {
    for (const result of results) {
      if (result.isSome()) return result;
    }
    return none;
  }
};
__name(_Option, "Option");
__publicField(_Option, "none", new _Option(null, false));
var Option = _Option;
var { some, none } = Option;
function resolve2(value) {
  if (value === null || value === void 0) return none;
  if (Option.isOption(value)) return value;
  return some(value);
}
__name(resolve2, "resolve");

export { Option, OptionError, Result, ResultError, err, none, ok, some };
//# sourceMappingURL=index.mjs.map
//# sourceMappingURL=index.mjs.map