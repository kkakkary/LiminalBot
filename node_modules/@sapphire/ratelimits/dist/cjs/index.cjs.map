{"version":3,"sources":["../../src/lib/RateLimit.ts","../../src/lib/RateLimitManager.ts"],"names":[],"mappings":"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","file":"index.cjs","sourcesContent":["import type { RateLimitManager } from './RateLimitManager';\n\nexport class RateLimit<K = string> {\n\t/**\n\t * The remaining amount of times this entry can be dripped before the bucket is empty.\n\t */\n\tpublic remaining!: number;\n\n\t/**\n\t * The timestamp that represents when this entry will reset back to a available state.\n\t */\n\tpublic expires!: number;\n\n\t/**\n\t * The {@link RateLimitManager} this entry is for.\n\t */\n\tprivate manager: RateLimitManager<K>;\n\n\t/**\n\t * @param manager The manager for this entry.\n\t */\n\tpublic constructor(manager: RateLimitManager<K>) {\n\t\tthis.manager = manager;\n\t\tthis.reset();\n\t}\n\n\t/**\n\t * Whether this entry is expired or not, allowing the bucket to be reset.\n\t */\n\tpublic get expired(): boolean {\n\t\treturn this.remainingTime === 0;\n\t}\n\n\t/**\n\t * Whether this entry is limited or not.\n\t */\n\tpublic get limited(): boolean {\n\t\treturn this.remaining === 0 && !this.expired;\n\t}\n\n\t/**\n\t * The remaining time in milliseconds before resetting.\n\t */\n\tpublic get remainingTime(): number {\n\t\treturn Math.max(this.expires - Date.now(), 0);\n\t}\n\n\t/**\n\t * Consumes {@link RateLimit.remaining} by one if it's not limited, calling {@link RateLimit.reset} first if {@link RateLimit.expired} is true.\n\t */\n\tpublic consume(): this {\n\t\tif (this.limited) throw new Error('Cannot consume a limited bucket');\n\t\tif (this.expired) this.reset();\n\n\t\tthis.remaining--;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets the entry back to it's full state.\n\t */\n\tpublic reset(): this {\n\t\treturn this.resetRemaining().resetTime();\n\t}\n\n\t/**\n\t * Resets the entry's {@link RateLimit.remaining} uses back to full state.\n\t */\n\tpublic resetRemaining(): this {\n\t\tthis.remaining = this.manager.limit;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets the entry's {@link RateLimit.expires} to the current time plus {@link RateLimitManager.time}.\n\t */\n\tpublic resetTime(): this {\n\t\tthis.expires = Date.now() + this.manager.time;\n\t\treturn this;\n\t}\n}\n","import { RateLimit } from './RateLimit';\n\nexport class RateLimitManager<K = string> extends Map<K, RateLimit<K>> {\n\t/**\n\t * The amount of milliseconds for the {@link RateLimit ratelimits} from this manager to expire.\n\t */\n\tpublic readonly time: number;\n\n\t/**\n\t * The amount of times a {@link RateLimit} can drip before it's limited.\n\t */\n\tpublic readonly limit: number;\n\n\t/**\n\t * The interval to sweep expired {@link RateLimit ratelimits}.\n\t */\n\tprivate sweepInterval!: NodeJS.Timeout | undefined | null;\n\n\t/**\n\t * @param time The amount of milliseconds for the ratelimits from this manager to expire.\n\t * @param limit The amount of times a {@link RateLimit} can drip before it's limited.\n\t */\n\tpublic constructor(time: number, limit = 1) {\n\t\tsuper();\n\n\t\tthis.time = time;\n\t\tthis.limit = limit;\n\t}\n\n\t/**\n\t * Gets a {@link RateLimit} from this manager or creates it if it does not exist.\n\t * @param id The id for the {@link RateLimit}\n\t */\n\tpublic acquire(id: K): RateLimit<K> {\n\t\treturn this.get(id) ?? this.create(id);\n\t}\n\n\t/**\n\t * Creates a {@link RateLimit} for this manager.\n\t * @param id The id the {@link RateLimit} belongs to\n\t */\n\tpublic create(id: K): RateLimit<K> {\n\t\tconst value = new RateLimit(this);\n\t\tthis.set(id, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Wraps Collection's set method to set interval to sweep inactive {@link RateLimit}s.\n\t * @param id The id the {@link RateLimit} belongs to\n\t * @param value The {@link RateLimit} to set\n\t */\n\tpublic override set(id: K, value: RateLimit<K>): this {\n\t\tthis.sweepInterval ??= setInterval(this.sweep.bind(this), RateLimitManager.sweepIntervalDuration);\n\t\treturn super.set(id, value);\n\t}\n\n\t/**\n\t * Wraps Collection's sweep method to clear the interval when this manager is empty.\n\t */\n\tpublic sweep(): void {\n\t\tfor (const [id, value] of this.entries()) {\n\t\t\tif (value.expired) this.delete(id);\n\t\t}\n\n\t\tif (this.size === 0 && this.sweepInterval !== undefined && this.sweepInterval !== null) {\n\t\t\tclearInterval(this.sweepInterval);\n\t\t\tthis.sweepInterval = null;\n\t\t}\n\t}\n\n\t/**\n\t * The delay in milliseconds for {@link RateLimitManager.sweepInterval}.\n\t */\n\tpublic static sweepIntervalDuration = 30_000;\n}\n"]}