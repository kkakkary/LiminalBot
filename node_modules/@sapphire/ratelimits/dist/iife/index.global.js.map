{"version":3,"sources":["../../src/lib/RateLimit.ts","../../src/lib/RateLimitManager.ts"],"names":[],"mappings":"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","file":"index.global.js","sourcesContent":["import type { RateLimitManager } from './RateLimitManager';\n\nexport class RateLimit<K = string> {\n\t/**\n\t * The remaining amount of times this entry can be dripped before the bucket is empty.\n\t */\n\tpublic remaining!: number;\n\n\t/**\n\t * The timestamp that represents when this entry will reset back to a available state.\n\t */\n\tpublic expires!: number;\n\n\t/**\n\t * The {@link RateLimitManager} this entry is for.\n\t */\n\tprivate manager: RateLimitManager<K>;\n\n\t/**\n\t * @param manager The manager for this entry.\n\t */\n\tpublic constructor(manager: RateLimitManager<K>) {\n\t\tthis.manager = manager;\n\t\tthis.reset();\n\t}\n\n\t/**\n\t * Whether this entry is expired or not, allowing the bucket to be reset.\n\t */\n\tpublic get expired(): boolean {\n\t\treturn this.remainingTime === 0;\n\t}\n\n\t/**\n\t * Whether this entry is limited or not.\n\t */\n\tpublic get limited(): boolean {\n\t\treturn this.remaining === 0 && !this.expired;\n\t}\n\n\t/**\n\t * The remaining time in milliseconds before resetting.\n\t */\n\tpublic get remainingTime(): number {\n\t\treturn Math.max(this.expires - Date.now(), 0);\n\t}\n\n\t/**\n\t * Consumes {@link RateLimit.remaining} by one if it's not limited, calling {@link RateLimit.reset} first if {@link RateLimit.expired} is true.\n\t */\n\tpublic consume(): this {\n\t\tif (this.limited) throw new Error('Cannot consume a limited bucket');\n\t\tif (this.expired) this.reset();\n\n\t\tthis.remaining--;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets the entry back to it's full state.\n\t */\n\tpublic reset(): this {\n\t\treturn this.resetRemaining().resetTime();\n\t}\n\n\t/**\n\t * Resets the entry's {@link RateLimit.remaining} uses back to full state.\n\t */\n\tpublic resetRemaining(): this {\n\t\tthis.remaining = this.manager.limit;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Resets the entry's {@link RateLimit.expires} to the current time plus {@link RateLimitManager.time}.\n\t */\n\tpublic resetTime(): this {\n\t\tthis.expires = Date.now() + this.manager.time;\n\t\treturn this;\n\t}\n}\n","import { RateLimit } from './RateLimit';\n\nexport class RateLimitManager<K = string> extends Map<K, RateLimit<K>> {\n\t/**\n\t * The amount of milliseconds for the {@link RateLimit ratelimits} from this manager to expire.\n\t */\n\tpublic readonly time: number;\n\n\t/**\n\t * The amount of times a {@link RateLimit} can drip before it's limited.\n\t */\n\tpublic readonly limit: number;\n\n\t/**\n\t * The interval to sweep expired {@link RateLimit ratelimits}.\n\t */\n\tprivate sweepInterval!: NodeJS.Timeout | undefined | null;\n\n\t/**\n\t * @param time The amount of milliseconds for the ratelimits from this manager to expire.\n\t * @param limit The amount of times a {@link RateLimit} can drip before it's limited.\n\t */\n\tpublic constructor(time: number, limit = 1) {\n\t\tsuper();\n\n\t\tthis.time = time;\n\t\tthis.limit = limit;\n\t}\n\n\t/**\n\t * Gets a {@link RateLimit} from this manager or creates it if it does not exist.\n\t * @param id The id for the {@link RateLimit}\n\t */\n\tpublic acquire(id: K): RateLimit<K> {\n\t\treturn this.get(id) ?? this.create(id);\n\t}\n\n\t/**\n\t * Creates a {@link RateLimit} for this manager.\n\t * @param id The id the {@link RateLimit} belongs to\n\t */\n\tpublic create(id: K): RateLimit<K> {\n\t\tconst value = new RateLimit(this);\n\t\tthis.set(id, value);\n\t\treturn value;\n\t}\n\n\t/**\n\t * Wraps Collection's set method to set interval to sweep inactive {@link RateLimit}s.\n\t * @param id The id the {@link RateLimit} belongs to\n\t * @param value The {@link RateLimit} to set\n\t */\n\tpublic override set(id: K, value: RateLimit<K>): this {\n\t\tthis.sweepInterval ??= setInterval(this.sweep.bind(this), RateLimitManager.sweepIntervalDuration);\n\t\treturn super.set(id, value);\n\t}\n\n\t/**\n\t * Wraps Collection's sweep method to clear the interval when this manager is empty.\n\t */\n\tpublic sweep(): void {\n\t\tfor (const [id, value] of this.entries()) {\n\t\t\tif (value.expired) this.delete(id);\n\t\t}\n\n\t\tif (this.size === 0 && this.sweepInterval !== undefined && this.sweepInterval !== null) {\n\t\t\tclearInterval(this.sweepInterval);\n\t\t\tthis.sweepInterval = null;\n\t\t}\n\t}\n\n\t/**\n\t * The delay in milliseconds for {@link RateLimitManager.sweepInterval}.\n\t */\n\tpublic static sweepIntervalDuration = 30_000;\n}\n"]}