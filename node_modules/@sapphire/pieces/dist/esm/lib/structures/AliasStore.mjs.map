{"version":3,"sources":["../../../../src/lib/structures/AliasStore.ts"],"names":[],"mappings":";;;;AAQO,IAAM,WAAA,GAAN,MAAM,WAAA,SAAgG,KAAoB,CAAA;AAAA,EAA1H,WAAA,GAAA;AAAA,IAAA,KAAA,CAAA,GAAA,SAAA,CAAA;AAIN;AAAA;AAAA;AAAA,IAAgB,aAAA,CAAA,IAAA,EAAA,SAAA,EAAU,IAAI,UAAsB,EAAA,CAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMpC,IAAI,GAA4B,EAAA;AAC/C,IAAA,OAAO,MAAM,GAAI,CAAA,GAAG,KAAK,IAAK,CAAA,OAAA,CAAQ,IAAI,GAAG,CAAA;AAAA;AAC9C;AAAA;AAAA;AAAA;AAAA,EAMgB,IAAI,GAAsB,EAAA;AACzC,IAAA,OAAO,MAAM,GAAI,CAAA,GAAG,KAAK,IAAK,CAAA,OAAA,CAAQ,IAAI,GAAG,CAAA;AAAA;AAC9C;AAAA;AAAA;AAAA;AAAA;AAAA,EAOgB,OAAO,IAA8B,EAAA;AACpD,IAAM,MAAA,KAAA,GAAQ,IAAK,CAAA,OAAA,CAAQ,IAAI,CAAA;AAG/B,IAAW,KAAA,MAAA,KAAA,IAAS,MAAM,OAAS,EAAA;AAElC,MAAA,MAAM,UAAa,GAAA,IAAA,CAAK,OAAQ,CAAA,GAAA,CAAI,KAAK,CAAA;AACzC,MAAA,IAAI,UAAe,KAAA,KAAA,EAAY,IAAA,CAAA,OAAA,CAAQ,OAAO,KAAK,CAAA;AAAA;AAGpD,IAAO,OAAA,KAAA,CAAM,OAAO,KAAK,CAAA;AAAA;AAC1B;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAsB,OAAO,KAAU,EAAA;AACtC,IAAW,KAAA,MAAA,GAAA,IAAO,MAAM,OAAS,EAAA;AAChC,MAAK,IAAA,CAAA,OAAA,CAAQ,GAAI,CAAA,GAAA,EAAK,KAAK,CAAA;AAAA;AAG5B,IAAO,OAAA,KAAA,CAAM,OAAO,KAAK,CAAA;AAAA;AAE3B,CAAA;AApDiI,MAAA,CAAA,WAAA,EAAA,YAAA,CAAA;AAA1H,IAAM,UAAN,GAAA","file":"AliasStore.mjs","sourcesContent":["import { Collection } from '@discordjs/collection';\nimport type { AliasPiece } from './AliasPiece';\nimport { Store } from './Store';\nimport type { StoreRegistryKey } from './StoreRegistry';\n\n/**\n * The store class which contains {@link AliasPiece}s.\n */\nexport class AliasStore<T extends AliasPiece, StoreName extends StoreRegistryKey = StoreRegistryKey> extends Store<T, StoreName> {\n\t/**\n\t * The aliases referencing to pieces.\n\t */\n\tpublic readonly aliases = new Collection<string, T>();\n\n\t/**\n\t * Looks up the name by the store, falling back to an alias lookup.\n\t * @param key The key to look for.\n\t */\n\tpublic override get(key: string): T | undefined {\n\t\treturn super.get(key) ?? this.aliases.get(key);\n\t}\n\n\t/**\n\t * Checks whether a key is in the store, or is an alias\n\t * @param key The key to check\n\t */\n\tpublic override has(key: string): boolean {\n\t\treturn super.has(key) || this.aliases.has(key);\n\t}\n\n\t/**\n\t * Unloads a piece given its instance or its name, and removes all the aliases.\n\t * @param name The name of the file to load.\n\t * @return Returns the piece that was unloaded.\n\t */\n\tpublic override unload(name: string | T): Promise<T> {\n\t\tconst piece = this.resolve(name);\n\n\t\t// Unload all aliases for the given piece:\n\t\tfor (const alias of piece.aliases) {\n\t\t\t// We don't want to delete aliases that were overriden by another piece:\n\t\t\tconst aliasPiece = this.aliases.get(alias);\n\t\t\tif (aliasPiece === piece) this.aliases.delete(alias);\n\t\t}\n\n\t\treturn super.unload(piece);\n\t}\n\n\t/**\n\t * Inserts a piece into the store, and adds all the aliases.\n\t * @param piece The piece to be inserted into the store.\n\t * @return The inserted piece.\n\t */\n\tpublic override async insert(piece: T) {\n\t\tfor (const key of piece.aliases) {\n\t\t\tthis.aliases.set(key, piece);\n\t\t}\n\n\t\treturn super.insert(piece);\n\t}\n}\n"]}