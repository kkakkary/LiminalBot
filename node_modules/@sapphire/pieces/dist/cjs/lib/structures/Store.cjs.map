{"version":3,"sources":["../../../../src/lib/structures/Store.ts"],"names":["LoaderStrategy","Collection","container","resolvePath","isClass","classExtends","LoaderError","LoaderErrorType","ManuallyRegisteredPiecesSymbol","VirtualPath","path","join","Store","StoreRegistry"],"mappings":"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","file":"Store.cjs","sourcesContent":["import { Collection } from '@discordjs/collection';\nimport { classExtends, isClass, type AbstractConstructor, type Constructor } from '@sapphire/utilities';\nimport { join } from 'path';\nimport { LoaderError, LoaderErrorType } from '../errors/LoaderError';\nimport { resolvePath, type Path } from '../internal/Path';\nimport { ManuallyRegisteredPiecesSymbol, VirtualPath } from '../internal/constants';\nimport { container, type Container } from '../shared/Container';\nimport type { HydratedModuleData, ILoaderResultEntry, ILoaderStrategy, ModuleData } from '../strategies/ILoaderStrategy';\nimport { LoaderStrategy } from '../strategies/LoaderStrategy';\nimport type { Piece } from './Piece';\nimport { StoreRegistry, type StoreRegistryEntries, type StoreRegistryKey } from './StoreRegistry';\n\n/**\n * The options for the store, this features both hooks (changes the behaviour) and handlers (similar to event listeners).\n */\nexport interface StoreOptions<T extends Piece, StoreName extends StoreRegistryKey = StoreRegistryKey> {\n\t/**\n\t * The name for this store.\n\t */\n\treadonly name: StoreName;\n\n\t/**\n\t * The paths to load pieces from, should be absolute.\n\t * @default []\n\t */\n\treadonly paths?: readonly string[];\n\n\t/**\n\t * The strategy to be used for the loader.\n\t * @default Store.defaultStrategy\n\t */\n\treadonly strategy?: ILoaderStrategy<T>;\n}\n\n/**\n * An interface representing a logger function.\n */\nexport interface StoreLogger {\n\t/**\n\t * @param value The string to print. All strings will be formatted with the format `[STORE => ${name}] [${type}] ${content}`,\n\t * where the content may have identifiers (values or names of methods) surrounded by `'`. For example:\n\t *\n\t * - `[STORE => commands] [LOAD] Skipped piece '/home/user/bot/src/commands/foo.js' as 'LoaderStrategy#filter' returned 'null'.`\n\t * - `[STORE => commands] [INSERT] Unloaded new piece 'foo' due to 'enabled' being 'false'.`\n\t * - `[STORE => commands] [UNLOAD] Unloaded piece 'foo'.`\n\t */\n\t(value: string): void;\n}\n\nconst defaultStrategy = new LoaderStrategy();\n\n/**\n * The store class which contains {@link Piece}s.\n */\nexport class Store<T extends Piece, StoreName extends StoreRegistryKey = StoreRegistryKey> extends Collection<string, T> {\n\tpublic readonly Constructor: AbstractConstructor<T>;\n\tpublic readonly name: StoreName;\n\tpublic readonly paths: Set<string>;\n\tpublic readonly strategy: ILoaderStrategy<T>;\n\n\t/**\n\t * The queue of manually registered pieces to load.\n\t */\n\tprivate readonly [ManuallyRegisteredPiecesSymbol] = new Map<string, StoreManuallyRegisteredPiece<StoreName>>();\n\n\t/**\n\t * Whether or not the store has called `loadAll` at least once.\n\t */\n\t#calledLoadAll = false;\n\n\t/**\n\t * The walk function for the store.\n\t */\n\t#walk: LoaderStrategy<T>['walk'];\n\n\t/**\n\t * @param constructor The piece constructor this store loads.\n\t * @param options The options for the store.\n\t */\n\tpublic constructor(constructor: AbstractConstructor<T>, options: StoreOptions<T, StoreName>) {\n\t\tsuper();\n\t\tthis.Constructor = constructor;\n\t\tthis.name = options.name as StoreRegistryKey;\n\t\tthis.paths = new Set(options.paths ?? []);\n\t\tthis.strategy = options.strategy ?? Store.defaultStrategy;\n\n\t\tthis.#walk =\n\t\t\ttypeof this.strategy.walk === 'function' //\n\t\t\t\t? this.strategy.walk.bind(this.strategy)\n\t\t\t\t: defaultStrategy.walk.bind(defaultStrategy);\n\t}\n\n\t/**\n\t * A reference to the {@link Container} object for ease of use.\n\t * @see container\n\t */\n\tpublic get container(): Container {\n\t\treturn container;\n\t}\n\n\t/**\n\t * Registers a directory into the store.\n\t * @param path The path to be added.\n\t * @example\n\t * ```typescript\n\t * store\n\t *   .registerPath(resolve('commands'))\n\t *   .registerPath(resolve('third-party', 'commands'));\n\t * ```\n\t */\n\tpublic registerPath(path: Path): this {\n\t\tconst root = resolvePath(path);\n\n\t\tthis.paths.add(root);\n\t\tStore.logger?.(`[STORE => ${this.name}] [REGISTER] Registered path '${root}'.`);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Adds a piece into the store's list of manually registered pieces. If {@linkcode Store.loadAll()} was called, the\n\t * piece will be loaded immediately, otherwise it will be queued until {@linkcode Store.loadAll()} is called.\n\t *\n\t * All manually registered pieces will be kept even after they are loaded to ensure they can be loaded again if\n\t * {@linkcode Store.loadAll()} is called again.\n\t *\n\t * @remarks\n\t *\n\t * - Pieces loaded this way will have their {@linkcode Piece.Context.root root} and\n\t *   {@linkcode Piece.Context.path path} set to {@linkcode VirtualPath}, and as such, cannot be reloaded.\n\t * - This method is useful in environments where file system access is limited or unavailable, such as when using\n\t *   {@link https://en.wikipedia.org/wiki/Serverless_computing Serverless Computing}.\n\t * - This method will always throw a {@link TypeError} if `entry.piece` is not a class.\n\t * - This method will always throw a {@linkcode LoaderError} if the piece does not extend the\n\t *   {@linkcode Store#Constructor store's piece constructor}.\n\t * - This operation is atomic, if any of the above errors are thrown, the piece will not be loaded.\n\t *\n\t * @seealso {@linkcode StoreRegistry.loadPiece()}\n\t * @since 3.8.0\n\t * @param entry The entry to load.\n\t * @example\n\t * ```typescript\n\t * import { container } from '@sapphire/pieces';\n\t *\n\t * class PingCommand extends Command {\n\t *   // ...\n\t * }\n\t *\n\t * container.stores.get('commands').loadPiece({\n\t *   name: 'ping',\n\t *   piece: PingCommand\n\t * });\n\t * ```\n\t */\n\tpublic async loadPiece(entry: StoreManuallyRegisteredPiece<StoreName>) {\n\t\tif (!isClass(entry.piece)) {\n\t\t\tthrow new TypeError(`The piece ${entry.name} is not a Class. ${String(entry.piece)}`);\n\t\t}\n\n\t\t// If the piece does not extend the store's Piece class, throw an error:\n\t\tif (!classExtends(entry.piece, this.Constructor as Constructor<T>)) {\n\t\t\tthrow new LoaderError(LoaderErrorType.IncorrectType, `The piece ${entry.name} does not extend ${this.name}`);\n\t\t}\n\n\t\tthis[ManuallyRegisteredPiecesSymbol].set(entry.name, entry);\n\t\tif (this.#calledLoadAll) {\n\t\t\tconst piece = this.construct(entry.piece as unknown as Constructor<T>, {\n\t\t\t\tname: entry.name,\n\t\t\t\troot: VirtualPath,\n\t\t\t\tpath: VirtualPath,\n\t\t\t\textension: VirtualPath\n\t\t\t});\n\t\t\tawait this.insert(piece);\n\t\t}\n\t}\n\n\t/**\n\t * Loads one or more pieces from a path.\n\t * @param root The root directory the file is from.\n\t * @param path The path of the file to load, relative to the `root`.\n\t * @return All the loaded pieces.\n\t */\n\tpublic async load(root: string, path: string): Promise<T[]> {\n\t\tif (root === VirtualPath) {\n\t\t\tthrow new LoaderError(LoaderErrorType.VirtualPiece, `Cannot load a virtual file.`);\n\t\t}\n\n\t\tconst full = join(root, path);\n\t\tconst data = this.strategy.filter(full);\n\t\tif (data === null) {\n\t\t\tStore.logger?.(`[STORE => ${this.name}] [LOAD] Skipped piece '${full}' as 'LoaderStrategy#filter' returned 'null'.`);\n\t\t\treturn [];\n\t\t}\n\n\t\tconst promises: Promise<T>[] = [];\n\t\tconst finishedData = this.hydrateModuleData(root, data);\n\t\tfor await (const Ctor of this.strategy.load(this, finishedData)) {\n\t\t\tpromises.push(this.insert(this.construct(Ctor, finishedData)));\n\t\t}\n\n\t\treturn Promise.all(promises);\n\t}\n\n\t/**\n\t * Unloads a piece given its instance or its name.\n\t * @param name The name of the file to load.\n\t * @return Returns the piece that was unloaded.\n\t */\n\tpublic async unload(name: string | T): Promise<T> {\n\t\tconst piece = this.resolve(name);\n\n\t\t// Unload piece:\n\t\tthis.strategy.onUnload(this, piece);\n\t\tawait piece.onUnload();\n\t\tStore.logger?.(`[STORE => ${this.name}] [UNLOAD] Unloaded piece '${piece.name}'.`);\n\n\t\t// Remove from cache and return it:\n\t\tthis.delete(piece.name);\n\t\tStore.logger?.(`[STORE => ${this.name}] [UNLOAD] Removed piece '${piece.name}'.`);\n\t\treturn piece;\n\t}\n\n\t/**\n\t * Unloads all pieces from the store.\n\t */\n\tpublic async unloadAll(): Promise<T[]> {\n\t\tconst promises: Promise<T>[] = [];\n\t\tfor (const piece of this.values()) {\n\t\t\tpromises.push(this.unload(piece));\n\t\t}\n\n\t\tconst results = await Promise.all(promises);\n\n\t\tthis.strategy.onUnloadAll(this);\n\t\tStore.logger?.(`[STORE => ${this.name}] [UNLOAD-ALL] Removed all pieces.`);\n\t\treturn results;\n\t}\n\n\t/**\n\t * Loads all pieces from all directories specified by {@link paths}.\n\t */\n\tpublic async loadAll(): Promise<void> {\n\t\tthis.#calledLoadAll = true;\n\n\t\tconst pieces: T[] = [];\n\t\tfor (const entry of this[ManuallyRegisteredPiecesSymbol].values()) {\n\t\t\tconst piece = this.construct(entry.piece as unknown as Constructor<T>, {\n\t\t\t\tname: entry.name,\n\t\t\t\troot: VirtualPath,\n\t\t\t\tpath: VirtualPath,\n\t\t\t\textension: VirtualPath\n\t\t\t});\n\t\t\tpieces.push(piece);\n\t\t}\n\n\t\tfor (const path of this.paths) {\n\t\t\tfor await (const piece of this.loadPath(path)) {\n\t\t\t\tpieces.push(piece);\n\t\t\t}\n\t\t}\n\n\t\tStore.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Found '${pieces.length}' pieces.`);\n\n\t\t// Clear the store before inserting the new pieces:\n\t\tawait this.unloadAll();\n\t\tStore.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Cleared all pieces.`);\n\n\t\t// Load each piece:\n\t\tfor (const piece of pieces) {\n\t\t\tawait this.insert(piece);\n\t\t}\n\n\t\t// Call onLoadAll:\n\t\tthis.strategy.onLoadAll(this);\n\t\tStore.logger?.(`[STORE => ${this.name}] [LOAD-ALL] Successfully loaded '${this.size}' pieces.`);\n\t}\n\n\t/**\n\t * Resolves a piece by its name or its instance.\n\t * @param name The name of the piece or the instance itself.\n\t * @return The resolved piece.\n\t */\n\tpublic resolve(name: string | T): T {\n\t\tif (typeof name === 'string') {\n\t\t\tconst result = this.get(name);\n\t\t\tif (typeof result === 'undefined') throw new LoaderError(LoaderErrorType.UnloadedPiece, `The piece '${name}' does not exist.`);\n\t\t\treturn result;\n\t\t}\n\n\t\tif (name instanceof this.Constructor) return name;\n\t\tthrow new LoaderError(LoaderErrorType.IncorrectType, `The piece '${name.name}' is not an instance of '${this.Constructor.name}'.`);\n\t}\n\n\t/**\n\t * Inserts a piece into the store.\n\t * @param piece The piece to be inserted into the store.\n\t * @return The inserted piece.\n\t */\n\tpublic async insert(piece: T): Promise<T> {\n\t\tif (!piece.enabled) return piece;\n\n\t\t// Load piece:\n\t\tthis.strategy.onLoad(this, piece);\n\t\tawait piece.onLoad();\n\t\tStore.logger?.(`[STORE => ${this.name}] [INSERT] Loaded new piece '${piece.name}'.`);\n\n\t\t// If the onLoad disabled the piece, call unload and return it:\n\t\tif (!piece.enabled) {\n\t\t\t// Unload piece:\n\t\t\tthis.strategy.onUnload(this, piece);\n\t\t\tawait piece.onUnload();\n\t\t\tStore.logger?.(`[STORE => ${this.name}] [INSERT] Unloaded new piece '${piece.name}' due to 'enabled' being 'false'.`);\n\n\t\t\treturn piece;\n\t\t}\n\n\t\t// Unload existing piece, if any:\n\t\tconst previous = super.get(piece.name);\n\t\tif (previous) {\n\t\t\tawait this.unload(previous);\n\t\t\tStore.logger?.(`[STORE => ${this.name}] [INSERT] Unloaded existing piece '${piece.name}' due to conflicting 'name'.`);\n\t\t}\n\n\t\t// Set the new piece and return it:\n\t\tthis.set(piece.name, piece);\n\t\tStore.logger?.(`[STORE => ${this.name}] [INSERT] Inserted new piece '${piece.name}'.`);\n\t\treturn piece;\n\t}\n\n\t/**\n\t * Constructs a {@link Piece} instance.\n\t * @param Ctor The {@link Piece}'s constructor used to build the instance.\n\t * @param data The module's information\n\t * @return An instance of the constructed piece.\n\t */\n\tpublic construct(Ctor: ILoaderResultEntry<T>, data: HydratedModuleData): T {\n\t\treturn new Ctor({ store: this, root: data.root, path: data.path, name: data.name }, { name: data.name, enabled: true });\n\t}\n\n\t/**\n\t * Adds the final module data properties.\n\t * @param root The root directory to add.\n\t * @param data The module data returned from {@link ILoaderStrategy.filter}.\n\t * @returns The finished module data.\n\t */\n\tprivate hydrateModuleData(root: string, data: ModuleData): HydratedModuleData {\n\t\treturn { root, ...data };\n\t}\n\n\t/**\n\t * Loads a directory into the store.\n\t * @param root The directory to load the pieces from.\n\t * @return An async iterator that yields the pieces to be loaded into the store.\n\t */\n\tprivate async *loadPath(root: string): AsyncIterableIterator<T> {\n\t\tStore.logger?.(`[STORE => ${this.name}] [WALK] Loading all pieces from '${root}'.`);\n\t\tfor await (const child of this.#walk(this, root, Store.logger)) {\n\t\t\tconst data = this.strategy.filter(child);\n\t\t\tif (data === null) {\n\t\t\t\tStore.logger?.(`[STORE => ${this.name}] [LOAD] Skipped piece '${child}' as 'LoaderStrategy#filter' returned 'null'.`);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\ttry {\n\t\t\t\tconst finishedData = this.hydrateModuleData(root, data);\n\t\t\t\tfor await (const Ctor of this.strategy.load(this, finishedData)) {\n\t\t\t\t\tyield this.construct(Ctor, finishedData);\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis.strategy.onError(error as Error, data.path);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The default strategy, defaults to {@link LoaderStrategy}, which is constructed on demand when a store is constructed,\n\t * when none was set beforehand.\n\t */\n\tpublic static defaultStrategy: ILoaderStrategy<any> = defaultStrategy;\n\n\t/**\n\t * The default logger, defaults to `null`.\n\t */\n\tpublic static logger: StoreLogger | null = null;\n}\n\n/**\n * An entry for a manually registered piece using {@linkcode Store.loadPiece()}.\n * @since 3.8.0\n */\nexport interface StoreManuallyRegisteredPiece<StoreName extends StoreRegistryKey> {\n\tname: string;\n\tpiece: StoreRegistryEntries[StoreName] extends Store<infer Piece> ? Constructor<Piece> : never;\n}\n\nexport namespace Store {\n\texport const Registry = StoreRegistry;\n\texport type Options<T extends Piece> = StoreOptions<T>;\n\texport type Logger = StoreLogger;\n\texport type RegistryEntries = StoreRegistryEntries;\n}\n"]}