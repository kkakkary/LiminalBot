var SapphireLexure = (function (exports) {
  'use strict';

  var __defProp = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
  var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

  // ../result/dist/esm/index.mjs
  var __defProp2 = Object.defineProperty;
  var __defNormalProp2 = /* @__PURE__ */ __name((obj, key, value) => key in obj ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value, "__defNormalProp");
  var __name2 = /* @__PURE__ */ __name((target, value) => __defProp2(target, "name", { value, configurable: true }), "__name");
  var __publicField2 = /* @__PURE__ */ __name((obj, key, value) => __defNormalProp2(obj, typeof key !== "symbol" ? key + "" : key, value), "__publicField");
  function isFunction(input) {
    return typeof input === "function";
  }
  __name(isFunction, "isFunction");
  __name2(isFunction, "isFunction");
  function returnThis() {
    return this;
  }
  __name(returnThis, "returnThis");
  __name2(returnThis, "returnThis");
  var _a;
  var _OptionError = (_a = class extends Error {
    get name() {
      return this.constructor.name;
    }
  }, __name(_a, "_OptionError"), _a);
  __name2(_OptionError, "OptionError");
  var OptionError = _OptionError;
  var _a2;
  var _ResultError = (_a2 = class extends Error {
    constructor(message, value) {
      super(message);
      __publicField2(this, "value");
      this.value = value;
    }
    get name() {
      return this.constructor.name;
    }
  }, __name(_a2, "_ResultError"), _a2);
  __name2(_ResultError, "ResultError");
  var ResultError = _ResultError;
  var ValueProperty = Symbol.for("@sapphire/result:Result.value");
  var SuccessProperty = Symbol.for("@sapphire/result:Result.success");
  var _a3;
  var _b;
  var _a4;
  var _Result = (_a4 = class {
    constructor(value, success) {
      __publicField2(this, _b);
      __publicField2(this, _a3);
      this[ValueProperty] = value;
      this[SuccessProperty] = success;
    }
    /**
     * Returns `true` if the result is `Ok`.
     *
     * @example
     * ```typescript
     * const x = ok(-3);
     * assert.equal(x.isOk(), true);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.isOk(), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok}
     */
    isOk() {
      return this[SuccessProperty];
    }
    isOkAnd(cb) {
      return this.isOk() && cb(this[ValueProperty]);
    }
    /**
     * Returns `true` if the result is `Err`.
     *
     * @example
     * ```typescript
     * const x = ok(-3);
     * assert.equal(x.isErr(), false);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.isErr(), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err}
     */
    isErr() {
      return !this[SuccessProperty];
    }
    isErrAnd(cb) {
      return this.isErr() && cb(this[ValueProperty]);
    }
    /**
     * Converts from `Result<T, E>` to `Option<T>`.
     *
     * Converts itself into an `Option<T>`, and discarding the error, if any.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.ok(), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.ok(), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.ok}
     */
    ok() {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => some(value), "ok"), err: /* @__PURE__ */ __name2(() => none, "err") });
    }
    /**
     * Converts from `Result<T, E>` to `Option<E>`.
     *
     * Converts itself into an `Option<E>`, and discarding the successful value, if any.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.err(), none);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.err(), 'Some error message');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.err}
     */
    err() {
      return this.match({ ok: /* @__PURE__ */ __name2(() => none, "ok"), err: /* @__PURE__ */ __name2((error) => some(error), "err") });
    }
    /**
     * Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained `Ok` value, leaving an `Err` value
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.map((value) => value * 2), ok(4));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.map((value) => value * 2), err('Some error message'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map}
     */
    map(cb) {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => ok(cb(value)), "ok"), err: returnThis });
    }
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Ok` value, leaving an `Err` value
     * untouched.
     *
     * Unlike {@link map}, this method does not wrap the returned value inside `Ok`, but instead, it returns the
     * returned value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * assert.equal(x.mapInto((value) => ok(value * value)), ok(4));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(0);
     * assert.equal(
     *   x.mapInto((value) => (value === 0 ? err('zero is not divisible') : ok(1 / value))),
     *   err('zero is not divisible')
     * );
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Some error message');
     * assert.equal(x.mapInto((value) => ok(4)), err('Some error message'));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapInto(cb) {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => cb(value), "ok"), err: returnThis });
    }
    /**
     * Returns the provided default (if `Err`), or applies a function to the contained value (if `Ok`),
     *
     * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use `mapOrElse`, which is lazily evaluated.
     * @param defaultValue The default value to use.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x = ok('hello');
     * assert.equal(x.mapOr(42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x = err('Some error message');
     * assert.equal(x.mapOr(42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or}
     */
    mapOr(defaultValue, cb) {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => cb(value), "ok"), err: /* @__PURE__ */ __name2(() => defaultValue, "err") });
    }
    /**
     * Maps a `Result<T, E>` to `U` by applying fallback function default to a contained `Err` value, or function `cb`
     * to a contained `Ok` value.
     *
     * This function can be used to unpack a successful result while handling an error.
     * @param op The predicate that is run on `Err`.
     * @param cb The predicate that is run on `Ok`.
     *
     * @example
     * ```typescript
     * const x: Result<string, string> = ok('hello');
     * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Result<string, string> = err('Some error message');
     * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 18);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else}
     */
    mapOrElse(op, cb) {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => cb(value), "ok"), err: /* @__PURE__ */ __name2((error) => op(error), "err") });
    }
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value
     * untouched.
     *
     * This function can be used to pass through a successful result while handling an error.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, Error> = ok(2);
     * assert.equal(x.mapErr((error) => error.message), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErr((error) => error.message), err('Some error message'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err}
     */
    mapErr(cb) {
      return this.match({ ok: returnThis, err: /* @__PURE__ */ __name2((error) => err(cb(error)), "err") });
    }
    /**
     * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value
     * untouched.
     *
     * This function can be used to pass through a successful result while handling an error.
     *
     * Unlike {@link mapErr}, this method does not wrap the returned value inside `Err`, but instead, it returns the
     * returned value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Result<number, Error> = ok(2);
     * assert.equal(x.mapErrInto((error) => err(error.message)), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErrInto((error) => err(error.message)), err('Some error message'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, Error> = err(new Error('Some error message'));
     * assert.equal(x.mapErrInto((error) => ok(4)), ok(4));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapErrInto(cb) {
      return this.match({ ok: returnThis, err: /* @__PURE__ */ __name2((error) => cb(error), "err") });
    }
    /**
     * Calls the provided closure with a reference to the contained value (if `Ok`).
     * @param cb The predicate.
     * @seealso {@link inspectAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * ok(2).inspect(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * err('Some error message').inspect(console.log);
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect}
     */
    inspect(cb) {
      if (this.isOk()) cb(this[ValueProperty]);
      return this;
    }
    /**
     * Calls the provided closure with a reference to the contained value (if `Ok`) and awaits it.
     * @param cb The predicate.
     * @seealso {@link inspect} for the sync version.
     *
     * @example
     * ```typescript
     * await ok(2).inspectAsync(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * await err('Some error message').inspectAsync(console.log);
     * // Doesn't log
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    async inspectAsync(cb) {
      if (this.isOk()) await cb(this[ValueProperty]);
      return this;
    }
    /**
     * Calls the provided closure with a reference to the contained error (if `Err`).
     * @param cb The predicate.
     * @seealso {@link inspectErrAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * ok(2).inspectErr(console.log);
     * // Doesn't log
     * ```
     * @example
     * ```typescript
     * err('Some error message').inspectErr(console.log);
     * // Logs: Some error message
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err}
     */
    inspectErr(cb) {
      if (this.isErr()) cb(this[ValueProperty]);
      return this;
    }
    /**
     * Calls the provided closure with a reference to the contained error (if `Err`) and awaits it.
     * @param cb The predicate.
     * @seealso {@link inspectErr} for the sync version.
     *
     * @example
     * ```typescript
     * await ok(2).inspectErrAsync(console.log);
     * // Doesn't log
     * ```
     * @example
     * ```typescript
     * await err('Some error message').inspectErrAsync(console.log);
     * // Logs: Some error message
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    async inspectErrAsync(cb) {
      if (this.isErr()) await cb(this[ValueProperty]);
      return this;
    }
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Ok`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = ok(7);
     * for (const value of x.iter()) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = err('Nothing!');
     * for (const value of x.iter()) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}
     */
    *iter() {
      if (this.isOk()) yield this[ValueProperty];
    }
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws a {@link ResultError} with the given message and the content of the `Err`.
     * @param message The message for the error.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.expect('Whoops!'), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.expect('Whoops!'), {
     *   name: 'ResultError',
     *   message: 'Whoops',
     *   value: 'Emergency failure'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect}
     */
    expect(message) {
      if (this.isErr()) throw new ResultError(message, this[ValueProperty]);
      return this[ValueProperty];
    }
    /**
     * Returns the contained `Err` value.
     *
     * If the value is an `Ok`, it throws a {@link ResultError} with the given message and the content of the `Ok`.
     * @param message The message for the error.
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.throws(() => x.expectErr('Whoops!'), {
     *   name: 'ResultError',
     *   message: 'Whoops',
     *   value: 2
     * });
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.equal(x.expectErr('Whoops!'), 'Emergency failure');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err}
     */
    expectErr(message) {
      if (this.isOk()) throw new ResultError(message, this[ValueProperty]);
      return this[ValueProperty];
    }
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws a {@link ResultError} with the message, and the content of the `Err`.
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.unwrap(), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.unwrap(), {
     *   name: 'ResultError',
     *   message: 'Unwrap failed',
     *   value: 'Emergency failure'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap}
     */
    unwrap() {
      if (this.isErr()) throw new ResultError("Unwrap failed", this[ValueProperty]);
      return this[ValueProperty];
    }
    /**
     * Returns the contained `Err` value.
     *
     * If the value is an `Ok`, it throws a {@link ResultError} with the message, and the content of the `Ok`.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapRaw}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.throws(() => x.unwrapErr(), {
     *   name: 'ResultError',
     *   message: 'Unwrap failed',
     *   value: 2
     * });
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.equal(x.unwrapErr(), 'Emergency failure');
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err}
     */
    unwrapErr() {
      if (this.isOk()) throw new ResultError("Unwrap failed", this[ValueProperty]);
      return this[ValueProperty];
    }
    /**
     * Returns the contained `Ok` value or the provided default.
     *
     * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link unwrapOrElse}, which is lazily evaluated.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @param defaultValue The default value.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(9);
     * assert.equal(x.unwrapOr(2), 9);
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Error');
     * assert.equal(x.unwrapOr(2), 2);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or}
     */
    unwrapOr(defaultValue) {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => value, "ok"), err: /* @__PURE__ */ __name2(() => defaultValue, "err") });
    }
    /**
     * Returns the contained `Ok` value or computes it from a closure.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapErr}
     * @seealso {@link unwrapRaw}
     *
     * @param op The predicate.
     *
     * @example
     * ```typescript
     * const count = (x: string) => x.length;
     *
     * assert.equal(ok(2).unwrapOrElse(count), 2);
     * assert.equal(err('hello').unwrapOrElse(count), 5);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else}
     */
    unwrapOrElse(op) {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => value, "ok"), err: /* @__PURE__ */ __name2((error) => op(error), "err") });
    }
    /**
     * Returns the contained `Ok` value.
     *
     * If the value is an `Err`, it throws the contained error.
     * @seealso {@link unwrap}
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     * @seealso {@link unwrapErr}
     *
     * @example
     * ```typescript
     * const x = ok(2);
     * assert.equal(x.unwrapRaw(), 2);
     * ```
     * @example
     * ```typescript
     * const x = err('Emergency failure');
     * assert.throws(() => x.unwrapRaw(), {
     *   name: 'Error',
     *   message: 'Unwrap failed',
     *   value: 'Emergency failure'
     * });
     * ```
     */
    unwrapRaw() {
      if (this.isErr()) throw this[ValueProperty];
      return this[ValueProperty];
    }
    /**
     * Returns `result` if the result is `Ok`, otherwise returns the `Err` value of itself.
     * @param result The result to check.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<string, string> = err('Late error');
     * assert.equal(x.and(y), err('Late error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<string, string> = err('Late error');
     * assert.equal(x.and(y), err('Early error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<string, string> = ok('Hello');
     * assert.equal(x.and(y), ok('Hello'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and}
     */
    and(result) {
      return this.match({ ok: /* @__PURE__ */ __name2(() => result, "ok"), err: returnThis });
    }
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * function fractionOf4(value: number) {
     *   return value === 0 ? err('overflowed') : ok(4 / value);
     * }
     *
     * assert.equal(ok(2).andThen(fractionOf4), ok(4));
     * assert.equal(ok(0).andThen(fractionOf4), err('overflowed'));
     * assert.equal(err('not a number').andThen(fractionOf4), err('not a number'));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}
     */
    andThen(cb) {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => cb(value), "ok"), err: returnThis });
    }
    /**
     * Return `result` if the result is `Err`, otherwise returns the `Ok` value of self.
     *
     * Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended
     * to use {@link orElse}, which is lazily evaluated.
     * @param result The result to check.
     *
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<number, string> = err('Late error');
     * assert.equal(x.or(y), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<number, string> = ok(2);
     * assert.equal(x.or(y), ok(2));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = err('Early error');
     * const y: Result<number, string> = err('Late error');
     * assert.equal(x.or(y), err('Late error'));
     * ```
     * @example
     * ```typescript
     * const x: Result<number, string> = ok(2);
     * const y: Result<number, string> = ok(100);
     * assert.equal(x.or(y), ok(2));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or}
     */
    or(result) {
      return this.match({ ok: returnThis, err: /* @__PURE__ */ __name2(() => result, "err") });
    }
    /**
     * Calls `cb` if the result is `Err`, otherwise returns the `Ok` value of self.
     *
     * This function can be used for control flow based on result values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const square = (x: number): Result<number, string> => ok(x * x);
     * const wrapErr = (x: number): Result<number, string> => err(x);
     *
     * assert.equal(ok(2).orElse(square).orElse(square), ok(2));
     * assert.equal(ok(2).orElse(wrapErr).orElse(square), ok(2));
     * assert.equal(err(3).orElse(square).orElse(wrapErr), ok(9));
     * assert.equal(err(3).orElse(wrapErr).orElse(wrapErr), err(3));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else}
     */
    orElse(cb) {
      return this.match({ ok: returnThis, err: /* @__PURE__ */ __name2((error) => cb(error), "err") });
    }
    contains(value) {
      return this.isOkAnd((inner) => inner === value);
    }
    containsErr(error) {
      return this.isErrAnd((inner) => inner === error);
    }
    /**
     * Transposes a `Result` of an `Option` into an `Option` of a `Result`.
     *
     * `ok(none)` will be mapped to `none`. `ok(some(v))` and `err(e)` will be mapped to `some(ok(v))` and `some(err(e))`.
     *
     * @example
     * ```typescript
     * const x: Result<Option<number>, Error> = ok(some(5));
     * const y: Option<Result<number, Error>> = some(ok(5));
     * assert.equal(x.transpose(), y);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose}
     */
    transpose() {
      return this.match({
        ok: /* @__PURE__ */ __name2((value) => value.map((value2) => ok(value2)), "ok"),
        err() {
          return some(this);
        }
      });
    }
    /**
     * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.
     *
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = ok(ok('Hello'));
     * assert.equal(x.flatten(), ok('Hello'));
     * ```
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = ok(err(6));
     * assert.equal(x.flatten(), err(6));
     * ```
     * @example
     * ```typescript
     * const x: Result<Result<string, number>, number> = err(6);
     * assert.equal(x.flatten(), err(6));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}
     */
    flatten() {
      return this.match({ ok: /* @__PURE__ */ __name2((value) => value, "ok"), err: returnThis });
    }
    /**
     * Returns the `Ok` value if self is `Ok`, and the `Err` value if self is `Err`.
     *
     * @example
     * ```typescript
     * let x: Result<number, number> = ok(3);
     * assert.equal(x.intoOkOrErr(), 3);
     * ```
     * @example
     * ```typescript
     * let x: Result<number, number> = err(4);
     * assert.equal(x.intoOkOrErr(), 4);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.into_ok_or_err}
     */
    intoOkOrErr() {
      return this[ValueProperty];
    }
    /**
     * Returns a `Promise` object with the awaited value (if `Ok`) or the awaited error (if `Err`).
     *
     * @example
     * ```typescript
     * let x = ok(Promise.resolve(3));
     * assert.equal(await x.intoPromise(), ok(3));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    intoPromise() {
      return this.match({
        ok: /* @__PURE__ */ __name2(async (value) => ok(await value), "ok"),
        // NOSONAR
        err: /* @__PURE__ */ __name2(async (error) => err(await error), "err")
        // NOSONAR
      });
    }
    /**
     * Checks whether or not `other` equals with self.
     * @param other The other result to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}
     */
    eq(other) {
      return this.isOk() === other.isOk() && this[ValueProperty] === other[ValueProperty];
    }
    /**
     * Checks whether or not `other` doesn't equal with self.
     * @param other The other result to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}
     */
    ne(other) {
      return !this.eq(other);
    }
    /**
     * Runs `ok` function if self is `Ok`, otherwise runs `err` function.
     * @param branches The branches to match.
     *
     * @example
     * ```typescript
     * const result = ok(4).match({
     *   ok: (v) => v,
     *   err: () => 0
     * });
     * assert.equal(result, 4);
     * ```
     * @example
     * ```typescript
     * const result = err('Hello').match({
     *   ok: (v) => v,
     *   err: () => 0
     * });
     * assert.equal(result, 0);
     * ```
     */
    match(branches) {
      return this.isOk() ? branches.ok.call(this, this[ValueProperty]) : branches.err.call(this, this[ValueProperty]);
    }
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Ok`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = ok(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = err('Nothing!');
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link IResult.iter}
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}
     */
    [(_b = ValueProperty, _a3 = SuccessProperty, Symbol.iterator)]() {
      return this.iter();
    }
    get [Symbol.toStringTag]() {
      return this.match({ ok: /* @__PURE__ */ __name2(() => "Ok", "ok"), err: /* @__PURE__ */ __name2(() => "Err", "err") });
    }
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    static ok(value) {
      return new _a4(value, true);
    }
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    static err(value) {
      return new _a4(value, false);
    }
    /**
     * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object. This override
     * exists to interoperate with other versions of this class, such as the one coming from another version of this
     * library or from a different build.
     *
     * @param instance The instance to check.
     * @returns Whether or not the instance is a `Result`.
     *
     * @example
     * ```typescript
     * import { Result } from '@sapphire/result';
     * const { ok } = require('@sapphire/result');
     *
     * ok(2) instanceof Result; // true
     * ```
     */
    static [Symbol.hasInstance](instance) {
      return typeof instance === "object" && instance !== null && ValueProperty in instance && SuccessProperty in instance;
    }
    /**
     * @deprecated Use {@link Result.isResult} instead.
     *
     * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.
     *
     * @param instance The instance to check.
     * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.
     *
     * @example
     * ```typescript
     * import { Result } from '@sapphire/result';
     * const { ok } = require('@sapphire/result');
     *
     * Result.isResult(ok(2)); // true
     * ```
     */
    static is(instance) {
      return _a4[Symbol.hasInstance](instance);
    }
    /**
     * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.
     *
     * @param instance The instance to check.
     * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.
     *
     * @example
     * ```typescript
     * import { Result } from '@sapphire/result';
     * const { ok } = require('@sapphire/result');
     *
     * Result.isResult(ok(2)); // true
     * ```
     */
    static isResult(instance) {
      return _a4[Symbol.hasInstance](instance);
    }
    /**
     * Creates a {@link Result} out of a callback.
     *
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    static from(op) {
      try {
        return resolve(isFunction(op) ? op() : op);
      } catch (error) {
        return err(error);
      }
    }
    /**
     * Creates a {@link Result} out of a promise or async callback.
     *
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    static async fromAsync(op) {
      try {
        return resolve(await (isFunction(op) ? op() : op));
      } catch (error) {
        return err(error);
      }
    }
    /**
     * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first
     * {@link Err} encountered.
     *
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    static all(results) {
      const values = [];
      for (const result of results) {
        if (result.isErr()) return result;
        values.push(result[ValueProperty]);
      }
      return ok(values);
    }
    /**
     * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.
     *
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    static any(results) {
      const errors = [];
      for (const result of results) {
        if (result.isOk()) return result;
        errors.push(result[ValueProperty]);
      }
      return err(errors);
    }
  }, __name(_a4, "_Result"), _a4);
  __name2(_Result, "Result");
  var Result = _Result;
  var { ok, err } = Result;
  function resolve(value) {
    return Result.isResult(value) ? value : ok(value);
  }
  __name(resolve, "resolve");
  __name2(resolve, "resolve");
  var ValueProperty2 = Symbol.for("@sapphire/result:Option.value");
  var ExistsProperty = Symbol.for("@sapphire/result:Option.exists");
  var _a22;
  var _b2;
  var _a5;
  var _Option = (_a5 = class {
    constructor(value, exists) {
      __publicField2(this, _b2);
      __publicField2(this, _a22);
      this[ValueProperty2] = value;
      this[ExistsProperty] = exists;
    }
    /**
     * Returns `true` if the option is a `Some` value.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isSome(), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isSome(), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some}
     */
    isSome() {
      return this[ExistsProperty];
    }
    isSomeAnd(cb) {
      return this.isSome() && cb(this[ValueProperty2]);
    }
    /**
     * Returns `true` if the option is a `None` value.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.isNone(), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.isNone(), true);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none}
     */
    isNone() {
      return !this[ExistsProperty];
    }
    isNoneOr(cb) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => cb(value), "some"), none: /* @__PURE__ */ __name2(() => true, "none") });
    }
    /**
     * Returns the contained `Some` value.
     * @param message The message for the error.
     * If the value is an `Err`, it throws an {@link OptionError} with the given message.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some(2);
     * assert.equal(x.expect('Whoops!'), 2);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.throws(() => x.expect('Whoops!'), {
     *   name: 'OptionError',
     *   message: 'Whoops'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.expect}
     */
    expect(message) {
      if (this.isNone()) throw new OptionError(message);
      return this[ValueProperty2];
    }
    /**
     * Returns the contained `Some` value.
     *
     * If the value is an `Err`, it throws an {@link OptionError} with the message.
     * @seealso {@link unwrapOr}
     * @seealso {@link unwrapOrElse}
     *
     * @example
     * ```typescript
     * const x: Option<string> = some(2);
     * assert.equal(x.unwrap(), 2);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.throws(() => x.unwrap(), {
     *   name: 'OptionError',
     *   message: 'Unwrap failed'
     * });
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap}
     */
    unwrap() {
      if (this.isNone()) throw new OptionError("Unwrap failed");
      return this[ValueProperty2];
    }
    /**
     * Returns the contained `Some` value or a provided default.
     *
     * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link unwrapOrElse}, which is lazily evaluated.
     *
     * @example
     * ```typescript
     * assert.equal(some(2).unwrapOr(0), 2);
     * ```
     * @example
     * ```typescript
     * assert.equal(none.unwrapOr(0), 0);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or}
     */
    unwrapOr(defaultValue) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => value, "some"), none: /* @__PURE__ */ __name2(() => defaultValue, "none") });
    }
    /**
     * Returns the contained Some value or computes it from a closure.
     *
     * @example
     * ```typescript
     * assert.equal(some(2).unwrapOrElse(() => 0), 2);
     * ```
     * @example
     * ```typescript
     * assert.equal(none.unwrapOrElse(() => 0), 0);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else}
     */
    unwrapOrElse(cb) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => value, "some"), none: cb });
    }
    /**
     * Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const maybeSomeString = some('Hello, world!');
     * const maybeSomeLength = maybeSomeString.map((value) => value.length);
     *
     * assert.equal(maybeSomeLength, some(13));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map}
     */
    map(cb) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => some(cb(value)), "some"), none: returnThis });
    }
    /**
     * Maps a `Some<T>` to the returned `Option<U>` by applying a function to a contained value, leaving `None`
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const input: Option<string> = some('Hello, world!');
     * const result = input.mapInto((value) => some(value.length));
     *
     * assert.equal(result, some(13));
     * ```
     * @example
     * ```typescript
     * const input: Option<string> = none;
     * const result = input.mapInto((value) => some(value.length));
     *
     * assert.equal(result, none);
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapInto(cb) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => cb(value), "some"), none: returnThis });
    }
    /**
     * Returns the provided default result (if none), or applies a function to the contained value (if any).
     *
     * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link mapOrElse}, which is lazily evaluated.
     * @param defaultValue The default value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.mapOr(42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.mapOr(42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or}
     */
    mapOr(defaultValue, cb) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => cb(value), "some"), none: /* @__PURE__ */ __name2(() => defaultValue, "none") });
    }
    /**
     * Computes a default function result (if none), or applies a different function to the contained value (if any).
     * @param defaultValue The default value.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 5);
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 42);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else}
     */
    mapOrElse(defaultValue, cb) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => cb(value), "some"), none: /* @__PURE__ */ __name2(() => defaultValue(), "none") });
    }
    /**
     * Maps a `None` to the returned `Option<U>` by applying a function to a contained value, leaving `Some<T>`
     * untouched.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const input: Option<string> = some('Hello, world!');
     * const result = input.mapNoneInto(() => some(13));
     *
     * assert.equal(result, some('Hello, world!'));
     * ```
     * @example
     * ```typescript
     * const input: Option<string> = none;
     * const result = input.mapNoneInto(() => some(13));
     *
     * assert.equal(result, some(13));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    mapNoneInto(cb) {
      return this.match({ some: returnThis, none: cb });
    }
    /**
     * Calls the provided closure with a reference to the contained value (if `Some`).
     * @param cb The predicate.
     * @seealso {@link inspectAsync} for the awaitable version.
     *
     * @example
     * ```typescript
     * some(2).inspect(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * none.inspect(console.log);
     * // Doesn't log
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.inspect}
     */
    inspect(cb) {
      if (this.isSome()) cb(this[ValueProperty2]);
      return this;
    }
    /**
     * Calls the provided closure with a reference to the contained value (if `Some`).
     * @param cb The predicate.
     * @seealso {@link inspect} for the sync version.
     *
     * @example
     * ```typescript
     * await some(2).inspectAsync(console.log);
     * // Logs: 2
     * ```
     * @example
     * ```typescript
     * await none.inspectAsync(console.log);
     * // Doesn't log
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    async inspectAsync(cb) {
      if (this.isSome()) await cb(this[ValueProperty2]);
      return this;
    }
    /**
     * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err)`.
     *
     * Arguments passed to `okOr` are eagerly evaluated; if you are passing the result of a function call, it is
     * recommended to use {@link okOrElse}, which is lazily evaluated.
     * @param err The error to be used.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.okOr(0), ok('hello'));
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.okOr(0), err(0));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or}
     */
    okOr(error) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => ok(value), "some"), none: /* @__PURE__ */ __name2(() => err(error), "none") });
    }
    /**
     * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err())`.
     * @param cb The error to be used.
     *
     * @example
     * ```typescript
     * const x: Option<string> = some('hello');
     * assert.equal(x.okOrElse(() => 0), ok('hello'));
     * ```
     * @example
     * ```typescript
     * const x: Option<string> = none;
     * assert.equal(x.okOrElse(() => 0), err(0));
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else}
     */
    okOrElse(cb) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => ok(value), "some"), none: /* @__PURE__ */ __name2(() => err(cb()), "none") });
    }
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Some`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = some(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = none;
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link Option.iter}
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}
     */
    *iter() {
      if (this.isSome()) yield this[ValueProperty2];
    }
    /**
     * Returns `None` if the option is `None`, otherwise returns `option`.
     * @param option The option.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<string> = none;
     * assert.equal(x.and(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<string> = some('foo');
     * assert.equal(x.and(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<string> = some('foo');
     * assert.equal(x.and(y), some('foo'));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<string> = none;
     * assert.equal(x.and(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.and}
     */
    and(option) {
      return this.match({ some: /* @__PURE__ */ __name2(() => option, "some"), none: returnThis });
    }
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * function fractionOf4(value: number) {
     *   return value === 0 ? none : some(4 / value);
     * }
     *
     * assert.equal(some(2).andThen(fractionOf4), some(4));
     * assert.equal(some(0).andThen(fractionOf4), none);
     * assert.equal(none.andThen(fractionOf4), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}
     */
    andThen(cb) {
      return this.match({ some: /* @__PURE__ */ __name2((value) => cb(value), "some"), none: returnThis });
    }
    /**
     * Returns the option if it contains a value, otherwise returns `option`.
     * @param option The option.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = none;
     * assert.equal(x.or(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = some(100);
     * assert.equal(x.or(y), some(100));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = some(100);
     * assert.equal(x.or(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = none;
     * assert.equal(x.or(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or}
     */
    or(option) {
      return this.match({ some: returnThis, none: /* @__PURE__ */ __name2(() => option, "none") });
    }
    /**
     * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.
     *
     * This function can be used for control flow based on `Result` values.
     * @param cb The predicate.
     *
     * @example
     * ```typescript
     * const nobody = (): Option<string> => none;
     * const vikings = (): Option<string> => some('vikings');
     *
     * assert.equal(some('barbarians').orElse(vikings), some('barbarians'));
     * assert.equal(none.orElse(vikings), some('vikings'));
     * assert.equal(none.orElse(nobody), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or_else}
     */
    orElse(cb) {
      return this.match({ some: returnThis, none: /* @__PURE__ */ __name2(() => cb(), "none") });
    }
    /**
     * Returns `Some` if exactly one of self or `option` is `Some`, otherwise returns `None`.
     * @param option The option to compare.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = none;
     * assert.equal(x.xor(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = some(2);
     * assert.equal(x.xor(y), some(2));
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * const y: Option<number> = some(2);
     * assert.equal(x.xor(y), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * const y: Option<number> = none;
     * assert.equal(x.xor(y), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.xor}
     */
    xor(option) {
      return this.match({
        some() {
          return option.isNone() ? this : none;
        },
        none: /* @__PURE__ */ __name2(() => option, "none")
      });
    }
    filter(predicate) {
      return this.isSomeAnd(predicate) ? this : none;
    }
    /**
     * Returns `true` if the option is a `Some` value containing the given value.
     * @param value The value to compare.
     *
     * @example
     * ```typescript
     * const x: Option<number> = some(2);
     * assert.equal(x.contains(2), true);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = some(3);
     * assert.equal(x.contains(2), false);
     * ```
     * @example
     * ```typescript
     * const x: Option<number> = none;
     * assert.equal(x.contains(2), false);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.contains}
     */
    contains(value) {
      return this.isSomeAnd((inner) => inner === value);
    }
    /**
     * Zips self with another `Option`.
     *
     * If self is `Some(s)` and `other` is `Some(o)`, this method returns `Some([s, o])`. Otherwise, `None` is returned.
     * @param other The option to zip self with.
     *
     * @example
     * ```typescript
     * const x = some(1);
     * const y = some('hi');
     * const z = none;
     *
     * assert.equal(x.zip(y), some([1, 'hi']));
     * assert.equal(x.zip(z), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip}
     */
    zip(other) {
      return this.isSome() && other.isSome() ? some([this[ValueProperty2], other[ValueProperty2]]) : none;
    }
    /**
     * Zips self and another `Option` with function `f`.
     *
     * If self is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`. Otherwise, `None` is returned.
     * @param other The option to zip self with.
     * @param f The function that computes the returned value.
     *
     * @example
     * ```typescript
     * class Point {
     *   public readonly x: number;
     *   public readonly y: number;
     *
     *   public constructor(x: number, y: number) {
     *     this.x = x;
     *     this.y = y;
     *   }
     * }
     *
     * const x = some(17.5);
     * const y = some(42.7);
     *
     * assert.equal(x.zipWith(y, (s, o) => new Point(s, o)), some(new Point(17.5, 42.7)));
     * assert.equal(x.zipWith(none, (s, o) => new Point(s, o)), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip_with}
     */
    zipWith(other, f) {
      return this.isSome() && other.isSome() ? some(f(this[ValueProperty2], other[ValueProperty2])) : none;
    }
    /**
     * Unzips an option containing a tuple of two options.
     *
     * If self is `Some([a, b])` this method returns `[Some(a), Some(b)]`. Otherwise, `[None, None]` is returned.
     *
     * @example
     * ```typescript
     * const x: Option<[number, string]> = some([1, 'hi']);
     * assert.equal(x.unzip(), [some(1), some('hi')]);
     * ```
     * @example
     * ```typescript
     * const x: Option<[number, string]> = none;
     * assert.equal(x.unzip(), [none, none]);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unzip}
     */
    unzip() {
      return this.match({
        some: /* @__PURE__ */ __name2(([value0, value1]) => [some(value0), some(value1)], "some"),
        none: /* @__PURE__ */ __name2(() => [none, none], "none")
      });
    }
    /**
     * Transposes an `Option` of a `Result` into a `Result` of an `Option`.
     *
     * `none` will be mapped to `ok(none)`. `some(ok(v))` and `some(err(e))` will be mapped to `ok(some(v))` and `err(e)`.
     *
     * @example
     * ```typescript
     * const x: Option<Result<number, Error>> = some(ok(5));
     * const y: Result<Option<number>, Error> = ok(some(5));
     * assert.equal(x.transpose(), y);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose}
     */
    transpose() {
      return this.match({
        // @ts-expect-error Complex types
        some: /* @__PURE__ */ __name2((result) => result.map(some), "some"),
        none: /* @__PURE__ */ __name2(() => ok(none), "none")
      });
    }
    /**
     * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.
     *
     * @example
     * ```typescript
     * const x: Option<Option<number>> = some(some(6));
     * assert.equal(x.flatten(), some(6));
     * ```
     * @example
     * ```typescript
     * const x: Option<Option<number>> = some(none);
     * assert.equal(x.flatten(), none);
     * ```
     * @example
     * ```typescript
     * const x: Option<Option<number>> = none;
     * assert.equal(x.flatten(), none);
     * ```
     *
     * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}
     */
    flatten() {
      return this.match({ some: /* @__PURE__ */ __name2((inner) => inner, "some"), none: returnThis });
    }
    /**
     * Returns a `Promise` object with the awaited value (if `Some`).
     *
     * @example
     * ```typescript
     * let x = some(Promise.resolve(3));
     * assert.equal(await x.intoPromise(), some(3));
     * ```
     *
     * @note This is an extension not supported in Rust
     */
    intoPromise() {
      return this.match({
        some: /* @__PURE__ */ __name2(async (value) => some(await value), "some"),
        // NOSONAR
        none: /* @__PURE__ */ __name2(() => Promise.resolve(none), "none")
      });
    }
    /**
     * Checks whether or not `other` equals with self.
     * @param other The other option to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}
     */
    eq(other) {
      return this.isSome() === other.isSome() && this[ValueProperty2] === other[ValueProperty2];
    }
    /**
     * Checks whether or not `other` doesn't equal with self.
     * @param other The other option to compare.
     *
     * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}
     */
    ne(other) {
      return !this.eq(other);
    }
    /**
     * Runs `ok` function if self is `Ok`, otherwise runs `err` function.
     * @param branches The branches to match.
     *
     * @example
     * ```typescript
     * const option = some(4).match({
     *   some: (v) => v,
     *   none: () => 0
     * });
     * assert.equal(option, 4);
     * ```
     * @example
     * ```typescript
     * const option = none.match({
     *   some: (v) => v,
     *   none: () => 0
     * });
     * assert.equal(option, 0);
     * ```
     */
    match(branches) {
      return this.isSome() ? branches.some.call(this, this[ValueProperty2]) : branches.none.call(this);
    }
    /**
     * Returns an iterator over the possibly contained value.
     *
     * The iterator yields one value if the result is `Some`, otherwise none.
     *
     * @example
     * ```typescript
     * const x = some(7);
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Logs 7
     * ```
     * @example
     * ```typescript
     * const x = none;
     * for (const value of x) {
     *   console.log(value);
     * }
     * // Doesn't log
     * ```
     *
     * @see {@link IOption.iter}
     * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}
     */
    [(_b2 = ValueProperty2, _a22 = ExistsProperty, Symbol.iterator)]() {
      return this.iter();
    }
    get [Symbol.toStringTag]() {
      return this.match({ some: /* @__PURE__ */ __name2(() => "Some", "some"), none: /* @__PURE__ */ __name2(() => "None", "none") });
    }
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    static some(value) {
      return new _a5(value, true);
    }
    /**
     * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object. This override
     * exists to interoperate with other versions of this class, such as the one coming from another version of this
     * library or from a different build.
     *
     * @param instance The instance to check.
     * @returns Whether or not the instance is a `Option`.
     *
     * @example
     * ```typescript
     * import { Option } from '@sapphire/result';
     * const { some } = require('@sapphire/result');
     *
     * some(2) instanceof Option; // true
     * ```
     */
    static [Symbol.hasInstance](instance) {
      return typeof instance === "object" && instance !== null && ValueProperty2 in instance && ExistsProperty in instance;
    }
    /**
     * @deprecated Use {@link Option.isOption} instead.
     *
     * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.
     *
     * @param instance The instance to check.
     * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.
     *
     * @example
     * ```typescript
     * import { Option } from '@sapphire/result';
     * const { some } = require('@sapphire/result');
     *
     * Option.isOption(some(2)); // true
     * ```
     */
    static is(instance) {
      return _a5[Symbol.hasInstance](instance);
    }
    /**
     * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.
     *
     * @param instance The instance to check.
     * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.
     *
     * @example
     * ```typescript
     * import { Option } from '@sapphire/result';
     * const { some } = require('@sapphire/result');
     *
     * Option.isOption(some(2)); // true
     * ```
     */
    static isOption(instance) {
      return _a5[Symbol.hasInstance](instance);
    }
    /**
     * Creates a {@link Result} out of a callback.
     *
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    static from(op) {
      try {
        return resolve2(isFunction(op) ? op() : op);
      } catch {
        return none;
      }
    }
    /**
     * Creates a {@link Result} out of a promise or async callback.
     *
     * @typeparam T The result's type.
     * @typeparam E The error's type.
     */
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    static async fromAsync(op) {
      try {
        return resolve2(await (isFunction(op) ? op() : op));
      } catch {
        return none;
      }
    }
    /**
     * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first
     * {@link Err} encountered.
     *
     * @param results An array of {@link Result}s.
     * @returns A new {@link Result}.
     */
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    static all(results) {
      const values = [];
      for (const result of results) {
        if (result.isNone()) return result;
        values.push(result[ValueProperty2]);
      }
      return some(values);
    }
    /**
     * Returns the first encountered {@link Some}, or a {@link None} if none was found.
     *
     * @param options An array of {@link Option}s.
     * @returns A new {@link Option}.
     */
    // eslint-disable-next-line @typescript-eslint/no-invalid-void-type
    static any(results) {
      for (const result of results) {
        if (result.isSome()) return result;
      }
      return none;
    }
  }, __name(_a5, "_Option"), _a5);
  __name2(_Option, "Option");
  __publicField2(_Option, "none", new _Option(null, false));
  var Option = _Option;
  var { some, none } = Option;
  function resolve2(value) {
    if (value === null || value === void 0) return none;
    if (Option.isOption(value)) return value;
    return some(value);
  }
  __name(resolve2, "resolve2");
  __name2(resolve2, "resolve");

  // src/lib/ArgumentStream.ts
  var _ArgumentStream = class _ArgumentStream {
    constructor(results) {
      __publicField(this, "results");
      __publicField(this, "state");
      this.results = results;
      this.state = { used: /* @__PURE__ */ new Set(), position: 0 };
    }
    /**
     * Whether or not all ordered parameters were used.
     */
    get finished() {
      return this.used === this.length;
    }
    /**
     * The amount of ordered parameters.
     */
    get length() {
      return this.results.ordered.length;
    }
    /**
     * The remaining amount of ordered parameters.
     */
    get remaining() {
      return this.length - this.used;
    }
    /**
     * The amount of ordered parameters that have been used.
     */
    get used() {
      return this.state.used.size;
    }
    /**
     * Retrieves the value of the next unused ordered token.
     *
     * @example
     * ```typescript
     * // Assume args are '1 2 3':
     *
     * console.log(args.single());
     * // Ok { value: '1' }
     *
     * console.log(args.single());
     * // Ok { value: '2' }
     *
     * console.log(args.single());
     * // Ok { value: '3' }
     *
     * console.log(args.single());
     * // None
     * ```
     *
     * @returns The value, if any.
     */
    single() {
      if (this.finished) return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      this.state.used.add(this.state.position);
      return Option.some(this.results.ordered[this.state.position++].value);
    }
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     *
     * @note This does not support asynchronous results, refer to {@link singleMapAsync}.
     *
     * @example
     * ```typescript
     * const parse = (value) => {
     *   const number = Number(value);
     *   return Number.isNaN(number) ? Option.none : Option.some(number);
     * };
     *
     * // Assume args are '1 2 3':
     *
     * console.log(args.singleMap(parse));
     * // Some { value: 1 }
     *
     * console.log(args.singleMap(parse));
     * // Some { value: 2 }
     *
     * console.log(args.singleMap(parse));
     * // Some { value: 3 }
     *
     * console.log(args.singleMap(parse));
     * // None
     * ```
     *
     * @typeparam T The output type.
     * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
     * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
     * @returns The mapped value, if any.
     */
    singleMap(predicate, useAnyways = false) {
      if (this.finished) return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = predicate(this.results.ordered[this.state.position].value);
      if (result.isSome() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     *
     * @note This is an asynchronous variant of {@link singleMap}.
     *
     * @typeparam T The output type.
     * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
     * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
     * @returns The mapped value, if any.
     */
    async singleMapAsync(predicate, useAnyways = false) {
      if (this.finished) return Option.none;
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = await predicate(this.results.ordered[this.state.position].value);
      if (result.isSome() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    /**
     * Finds and retrieves the next unused parameter and transforms it.
     *
     * @note This is a variant of {@link findMap} that returns the errors on failure.
     * @note This does not support asynchronous results, refer to {@link singleParseAsync}.
     *
     * @example
     * ```typescript
     * const parse = (value) => {
     *   const number = Number(value);
     *   return Number.isNaN(number)
     *     ? Result.err(`Could not parse ${value} to a number`)
     *     : Result.ok(number);
     * };
     *
     * // Assume args are '1 2 3':
     *
     * console.log(args.singleParse(parse));
     * // Ok { value: 1 }
     *
     * console.log(args.singleParse(parse));
     * // Ok { value: 2 }
     *
     * console.log(args.singleParse(parse));
     * // Ok { value: 3 }
     *
     * console.log(args.singleParse(parse));
     * // Err { error: null }
     * ```
     *
     * @typeparam T The output type.
     * @typeparam E The error type.
     * @param predicate The predicate that determines the parameter's transformed value, or nothing if failed.
     * @param useAnyways Whether to consider the parameter used even if the transformation failed. Defaults to `false`.
     * @returns The transformed value, if any.
     */
    singleParse(predicate, useAnyways = false) {
      if (this.finished) return Result.err(null);
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = predicate(this.results.ordered[this.state.position].value);
      if (result.isOk() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    /**
     * Retrieves the value of the next unused ordered token, but only if it could be transformed.
     *
     * @note This is an asynchronous variant of {@link singleParse}.
     *
     * @typeparam T The output type.
     * @typeparam E The error type.
     * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.
     * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.
     * @returns The mapped value, if any.
     */
    async singleParseAsync(predicate, useAnyways = false) {
      if (this.finished) return Result.err(null);
      while (this.state.used.has(this.state.position)) {
        ++this.state.position;
      }
      const result = await predicate(this.results.ordered[this.state.position].value);
      if (result.isOk() || useAnyways) {
        this.state.used.add(this.state.position);
        ++this.state.position;
      }
      return result;
    }
    /**
     * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and
     * `Option.none` otherwise.
     *
     * @note This does not support asynchronous results, refer to {@link findAsync}.
     *
     * @example
     * ```typescript
     * // Suppose args are from 'ba aa cc'.
     *
     * console.log(args.find((value) => value.startsWith('a')));
     * // Some { value: 'aa' }
     * ```
     *
     * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
     * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`
     * with that element value. Otherwise, find returns `Option.none`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    find(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        if (predicate(parameter)) {
          this.state.used.add(i);
          return Option.some(parameter);
        }
      }
      return Option.none;
    }
    /**
     * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and
     * `Option.none` otherwise.
     *
     * @note This is an asynchronous variant of {@link find}.
     *
     * @example
     * ```typescript
     * // Suppose args are from 'ba aa cc'.
     *
     * console.log(args.find((value) => value.startsWith('a')));
     * // Some { value: 'aa' }
     * ```
     *
     * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
     * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`
     * with that element value. Otherwise, find returns `Option.none`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    async findAsync(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        if (await predicate(parameter)) {
          this.state.used.add(i);
          return Option.some(parameter);
        }
      }
      return Option.none;
    }
    /**
     * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and
     * `Option.none` otherwise.
     *
     * @note This does not support asynchronous results, refer to {@link findMapAsync}.
     *
     * @example
     * ```typescript
     * // Suppose args are from 'ba aa cc'.
     *
     * console.log(args.find((value) => value.startsWith('a')));
     * // Some { value: 'aa' }
     * ```
     *
     * @typeparam T The output type.
     * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
     * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned
     * value. Otherwise, find returns `Option.none`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    findMap(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        if (result.isSome()) {
          this.state.used.add(i);
          return result;
        }
      }
      return Option.none;
    }
    /**
     * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and
     * `Option.none` otherwise.
     *
     * @note This is an asynchronous variant of {@link findMap}.
     *
     * @example
     * ```typescript
     * // Suppose args are from 'ba aa cc'.
     *
     * console.log(args.find((value) => value.startsWith('a')));
     * // Some { value: 'aa' }
     * ```
     *
     * @typeparam T The output type.
     * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it
     * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned
     * value. Otherwise, find returns `Option.none`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    async findMapAsync(predicate, from = this.state.position) {
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        if (result.isSome()) {
          this.state.used.add(i);
          return result;
        }
      }
      return Option.none;
    }
    /**
     * Finds and retrieves the first unused parameter that could be transformed.
     *
     * @note This is a variant of {@link findMap} that returns the errors on failure.
     * @note This does not support asynchronous results, refer to {@link findParseAsync}.
     *
     * @example
     * ```typescript
     * const parse = (value) => {
     *   const number = Number(value);
     *   return Number.isNaN(number)
     *     ? Result.err(`Could not parse ${value} to a number`)
     *     : Result.ok(number);
     * };
     *
     * // Suppose args are from 'ba 1 cc'.
     *
     * console.log(args.findParse(parse));
     * // Ok { value: 1 }
     *
     * console.log(args.findParse(parse));
     * // Err {
     * //   error: [
     * //     'Could not parse ba to a number',
     * //     'Could not parse cc to a number'
     * //   ]
     * // }
     * ```
     *
     * @typeparam T The output type.
     * @typeparam E The error type.
     * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until
     * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the
     * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    findParse(predicate, from = this.state.position) {
      const errors = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        if (result.isOk()) {
          this.state.used.add(i);
          return result;
        }
        errors.push(result.unwrapErr());
      }
      return Result.err(errors);
    }
    /**
     * Finds and retrieves the first unused parameter that could be transformed.
     *
     * @note This is a variant of {@link findMapAsync} that returns the errors on failure.
     * @note This is an asynchronous variant of {@link findParse}.
     *
     * @typeparam T The output type.
     * @typeparam E The error type.
     * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until
     * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the
     * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The found parameter's value.
     */
    async findParseAsync(predicate, from = this.state.position) {
      const errors = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        if (result.isOk()) {
          this.state.used.add(i);
          return result;
        }
        errors.push(result.unwrapErr());
      }
      return Result.err(errors);
    }
    /**
     * Retrieves multiple unused parameters.
     *
     * @example
     * ```typescript
     * // Assume args are '1 2 3':
     *
     * console.log(join(args.many().unwrap()));
     * // '1 2 3'
     * ```
     *
     * @example
     * ```typescript
     * // Assume args are '1 2 3':
     *
     * console.log(join(args.many(2).unwrap()));
     * // '1 2'
     * ```
     *
     * @param limit The maximum amount of parameters to retrieve, defaults to `Infinity`.
     * @param from The position where to start looking for unused parameters, defaults to current position.
     * @returns The unused parameters within the range.
     */
    many(limit = Infinity, from = this.state.position) {
      if (this.finished) return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        this.state.used.add(i);
        parameters.push(this.results.ordered[i]);
        if (parameters.length >= limit) break;
      }
      return parameters.length ? Option.some(parameters) : Option.none;
    }
    filter(predicate, from = this.state.position) {
      if (this.finished) return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        if (predicate(parameter)) {
          this.state.used.add(i);
          parameters.push(parameter);
        }
      }
      return Option.some(parameters);
    }
    async filterAsync(predicate, from = this.state.position) {
      if (this.finished) return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        if (await predicate(parameter)) {
          this.state.used.add(i);
          parameters.push(parameter);
        }
      }
      return Option.some(parameters);
    }
    filterMap(predicate, from = this.state.position) {
      if (this.finished) return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        const result = predicate(parameter);
        result.inspect((value) => {
          this.state.used.add(i);
          parameters.push(value);
        });
      }
      return Option.some(parameters);
    }
    async filterMapAsync(predicate, from = this.state.position) {
      if (this.finished) return Option.none;
      const parameters = [];
      for (let i = from; i < this.length; ++i) {
        if (this.state.used.has(i)) continue;
        const parameter = this.results.ordered[i].value;
        const result = await predicate(parameter);
        result.inspect((value) => {
          this.state.used.add(i);
          parameters.push(value);
        });
      }
      return Option.some(parameters);
    }
    /**
     * Checks whether any of the flags were given.
     *
     * @example
     * ```typescript
     * // Assume args are '--f --g':
     *
     * console.log(args.flag('f'));
     * // true
     *
     * console.log(args.flag('g', 'h'));
     * // true
     *
     * console.log(args.flag('h'));
     * // false
     * ```
     *
     * @param keys The names of the flags to check.
     * @returns Whether or not any of the flags were given.
     */
    flag(...keys) {
      return keys.some((key) => this.results.flags.has(key));
    }
    /**
     * Gets the last value of any option. When there are multiple names, the last value of the last found name is given.
     *
     * @example
     * ```typescript
     * // Assume args are '--a=1 --b=2 --c=3'.
     * console.log(args.option('a'));
     * // Some { value: '1' }
     *
     * console.log(args.option('b', 'c'));
     * // Some { value: '3' }
     *
     * console.log(args.option('d'));
     * // None {}
     * ```
     *
     * @param keys The names of the options to check.
     * @returns The last value of the option, if any.
     */
    option(...keys) {
      return this.options(...keys).map((values) => values.at(-1));
    }
    /**
     * Gets all values from all options.
     *
     * @example
     * ```typescript
     * // Assume args are '--a=1 --a=1 --b=2 --c=3'.
     * console.log(args.option('a'));
     * // Some { value: ['1', '1'] }
     *
     * console.log(args.option('b', 'c'));
     * // Some { value: ['2', '3'] }
     *
     * console.log(args.option('d'));
     * // None {}
     * ```
     *
     * @param keys The names of the options to check.
     * @returns The values from all the options concatenated, if any.
     */
    options(...keys) {
      const entries = [];
      for (const key of keys) {
        const values = this.results.options.get(key);
        if (values) entries.push(...values);
      }
      return entries.length ? Option.some(entries) : Option.none;
    }
    save() {
      return {
        used: new Set(this.state.used),
        position: this.state.position
      };
    }
    restore(state) {
      this.state = state;
    }
    reset() {
      this.restore({ used: /* @__PURE__ */ new Set(), position: 0 });
    }
  };
  __name(_ArgumentStream, "ArgumentStream");
  var ArgumentStream = _ArgumentStream;

  // src/lib/lexer/streams/parameters/BaseParameter.ts
  var _BaseParameter = class _BaseParameter {
    constructor(separators) {
      __publicField(this, "separators");
      this.separators = separators;
    }
    get leading() {
      return this.separators.join("");
    }
  };
  __name(_BaseParameter, "BaseParameter");
  var BaseParameter = _BaseParameter;

  // src/lib/lexer/streams/parameters/QuotedParameter.ts
  var _QuotedParameter = class _QuotedParameter extends BaseParameter {
    constructor(separators, part) {
      super(separators);
      __publicField(this, "value");
      __publicField(this, "open");
      __publicField(this, "close");
      this.value = part.value;
      this.open = part.open;
      this.close = part.close;
    }
    get raw() {
      return `${this.open}${this.value}${this.close}`;
    }
  };
  __name(_QuotedParameter, "QuotedParameter");
  var QuotedParameter = _QuotedParameter;

  // src/lib/lexer/streams/parameters/WordParameter.ts
  var _WordParameter = class _WordParameter extends BaseParameter {
    constructor(separators, part) {
      super(separators);
      __publicField(this, "value");
      this.value = part.value;
    }
    get raw() {
      return this.value;
    }
  };
  __name(_WordParameter, "WordParameter");
  var WordParameter = _WordParameter;

  // src/lib/lexer/streams/raw/TokenStream.ts
  var _TokenStream = class _TokenStream {
    constructor(lexer, input) {
      __publicField(this, "input");
      __publicField(this, "quotes");
      __publicField(this, "separator");
      __publicField(this, "position", 0);
      this.quotes = lexer.quotes;
      this.separator = lexer.separator;
      this.input = input;
    }
    get finished() {
      return this.position >= this.input.length;
    }
    *[Symbol.iterator]() {
      while (!this.finished) {
        yield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();
      }
    }
    getPossibleSeparator() {
      if (this.input.startsWith(this.separator, this.position)) {
        this.position += this.separator.length;
        return { type: 2 /* Separator */, value: this.separator };
      }
      return null;
    }
    getPossibleQuotedArgument() {
      for (const [open, close] of this.quotes) {
        if (!this.input.startsWith(open, this.position)) continue;
        const end = this.input.indexOf(close, this.position + open.length);
        if (end === -1) continue;
        const value = this.input.slice(this.position + open.length, end);
        this.position = end + close.length;
        return { type: 1 /* Quoted */, value, open, close };
      }
      return null;
    }
    getParameter() {
      const index = this.input.indexOf(this.separator, this.position);
      const value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);
      this.position += value.length;
      return { type: 0 /* Parameter */, value };
    }
  };
  __name(_TokenStream, "TokenStream");
  var TokenStream = _TokenStream;
  var TokenType = /* @__PURE__ */ ((TokenType2) => {
    TokenType2[TokenType2["Parameter"] = 0] = "Parameter";
    TokenType2[TokenType2["Quoted"] = 1] = "Quoted";
    TokenType2[TokenType2["Separator"] = 2] = "Separator";
    return TokenType2;
  })(TokenType || {});

  // src/lib/lexer/streams/ParameterStream.ts
  var _ParameterStream = class _ParameterStream {
    constructor(stream) {
      __publicField(this, "stream");
      __publicField(this, "separators", []);
      this.stream = stream;
    }
    *[Symbol.iterator]() {
      for (const part of this.stream) {
        if (part.type === 2 /* Separator */) {
          this.separators.push(part.value);
          continue;
        }
        yield part.type === 1 /* Quoted */ ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);
        this.separators = [];
      }
      return this.separators;
    }
  };
  __name(_ParameterStream, "ParameterStream");
  var ParameterStream = _ParameterStream;

  // src/lib/lexer/Lexer.ts
  var _Lexer = class _Lexer {
    constructor(options = {}) {
      __publicField(this, "quotes");
      __publicField(this, "separator");
      this.quotes = options.quotes ?? [];
      this.separator = options.separator ?? " ";
    }
    run(input) {
      return new ParameterStream(this.raw(input));
    }
    raw(input) {
      return new TokenStream(this, input);
    }
  };
  __name(_Lexer, "Lexer");
  var Lexer = _Lexer;

  // src/lib/parser/ParserResult.ts
  var _ParserResult = class _ParserResult {
    constructor(parser) {
      __publicField(this, "ordered", []);
      __publicField(this, "flags", /* @__PURE__ */ new Set());
      __publicField(this, "options", /* @__PURE__ */ new Map());
      __publicField(this, "strategy");
      this.strategy = parser.strategy;
    }
    parse(parameters) {
      for (const parameter of parameters) {
        this.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);
      }
      return this;
    }
    parsePossibleFlag(parameter) {
      return this.strategy.matchFlag(parameter.value).inspect((value) => this.flags.add(value)).isSome();
    }
    parsePossibleOptions(parameter) {
      return this.strategy.matchOption(parameter.value).inspect(([key, value]) => {
        const existing = this.options.get(key);
        if (existing) existing.push(value);
        else this.options.set(key, [value]);
      }).isSome();
    }
    parseOrdered(parameter) {
      this.ordered.push(parameter);
      return true;
    }
  };
  __name(_ParserResult, "ParserResult");
  var ParserResult = _ParserResult;

  // src/lib/parser/strategies/EmptyStrategy.ts
  var _EmptyStrategy = class _EmptyStrategy {
    matchFlag() {
      return Option.none;
    }
    matchOption() {
      return Option.none;
    }
  };
  __name(_EmptyStrategy, "EmptyStrategy");
  var EmptyStrategy = _EmptyStrategy;

  // src/lib/parser/Parser.ts
  var _Parser = class _Parser {
    constructor(strategy) {
      __publicField(this, "strategy");
      this.strategy = strategy ?? new EmptyStrategy();
    }
    setUnorderedStrategy(strategy) {
      this.strategy = strategy;
      return this;
    }
    run(input) {
      return new ParserResult(this).parse(input);
    }
  };
  __name(_Parser, "Parser");
  var Parser = _Parser;

  // src/lib/parser/strategies/PrefixedStrategy.ts
  var _PrefixedStrategy = class _PrefixedStrategy {
    constructor(prefixes, separators) {
      __publicField(this, "prefixes");
      __publicField(this, "separators");
      this.prefixes = prefixes;
      this.separators = separators;
    }
    matchFlag(input) {
      const prefix = this.prefixes.find((x) => input.startsWith(x));
      if (!prefix) return Option.none;
      if (this.separators.some((x) => input.includes(x, prefix.length))) return Option.none;
      return Option.some(input.slice(prefix.length));
    }
    matchOption(input) {
      const prefix = this.prefixes.find((x) => input.startsWith(x));
      if (!prefix) return Option.none;
      for (const separator of this.separators) {
        const index = input.indexOf(separator, prefix.length + 1);
        if (index === -1) continue;
        if (index + separator.length === input.length) return Option.none;
        const key = input.slice(prefix.length, index);
        const value = input.slice(index + separator.length);
        return Option.some([key, value]);
      }
      return Option.none;
    }
  };
  __name(_PrefixedStrategy, "PrefixedStrategy");
  var PrefixedStrategy = _PrefixedStrategy;

  // src/lib/util/util.ts
  function join(parameters) {
    if (parameters.length === 0) return "";
    if (parameters.length === 1) return parameters[0].value;
    let output = parameters[0].value;
    for (let i = 1; i < parameters.length; i++) {
      const parameter = parameters[i];
      output += parameter.leading + parameter.value;
    }
    return output;
  }
  __name(join, "join");
  function joinRaw(parameters) {
    if (parameters.length === 0) return "";
    if (parameters.length === 1) return parameters[0].raw;
    let output = parameters[0].raw;
    for (let i = 1; i < parameters.length; i++) {
      const parameter = parameters[i];
      output += parameter.leading + parameter.raw;
    }
    return output;
  }
  __name(joinRaw, "joinRaw");

  exports.ArgumentStream = ArgumentStream;
  exports.BaseParameter = BaseParameter;
  exports.EmptyStrategy = EmptyStrategy;
  exports.Lexer = Lexer;
  exports.ParameterStream = ParameterStream;
  exports.Parser = Parser;
  exports.ParserResult = ParserResult;
  exports.PrefixedStrategy = PrefixedStrategy;
  exports.QuotedParameter = QuotedParameter;
  exports.TokenStream = TokenStream;
  exports.TokenType = TokenType;
  exports.WordParameter = WordParameter;
  exports.join = join;
  exports.joinRaw = joinRaw;

  return exports;

})({});
//# sourceMappingURL=index.global.js.map
//# sourceMappingURL=index.global.js.map