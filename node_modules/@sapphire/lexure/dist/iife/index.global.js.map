{"version":3,"sources":["../../../result/src/lib/common/utils.ts","../../../result/src/lib/OptionError.ts","../../../result/src/lib/ResultError.ts","../../../result/src/lib/Result.ts","../../../result/src/lib/Option.ts","../../src/lib/ArgumentStream.ts","../../src/lib/lexer/streams/parameters/BaseParameter.ts","../../src/lib/lexer/streams/parameters/QuotedParameter.ts","../../src/lib/lexer/streams/parameters/WordParameter.ts","../../src/lib/lexer/streams/raw/TokenStream.ts","../../src/lib/lexer/streams/ParameterStream.ts","../../src/lib/lexer/Lexer.ts","../../src/lib/parser/ParserResult.ts","../../src/lib/parser/strategies/EmptyStrategy.ts","../../src/lib/parser/Parser.ts","../../src/lib/parser/strategies/PrefixedStrategy.ts","../../src/lib/util/util.ts"],"names":["__name","_a","__publicField","value","ValueProperty","_b","resolve","TokenType"],"mappings":"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","file":"index.global.js","sourcesContent":["export type Awaitable<T> = PromiseLike<T> | T;\n\nexport type If<Value extends boolean, TrueResult, FalseResult> = Value extends true\n\t? TrueResult\n\t: Value extends false\n\t\t? FalseResult\n\t\t: TrueResult | FalseResult;\n\nexport function isFunction<A extends readonly any[], R>(cb: (...args: A) => R): true;\nexport function isFunction(input: any): input is (...args: readonly any[]) => any;\nexport function isFunction(input: any) {\n\treturn typeof input === 'function';\n}\n\nexport function isPromise<T>(input: PromiseLike<T>): true;\nexport function isPromise(input: any): input is PromiseLike<any>;\nexport function isPromise(input: any) {\n\treturn typeof input === 'object' && input !== null && typeof input.then === 'function';\n}\n\nexport function returnThis<U>(this: U): U {\n\treturn this;\n}\n","export class OptionError extends Error {\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","export class ResultError<E> extends Error {\n\tpublic readonly value: E;\n\n\tpublic constructor(message: string, value: E) {\n\t\tsuper(message);\n\t\tthis.value = value;\n\t}\n\n\tpublic override get name(): string {\n\t\treturn this.constructor.name;\n\t}\n}\n","import { isFunction, returnThis, type Awaitable, type If } from './common/utils';\nimport { none, some, type None, type Option, type Some } from './Option';\nimport { ResultError } from './ResultError';\n\nconst ValueProperty = Symbol.for('@sapphire/result:Result.value');\nconst SuccessProperty = Symbol.for('@sapphire/result:Result.success');\n\n/**\n * A type used to express computations that can fail, it can be used for returning and propagating errors. This is a\n * type union with the variants `Ok(T)`, representing success and containing a value, and `Err(E)`, representing error\n * and containing an error value.\n *\n * @typeparam T The result's type.\n * @typeparam E The error's type.\n *\n * @see {@link https://doc.rust-lang.org/std/result/index.html}\n */\nexport class Result<T, E, const Success extends boolean = boolean> {\n\t/**\n\t * Branded value to ensure `Success` is typed correctly.\n\t * @internal\n\t */\n\tprotected declare __STATUS__: Success;\n\n\tprivate readonly [ValueProperty]: If<Success, T, E>;\n\tprivate readonly [SuccessProperty]: Success;\n\n\tprivate constructor(value: If<Success, T, E>, success: Success) {\n\t\tthis[ValueProperty] = value;\n\t\tthis[SuccessProperty] = success;\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Ok`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(-3);\n\t * assert.equal(x.isOk(), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isOk(), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok}\n\t */\n\tpublic isOk(): this is Ok<T, E> {\n\t\treturn this[SuccessProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Ok` and the value inside of it matches a predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.isOkAnd((value) => value > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = ok(0);\n\t * assert.equal(x.isOkAnd((value) => value > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isOkAnd((value) => value > 1), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_ok_and}\n\t */\n\tpublic isOkAnd<R extends T>(cb: (value: T) => value is R): this is Ok<R, E>;\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R;\n\tpublic isOkAnd<R extends boolean>(cb: (value: T) => R): this is Ok<T, E> & R {\n\t\treturn this.isOk() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Err`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(-3);\n\t * assert.equal(x.isErr(), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.isErr(), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err}\n\t */\n\tpublic isErr(): this is Err<E, T> {\n\t\treturn !this[SuccessProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the result is `Err` and the value inside of it matches a predicate.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err(new Error('Some error message'));\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err(new TypeError('Some error message'));\n\t * assert.equal(x.isErrAnd((error) => error instanceof TypeError), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.is_err_and}\n\t */\n\tpublic isErrAnd<R extends E>(cb: (error: E) => error is R): this is Err<R, T>;\n\tpublic isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R;\n\tpublic isErrAnd<R extends boolean>(cb: (error: E) => R): this is Err<E, T> & R {\n\t\treturn this.isErr() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Converts from `Result<T, E>` to `Option<T>`.\n\t *\n\t * Converts itself into an `Option<T>`, and discarding the error, if any.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.ok(), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.ok(), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.ok}\n\t */\n\tpublic ok(): If<Success, Some<T>, None> {\n\t\treturn this.match({ ok: (value) => some(value), err: () => none });\n\t}\n\n\t/**\n\t * Converts from `Result<T, E>` to `Option<E>`.\n\t *\n\t * Converts itself into an `Option<E>`, and discarding the successful value, if any.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.err(), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.err(), 'Some error message');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.err}\n\t */\n\tpublic err(): If<Success, None, Some<E>> {\n\t\treturn this.match({ ok: () => none, err: (error) => some(error) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<U, E>` by applying a function to a contained `Ok` value, leaving an `Err` value\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.map((value) => value * 2), ok(4));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.map((value) => value * 2), err('Some error message'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map}\n\t */\n\tpublic map<OutputValue>(cb: (value: T) => OutputValue): If<Success, Ok<OutputValue, E>, Err<E>> {\n\t\treturn this.match({ ok: (value) => ok(cb(value)), err: returnThis });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Ok` value, leaving an `Err` value\n\t * untouched.\n\t *\n\t * Unlike {@link map}, this method does not wrap the returned value inside `Ok`, but instead, it returns the\n\t * returned value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.mapInto((value) => ok(value * value)), ok(4));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(0);\n\t * assert.equal(\n\t *   x.mapInto((value) => (value === 0 ? err('zero is not divisible') : ok(1 / value))),\n\t *   err('zero is not divisible')\n\t * );\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.mapInto((value) => ok(4)), err('Some error message'));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapInto<OutputResult extends AnyResult>(cb: (value: T) => OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => cb(value), err: returnThis });\n\t}\n\n\t/**\n\t * Returns the provided default (if `Err`), or applies a function to the contained value (if `Ok`),\n\t *\n\t * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use `mapOrElse`, which is lazily evaluated.\n\t * @param defaultValue The default value to use.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok('hello');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Some error message');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or}\n\t */\n\tpublic mapOr<MappedOutputValue, DefaultOutputValue>(\n\t\tdefaultValue: DefaultOutputValue,\n\t\tcb: (value: T) => MappedOutputValue\n\t): If<Success, MappedOutputValue, DefaultOutputValue> {\n\t\treturn this.match({ ok: (value) => cb(value), err: () => defaultValue });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `U` by applying fallback function default to a contained `Err` value, or function `cb`\n\t * to a contained `Ok` value.\n\t *\n\t * This function can be used to unpack a successful result while handling an error.\n\t * @param op The predicate that is run on `Err`.\n\t * @param cb The predicate that is run on `Ok`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<string, string> = ok('hello');\n\t * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<string, string> = err('Some error message');\n\t * assert.equal(x.mapOrElse((error) => error.length, (value) => value.length), 18);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_or_else}\n\t */\n\tpublic mapOrElse<OutputValue, OutputError>(op: (error: E) => OutputError, cb: (value: T) => OutputValue): If<Success, OutputValue, OutputError> {\n\t\treturn this.match({ ok: (value) => cb(value), err: (error) => op(error) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value\n\t * untouched.\n\t *\n\t * This function can be used to pass through a successful result while handling an error.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = ok(2);\n\t * assert.equal(x.mapErr((error) => error.message), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErr((error) => error.message), err('Some error message'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.map_err}\n\t */\n\tpublic mapErr<OutputError>(cb: (error: E) => OutputError): If<Success, Ok<T>, Err<OutputError>> {\n\t\treturn this.match({ ok: returnThis, err: (error) => err(cb(error)) });\n\t}\n\n\t/**\n\t * Maps a `Result<T, E>` to `Result<T, F>` by applying a function to a contained `Err` value, leaving an `Ok` value\n\t * untouched.\n\t *\n\t * This function can be used to pass through a successful result while handling an error.\n\t *\n\t * Unlike {@link mapErr}, this method does not wrap the returned value inside `Err`, but instead, it returns the\n\t * returned value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = ok(2);\n\t * assert.equal(x.mapErrInto((error) => err(error.message)), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErrInto((error) => err(error.message)), err('Some error message'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, Error> = err(new Error('Some error message'));\n\t * assert.equal(x.mapErrInto((error) => ok(4)), ok(4));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapErrInto<OutputResult extends AnyResult>(cb: (error: E) => OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: (error) => cb(error) });\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Ok`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * ok(2).inspect(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * err('Some error message').inspect(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect}\n\t */\n\tpublic inspect(cb: (value: T) => unknown): this {\n\t\tif (this.isOk()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Ok`) and awaits it.\n\t * @param cb The predicate.\n\t * @seealso {@link inspect} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await ok(2).inspectAsync(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await err('Some error message').inspectAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isOk()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained error (if `Err`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectErrAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * ok(2).inspectErr(console.log);\n\t * // Doesn't log\n\t * ```\n\t * @example\n\t * ```typescript\n\t * err('Some error message').inspectErr(console.log);\n\t * // Logs: Some error message\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.inspect_err}\n\t */\n\tpublic inspectErr(cb: (error: E) => unknown): this {\n\t\tif (this.isErr()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained error (if `Err`) and awaits it.\n\t * @param cb The predicate.\n\t * @seealso {@link inspectErr} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await ok(2).inspectErrAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await err('Some error message').inspectErrAsync(console.log);\n\t * // Logs: Some error message\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectErrAsync(cb: (error: E) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isErr()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Ok`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(7);\n\t * for (const value of x.iter()) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Nothing!');\n\t * for (const value of x.iter()) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}\n\t */\n\tpublic *iter(): Generator<T> {\n\t\tif (this.isOk()) yield this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws a {@link ResultError} with the given message and the content of the `Err`.\n\t * @param message The message for the error.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.expect('Whoops!'), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.expect('Whoops!'), {\n\t *   name: 'ResultError',\n\t *   message: 'Whoops',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect}\n\t */\n\tpublic expect(message: string): If<Success, T, never> {\n\t\tif (this.isErr()) throw new ResultError(message, this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, T, never>;\n\t}\n\n\t/**\n\t * Returns the contained `Err` value.\n\t *\n\t * If the value is an `Ok`, it throws a {@link ResultError} with the given message and the content of the `Ok`.\n\t * @param message The message for the error.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.throws(() => x.expectErr('Whoops!'), {\n\t *   name: 'ResultError',\n\t *   message: 'Whoops',\n\t *   value: 2\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.equal(x.expectErr('Whoops!'), 'Emergency failure');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.expect_err}\n\t */\n\tpublic expectErr(message: string): If<Success, never, E> {\n\t\tif (this.isOk()) throw new ResultError(message, this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, never, E>;\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws a {@link ResultError} with the message, and the content of the `Err`.\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.unwrap(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.unwrap(), {\n\t *   name: 'ResultError',\n\t *   message: 'Unwrap failed',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap}\n\t */\n\tpublic unwrap(): If<Success, T, never> {\n\t\tif (this.isErr()) throw new ResultError('Unwrap failed', this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, T, never>;\n\t}\n\n\t/**\n\t * Returns the contained `Err` value.\n\t *\n\t * If the value is an `Ok`, it throws a {@link ResultError} with the message, and the content of the `Ok`.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.throws(() => x.unwrapErr(), {\n\t *   name: 'ResultError',\n\t *   message: 'Unwrap failed',\n\t *   value: 2\n\t * });\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.equal(x.unwrapErr(), 'Emergency failure');\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_err}\n\t */\n\tpublic unwrapErr(): If<Success, never, E> {\n\t\tif (this.isOk()) throw new ResultError('Unwrap failed', this[ValueProperty]);\n\t\treturn this[ValueProperty] as If<Success, never, E>;\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value or the provided default.\n\t *\n\t * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link unwrapOrElse}, which is lazily evaluated.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @param defaultValue The default value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(9);\n\t * assert.equal(x.unwrapOr(2), 9);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Error');\n\t * assert.equal(x.unwrapOr(2), 2);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or}\n\t */\n\tpublic unwrapOr<OutputValue>(defaultValue: OutputValue): If<Success, T, OutputValue> {\n\t\treturn this.match({ ok: (value) => value, err: () => defaultValue });\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value or computes it from a closure.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapErr}\n\t * @seealso {@link unwrapRaw}\n\t *\n\t * @param op The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const count = (x: string) => x.length;\n\t *\n\t * assert.equal(ok(2).unwrapOrElse(count), 2);\n\t * assert.equal(err('hello').unwrapOrElse(count), 5);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.unwrap_or_else}\n\t */\n\tpublic unwrapOrElse<OutputValue>(op: (error: E) => OutputValue): If<Success, T, OutputValue> {\n\t\treturn this.match({ ok: (value) => value, err: (error) => op(error) });\n\t}\n\n\t/**\n\t * Returns the contained `Ok` value.\n\t *\n\t * If the value is an `Err`, it throws the contained error.\n\t * @seealso {@link unwrap}\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t * @seealso {@link unwrapErr}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(2);\n\t * assert.equal(x.unwrapRaw(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Emergency failure');\n\t * assert.throws(() => x.unwrapRaw(), {\n\t *   name: 'Error',\n\t *   message: 'Unwrap failed',\n\t *   value: 'Emergency failure'\n\t * });\n\t * ```\n\t */\n\tpublic unwrapRaw(): If<Success, T, never> {\n\t\t// eslint-disable-next-line @typescript-eslint/no-throw-literal\n\t\tif (this.isErr()) throw this[ValueProperty];\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty] as T;\n\t}\n\n\t/**\n\t * Returns `result` if the result is `Ok`, otherwise returns the `Err` value of itself.\n\t * @param result The result to check.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<string, string> = err('Late error');\n\t * assert.equal(x.and(y), err('Late error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<string, string> = err('Late error');\n\t * assert.equal(x.and(y), err('Early error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<string, string> = ok('Hello');\n\t * assert.equal(x.and(y), ok('Hello'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and}\n\t */\n\tpublic and<OutputResult extends AnyResult>(result: OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: () => result, err: returnThis });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function fractionOf4(value: number) {\n\t *   return value === 0 ? err('overflowed') : ok(4 / value);\n\t * }\n\t *\n\t * assert.equal(ok(2).andThen(fractionOf4), ok(4));\n\t * assert.equal(ok(0).andThen(fractionOf4), err('overflowed'));\n\t * assert.equal(err('not a number').andThen(fractionOf4), err('not a number'));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}\n\t */\n\tpublic andThen<OutputResult extends AnyResult>(cb: (value: T) => OutputResult): If<Success, OutputResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => cb(value), err: returnThis });\n\t}\n\n\t/**\n\t * Return `result` if the result is `Err`, otherwise returns the `Ok` value of self.\n\t *\n\t * Arguments passed to or are eagerly evaluated; if you are passing the result of a function call, it is recommended\n\t * to use {@link orElse}, which is lazily evaluated.\n\t * @param result The result to check.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<number, string> = err('Late error');\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<number, string> = ok(2);\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Early error');\n\t * const y: Result<number, string> = err('Late error');\n\t * assert.equal(x.or(y), err('Late error'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * const y: Result<number, string> = ok(100);\n\t * assert.equal(x.or(y), ok(2));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or}\n\t */\n\tpublic or<OutputResult extends AnyResult>(result: OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: () => result });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Err`, otherwise returns the `Ok` value of self.\n\t *\n\t * This function can be used for control flow based on result values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const square = (x: number): Result<number, string> => ok(x * x);\n\t * const wrapErr = (x: number): Result<number, string> => err(x);\n\t *\n\t * assert.equal(ok(2).orElse(square).orElse(square), ok(2));\n\t * assert.equal(ok(2).orElse(wrapErr).orElse(square), ok(2));\n\t * assert.equal(err(3).orElse(square).orElse(wrapErr), ok(9));\n\t * assert.equal(err(3).orElse(wrapErr).orElse(wrapErr), err(3));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.or_else}\n\t */\n\tpublic orElse<OutputResult extends AnyResult>(cb: (error: E) => OutputResult): If<Success, Ok<T>, OutputResult> {\n\t\treturn this.match({ ok: returnThis, err: (error) => cb(error) });\n\t}\n\n\t/**\n\t * Returns `true` if the result is an `Ok` and the given value strict equals it.\n\t * @param value The value to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.contains(2), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(3);\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains}\n\t */\n\tpublic contains<const Value extends T>(this: Ok<T>, value: Value): this is Ok<Value>;\n\tpublic contains(this: Err<E>, value: T): false;\n\tpublic contains(value: T): boolean {\n\t\treturn this.isOkAnd((inner) => inner === value);\n\t}\n\n\t/**\n\t * Returns `true` if the result is an `Err` and the given error strict equals it.\n\t * @param error The error to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = ok(2);\n\t * assert.equal(x.containsErr('Some error message'), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some error message');\n\t * assert.equal(x.containsErr('Some error message'), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<number, string> = err('Some other error message');\n\t * assert.equal(x.containsErr('Some error message'), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.contains_err}\n\t */\n\tpublic containsErr(this: Ok<T>, error: E): false;\n\tpublic containsErr<const Value extends E>(this: Err<E>, error: Value): this is Err<Value>;\n\tpublic containsErr(error: E): boolean {\n\t\treturn this.isErrAnd((inner) => inner === error);\n\t}\n\n\t/**\n\t * Transposes a `Result` of an `Option` into an `Option` of a `Result`.\n\t *\n\t * `ok(none)` will be mapped to `none`. `ok(some(v))` and `err(e)` will be mapped to `some(ok(v))` and `some(err(e))`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<Option<number>, Error> = ok(some(5));\n\t * const y: Option<Result<number, Error>> = some(ok(5));\n\t * assert.equal(x.transpose(), y);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.transpose}\n\t */\n\tpublic transpose<InnerValue>(this: Result<Option<InnerValue>, E, Success>): If<Success, Option<Ok<InnerValue>>, Some<Err<E>>> {\n\t\treturn this.match({\n\t\t\tok: (value) => value.map((value) => ok(value)),\n\t\t\terr() {\n\t\t\t\treturn some(this);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = ok(ok('Hello'));\n\t * assert.equal(x.flatten(), ok('Hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = ok(err(6));\n\t * assert.equal(x.flatten(), err(6));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Result<Result<string, number>, number> = err(6);\n\t * assert.equal(x.flatten(), err(6));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}\n\t */\n\tpublic flatten<InnerResult extends AnyResult>(this: Result<InnerResult, E, Success>): If<Success, InnerResult, Err<E>> {\n\t\treturn this.match({ ok: (value) => value, err: returnThis });\n\t}\n\n\t/**\n\t * Returns the `Ok` value if self is `Ok`, and the `Err` value if self is `Err`.\n\t *\n\t * @example\n\t * ```typescript\n\t * let x: Result<number, number> = ok(3);\n\t * assert.equal(x.intoOkOrErr(), 3);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * let x: Result<number, number> = err(4);\n\t * assert.equal(x.intoOkOrErr(), 4);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.into_ok_or_err}\n\t */\n\tpublic intoOkOrErr(): If<Success, T, E> {\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns a `Promise` object with the awaited value (if `Ok`) or the awaited error (if `Err`).\n\t *\n\t * @example\n\t * ```typescript\n\t * let x = ok(Promise.resolve(3));\n\t * assert.equal(await x.intoPromise(), ok(3));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic intoPromise(): If<Success, Promise<Ok<Awaited<T>>>, Promise<Err<Awaited<E>>>> {\n\t\treturn this.match({\n\t\t\tok: async (value) => ok(await value), // NOSONAR\n\t\t\terr: async (error) => err(await error) // NOSONAR\n\t\t});\n\t}\n\n\t/**\n\t * Checks whether or not `other` equals with self.\n\t * @param other The other result to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}\n\t */\n\tpublic eq<OtherValue extends T, OtherError extends E, OtherSuccess extends boolean>(\n\t\tother: Result<OtherValue, OtherError, OtherSuccess>\n\t): this is Result<OtherValue, OtherError, OtherSuccess> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isOk() === other.isOk() && this[ValueProperty] === other[ValueProperty];\n\t}\n\n\t/**\n\t * Checks whether or not `other` doesn't equal with self.\n\t * @param other The other result to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}\n\t */\n\tpublic ne(other: Result<T, E>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\t/**\n\t * Runs `ok` function if self is `Ok`, otherwise runs `err` function.\n\t * @param branches The branches to match.\n\t *\n\t * @example\n\t * ```typescript\n\t * const result = ok(4).match({\n\t *   ok: (v) => v,\n\t *   err: () => 0\n\t * });\n\t * assert.equal(result, 4);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const result = err('Hello').match({\n\t *   ok: (v) => v,\n\t *   err: () => 0\n\t * });\n\t * assert.equal(result, 0);\n\t * ```\n\t */\n\tpublic match<OkValue, ErrValue>(branches: {\n\t\tok(this: Ok<T>, value: T): OkValue;\n\t\terr(this: Err<E>, error: E): ErrValue;\n\t}): If<Success, OkValue, ErrValue> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isOk() ? branches.ok.call(this, this[ValueProperty]) : branches.err.call(this, this[ValueProperty] as E);\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Ok`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = ok(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = err('Nothing!');\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link IResult.iter}\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.iter}\n\t */\n\tpublic [Symbol.iterator](): Generator<T> {\n\t\treturn this.iter();\n\t}\n\n\tpublic get [Symbol.toStringTag](): If<Success, 'Ok', 'Err'> {\n\t\treturn this.match({ ok: () => 'Ok', err: () => 'Err' });\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static ok<T = undefined, E = any>(this: void, value?: T): Ok<T, E>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static ok<T, E = any>(this: void, value: T): Ok<T, E> {\n\t\treturn new Result<T, E, true>(value, true);\n\t}\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static err<E = undefined, T = any>(this: void, value?: E): Err<E, T>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static err<E, T = any>(this: void, value: E): Err<E, T> {\n\t\treturn new Result<T, E, false>(value, false);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object. This override\n\t * exists to interoperate with other versions of this class, such as the one coming from another version of this\n\t * library or from a different build.\n\t *\n\t * @param instance The instance to check.\n\t * @returns Whether or not the instance is a `Result`.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * ok(2) instanceof Result; // true\n\t * ```\n\t */\n\tpublic static [Symbol.hasInstance](instance: unknown): boolean {\n\t\treturn typeof instance === 'object' && instance !== null && ValueProperty in instance && SuccessProperty in instance;\n\t}\n\n\t/**\n\t * @deprecated Use {@link Result.isResult} instead.\n\t *\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * Result.isResult(ok(2)); // true\n\t * ```\n\t */\n\tpublic static is(instance: unknown): instance is AnyResult {\n\t\treturn Result[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Result`, or if it is a `Result`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Result` or a `Result`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Result } from '@sapphire/result';\n\t * const { ok } = require('@sapphire/result');\n\t *\n\t * Result.isResult(ok(2)); // true\n\t * ```\n\t */\n\tpublic static isResult(instance: unknown): instance is AnyResult {\n\t\treturn Result[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static from<T, E = unknown>(this: void, op: ResultResolvable<T, E> | (() => ResultResolvable<T, E>)): Result<T, E> {\n\t\ttry {\n\t\t\treturn resolve(isFunction(op) ? op() : op);\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\tpublic static async fromAsync<T, E = unknown>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\top: Awaitable<ResultResolvable<T, E>> | (() => Awaitable<ResultResolvable<T, E>>)\n\t): Promise<Result<T, E>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch (error) {\n\t\t\treturn err(error as E);\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\tpublic static all<const Entries extends readonly AnyResult[]>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\tresults: Entries\n\t): Result<UnwrapOkArray<Entries>, UnwrapErrArray<Entries>[number]> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isErr()) return result;\n\n\t\t\tvalues.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn ok(values as UnwrapOkArray<Entries>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Ok}, or an {@link Err} that is the combination of all collected error values.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\tpublic static any<const Entries extends readonly AnyResult[]>(\n\t\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\t\tthis: void,\n\t\tresults: Entries\n\t): Result<UnwrapOk<Entries[number]>, UnwrapErrArray<Entries>> {\n\t\tconst errors: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isOk()) return result;\n\n\t\t\terrors.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn err(errors as UnwrapErrArray<Entries>);\n\t}\n}\n\nexport namespace Result {\n\texport type Ok<T, E = any> = Result<T, E, true>;\n\texport type Err<E, T = any> = Result<T, E, false>;\n\texport type Any = Result<any, any>;\n\texport type Resolvable<T, E = any, Success extends boolean = boolean> = T | Result<T, E, Success>;\n\texport type UnwrapOk<T extends AnyResult> = T extends Ok<infer S> ? S : never;\n\texport type UnwrapErr<T extends AnyResult> = T extends Err<infer S> ? S : never;\n\n\texport type UnwrapOkArray<T extends readonly AnyResult[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapOk<T[P]>;\n\t};\n\texport type UnwrapErrArray<T extends readonly AnyResult[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapErr<T[P]>;\n\t};\n}\n\nexport const { ok, err } = Result;\n\nfunction resolve<T, E>(value: Result.Resolvable<T, E>): Result<T, E> {\n\treturn Result.isResult(value) ? value : ok(value);\n}\n\nexport type ResultResolvable<T, E = any, Success extends boolean = boolean> = Result.Resolvable<T, E, Success>;\n\nexport type Ok<T, E = any> = Result.Ok<T, E>;\nexport type Err<E, T = any> = Result.Err<E, T>;\nexport type AnyResult = Result.Any;\n\nexport type UnwrapOk<T extends AnyResult> = Result.UnwrapOk<T>;\nexport type UnwrapErr<T extends AnyResult> = Result.UnwrapErr<T>;\n\nexport type UnwrapOkArray<T extends readonly AnyResult[] | []> = Result.UnwrapOkArray<T>;\nexport type UnwrapErrArray<T extends readonly AnyResult[] | []> = Result.UnwrapErrArray<T>;\n","import { isFunction, returnThis, type Awaitable, type If } from './common/utils';\nimport { OptionError } from './OptionError';\nimport { err, ok, Result, type Err, type Ok } from './Result';\n\nconst ValueProperty = Symbol.for('@sapphire/result:Option.value');\nconst ExistsProperty = Symbol.for('@sapphire/result:Option.exists');\n\nexport class Option<T, Exists extends boolean = boolean> {\n\t/**\n\t * Branded value to ensure `Success` is typed correctly.\n\t * @internal\n\t */\n\tprotected declare __STATUS__: Exists;\n\n\tprivate readonly [ValueProperty]: If<Exists, T, null>;\n\tprivate readonly [ExistsProperty]: Exists;\n\n\tprivate constructor(value: If<Exists, T, null>, exists: Exists) {\n\t\tthis[ValueProperty] = value;\n\t\tthis[ExistsProperty] = exists;\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isSome(), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isSome(), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some}\n\t */\n\tpublic isSome(): this is Some<T> {\n\t\treturn this[ExistsProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` and the value inside of it matches a predicate.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isSomeAnd((x) => x > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(0);\n\t * assert.equal(x.isSomeAnd((x) => x > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isSomeAnd((x) => x > 1), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_some_and}\n\t */\n\tpublic isSomeAnd<R extends T>(cb: (value: T) => value is R): this is Some<R>;\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R;\n\tpublic isSomeAnd<R extends boolean>(cb: (value: T) => R): this is Some<R> & R {\n\t\treturn this.isSome() && cb(this[ValueProperty]);\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `None` value.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isNone(), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isNone(), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none}\n\t */\n\tpublic isNone(): this is None {\n\t\treturn !this[ExistsProperty];\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `None` value or the value inside of it matches a predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.isNoneOr((x) => x > 1), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(0);\n\t * assert.equal(x.isNoneOr((x) => x > 1), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.isNoneOr((x) => x > 1), true);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.is_none_or}\n\t */\n\tpublic isNoneOr<R extends T>(cb: (value: T) => value is R): this is None | Some<R>;\n\tpublic isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true>;\n\tpublic isNoneOr<R extends boolean>(cb: (value: T) => R): If<Exists, R, true> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => true });\n\t}\n\n\t/**\n\t * Returns the contained `Some` value.\n\t * @param message The message for the error.\n\t * If the value is an `Err`, it throws an {@link OptionError} with the given message.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some(2);\n\t * assert.equal(x.expect('Whoops!'), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.throws(() => x.expect('Whoops!'), {\n\t *   name: 'OptionError',\n\t *   message: 'Whoops'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.expect}\n\t */\n\tpublic expect(message: string): If<Exists, T, never> {\n\t\tif (this.isNone()) throw new OptionError(message);\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Some` value.\n\t *\n\t * If the value is an `Err`, it throws an {@link OptionError} with the message.\n\t * @seealso {@link unwrapOr}\n\t * @seealso {@link unwrapOrElse}\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some(2);\n\t * assert.equal(x.unwrap(), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.throws(() => x.unwrap(), {\n\t *   name: 'OptionError',\n\t *   message: 'Unwrap failed'\n\t * });\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap}\n\t */\n\tpublic unwrap(): If<Exists, T, never> {\n\t\tif (this.isNone()) throw new OptionError('Unwrap failed');\n\t\t// @ts-expect-error Complex types\n\t\treturn this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns the contained `Some` value or a provided default.\n\t *\n\t * Arguments passed to `unwrapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link unwrapOrElse}, which is lazily evaluated.\n\t *\n\t * @example\n\t * ```typescript\n\t * assert.equal(some(2).unwrapOr(0), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * assert.equal(none.unwrapOr(0), 0);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or}\n\t */\n\tpublic unwrapOr<OutputValue>(defaultValue: OutputValue): If<Exists, T, OutputValue> {\n\t\treturn this.match({ some: (value) => value, none: () => defaultValue });\n\t}\n\n\t/**\n\t * Returns the contained Some value or computes it from a closure.\n\t *\n\t * @example\n\t * ```typescript\n\t * assert.equal(some(2).unwrapOrElse(() => 0), 2);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * assert.equal(none.unwrapOrElse(() => 0), 0);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else}\n\t */\n\tpublic unwrapOrElse<OutputValue>(cb: () => OutputValue): If<Exists, T, OutputValue> {\n\t\treturn this.match({ some: (value) => value, none: cb });\n\t}\n\n\t/**\n\t * Maps an `Option<T>` to `Option<U>` by applying a function to a contained value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const maybeSomeString = some('Hello, world!');\n\t * const maybeSomeLength = maybeSomeString.map((value) => value.length);\n\t *\n\t * assert.equal(maybeSomeLength, some(13));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map}\n\t */\n\tpublic map<U>(cb: (value: T) => U): If<Exists, Some<U>, None> {\n\t\treturn this.match({ some: (value) => some(cb(value)), none: returnThis });\n\t}\n\n\t/**\n\t * Maps a `Some<T>` to the returned `Option<U>` by applying a function to a contained value, leaving `None`\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = some('Hello, world!');\n\t * const result = input.mapInto((value) => some(value.length));\n\t *\n\t * assert.equal(result, some(13));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = none;\n\t * const result = input.mapInto((value) => some(value.length));\n\t *\n\t * assert.equal(result, none);\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapInto<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: (value) => cb(value), none: returnThis });\n\t}\n\n\t/**\n\t * Returns the provided default result (if none), or applies a function to the contained value (if any).\n\t *\n\t * Arguments passed to `mapOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link mapOrElse}, which is lazily evaluated.\n\t * @param defaultValue The default value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.mapOr(42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.mapOr(42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or}\n\t */\n\tpublic mapOr<MappedOutputValue, DefaultOutputValue>(\n\t\tdefaultValue: DefaultOutputValue,\n\t\tcb: (value: T) => MappedOutputValue\n\t): If<Exists, MappedOutputValue, DefaultOutputValue> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => defaultValue });\n\t}\n\n\t/**\n\t * Computes a default function result (if none), or applies a different function to the contained value (if any).\n\t * @param defaultValue The default value.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 5);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.mapOrElse(() => 42, (value) => value.length), 42);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.map_or_else}\n\t */\n\tpublic mapOrElse<OutputValue, OutputNone>(defaultValue: () => OutputNone, cb: (value: T) => OutputValue): If<Exists, OutputValue, OutputNone> {\n\t\treturn this.match({ some: (value) => cb(value), none: () => defaultValue() });\n\t}\n\n\t/**\n\t * Maps a `None` to the returned `Option<U>` by applying a function to a contained value, leaving `Some<T>`\n\t * untouched.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = some('Hello, world!');\n\t * const result = input.mapNoneInto(() => some(13));\n\t *\n\t * assert.equal(result, some('Hello, world!'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const input: Option<string> = none;\n\t * const result = input.mapNoneInto(() => some(13));\n\t *\n\t * assert.equal(result, some(13));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic mapNoneInto<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: cb });\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Some`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspectAsync} for the awaitable version.\n\t *\n\t * @example\n\t * ```typescript\n\t * some(2).inspect(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * none.inspect(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.inspect}\n\t */\n\tpublic inspect(cb: (value: T) => void): this {\n\t\tif (this.isSome()) cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Calls the provided closure with a reference to the contained value (if `Some`).\n\t * @param cb The predicate.\n\t * @seealso {@link inspect} for the sync version.\n\t *\n\t * @example\n\t * ```typescript\n\t * await some(2).inspectAsync(console.log);\n\t * // Logs: 2\n\t * ```\n\t * @example\n\t * ```typescript\n\t * await none.inspectAsync(console.log);\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic async inspectAsync(cb: (value: T) => Awaitable<unknown>): Promise<this> {\n\t\tif (this.isSome()) await cb(this[ValueProperty]);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err)`.\n\t *\n\t * Arguments passed to `okOr` are eagerly evaluated; if you are passing the result of a function call, it is\n\t * recommended to use {@link okOrElse}, which is lazily evaluated.\n\t * @param err The error to be used.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.okOr(0), ok('hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.okOr(0), err(0));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or}\n\t */\n\tpublic okOr<ErrorValue>(error: ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>> {\n\t\treturn this.match({ some: (value) => ok(value), none: () => err(error) });\n\t}\n\n\t/**\n\t * Transforms the `Option<T>` into a `Result<T, E>`, mapping `Some(v)` to `Ok(v)` and `None` to `Err(err())`.\n\t * @param cb The error to be used.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = some('hello');\n\t * assert.equal(x.okOrElse(() => 0), ok('hello'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<string> = none;\n\t * assert.equal(x.okOrElse(() => 0), err(0));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.ok_or_else}\n\t */\n\tpublic okOrElse<ErrorValue>(cb: () => ErrorValue): If<Exists, Ok<T>, Err<ErrorValue>> {\n\t\treturn this.match({ some: (value) => ok(value), none: () => err(cb()) });\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Some`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = none;\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link Option.iter}\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}\n\t */\n\tpublic *iter(): Generator<T> {\n\t\tif (this.isSome()) yield this[ValueProperty];\n\t}\n\n\t/**\n\t * Returns `None` if the option is `None`, otherwise returns `option`.\n\t * @param option The option.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<string> = none;\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<string> = some('foo');\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<string> = some('foo');\n\t * assert.equal(x.and(y), some('foo'));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<string> = none;\n\t * assert.equal(x.and(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.and}\n\t */\n\tpublic and<OutputOption extends AnyOption>(option: OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: () => option, none: returnThis });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function fractionOf4(value: number) {\n\t *   return value === 0 ? none : some(4 / value);\n\t * }\n\t *\n\t * assert.equal(some(2).andThen(fractionOf4), some(4));\n\t * assert.equal(some(0).andThen(fractionOf4), none);\n\t * assert.equal(none.andThen(fractionOf4), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.and_then}\n\t */\n\tpublic andThen<OutputOption extends AnyOption>(cb: (value: T) => OutputOption): If<Exists, OutputOption, None> {\n\t\treturn this.match({ some: (value) => cb(value), none: returnThis });\n\t}\n\n\t/**\n\t * Returns the option if it contains a value, otherwise returns `option`.\n\t * @param option The option.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = none;\n\t * assert.equal(x.or(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = some(100);\n\t * assert.equal(x.or(y), some(100));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = some(100);\n\t * assert.equal(x.or(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = none;\n\t * assert.equal(x.or(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or}\n\t */\n\tpublic or<OutputOption extends AnyOption>(option: OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: () => option });\n\t}\n\n\t/**\n\t * Calls `cb` if the result is `Ok`, otherwise returns the `Err` value of self.\n\t *\n\t * This function can be used for control flow based on `Result` values.\n\t * @param cb The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * const nobody = (): Option<string> => none;\n\t * const vikings = (): Option<string> => some('vikings');\n\t *\n\t * assert.equal(some('barbarians').orElse(vikings), some('barbarians'));\n\t * assert.equal(none.orElse(vikings), some('vikings'));\n\t * assert.equal(none.orElse(nobody), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.or_else}\n\t */\n\tpublic orElse<OutputOption extends AnyOption>(cb: () => OutputOption): If<Exists, Some<T>, OutputOption> {\n\t\treturn this.match({ some: returnThis, none: () => cb() });\n\t}\n\n\t/**\n\t * Returns `Some` if exactly one of self or `option` is `Some`, otherwise returns `None`.\n\t * @param option The option to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = none;\n\t * assert.equal(x.xor(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = some(2);\n\t * assert.equal(x.xor(y), some(2));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * const y: Option<number> = some(2);\n\t * assert.equal(x.xor(y), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * const y: Option<number> = none;\n\t * assert.equal(x.xor(y), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.xor}\n\t */\n\tpublic xor<OtherValue, OtherExists extends boolean>(\n\t\toption: Option<OtherValue, OtherExists>\n\t): If<Exists, If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>> {\n\t\treturn this.match<If<OtherExists, None, Some<T>>, Option<OtherValue, OtherExists>>({\n\t\t\tsome() {\n\t\t\t\treturn (option.isNone() ? this : none) as If<OtherExists, None, Some<T>>;\n\t\t\t},\n\t\t\tnone: () => option\n\t\t});\n\t}\n\n\t/**\n\t * Returns None if the option is None, otherwise calls `predicate` with the wrapped value and returns:\n\t *\n\t * - `Some(t)` if `predicate` returns `true` (where t is the wrapped value), and\n\t * - `None` if `predicate` returns `false`.\n\t * @param predicate The predicate.\n\t *\n\t * @example\n\t * ```typescript\n\t * function isEven(value: number) {\n\t *   return n % 2 === 0;\n\t * }\n\t *\n\t * assert.equal(none.filter(isEven), none);\n\t * assert.equal(some(3).filter(isEven), none);\n\t * assert.equal(some(4).filter(isEven), some(4));\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.filter}\n\t */\n\tpublic filter<R extends T>(predicate: (value: T) => value is R): Option<R>;\n\tpublic filter(predicate: (value: T) => boolean): Option<T>;\n\tpublic filter(predicate: (value: T) => boolean): Option<T> {\n\t\treturn this.isSomeAnd(predicate) ? this : none;\n\t}\n\n\t/**\n\t * Returns `true` if the option is a `Some` value containing the given value.\n\t * @param value The value to compare.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(2);\n\t * assert.equal(x.contains(2), true);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = some(3);\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<number> = none;\n\t * assert.equal(x.contains(2), false);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.contains}\n\t */\n\tpublic contains<const Value extends T>(value: If<Exists, Value, unknown>): this is Some<Value> {\n\t\treturn this.isSomeAnd((inner) => inner === value);\n\t}\n\n\t/**\n\t * Zips self with another `Option`.\n\t *\n\t * If self is `Some(s)` and `other` is `Some(o)`, this method returns `Some([s, o])`. Otherwise, `None` is returned.\n\t * @param other The option to zip self with.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(1);\n\t * const y = some('hi');\n\t * const z = none;\n\t *\n\t * assert.equal(x.zip(y), some([1, 'hi']));\n\t * assert.equal(x.zip(z), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip}\n\t */\n\tpublic zip<OtherValue, OtherExists extends boolean>(\n\t\tother: Option<OtherValue, OtherExists>\n\t): Option<[T, OtherValue], If<Exists, OtherExists, false>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() && other.isSome() ? some([this[ValueProperty], other[ValueProperty]] as [T, OtherValue]) : none;\n\t}\n\n\t/**\n\t * Zips self and another `Option` with function `f`.\n\t *\n\t * If self is `Some(s)` and other is `Some(o)`, this method returns `Some(f(s, o))`. Otherwise, `None` is returned.\n\t * @param other The option to zip self with.\n\t * @param f The function that computes the returned value.\n\t *\n\t * @example\n\t * ```typescript\n\t * class Point {\n\t *   public readonly x: number;\n\t *   public readonly y: number;\n\t *\n\t *   public constructor(x: number, y: number) {\n\t *     this.x = x;\n\t *     this.y = y;\n\t *   }\n\t * }\n\t *\n\t * const x = some(17.5);\n\t * const y = some(42.7);\n\t *\n\t * assert.equal(x.zipWith(y, (s, o) => new Point(s, o)), some(new Point(17.5, 42.7)));\n\t * assert.equal(x.zipWith(none, (s, o) => new Point(s, o)), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.zip_with}\n\t */\n\tpublic zipWith<OtherValue, OtherExists extends boolean, ReturnValue>(\n\t\tother: Option<OtherValue, OtherExists>,\n\t\tf: (value0: T, value1: OtherValue) => ReturnValue\n\t): Option<ReturnValue, If<Exists, OtherExists, false>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() && other.isSome() ? some(f(this[ValueProperty], other[ValueProperty])) : none;\n\t}\n\n\t/**\n\t * Unzips an option containing a tuple of two options.\n\t *\n\t * If self is `Some([a, b])` this method returns `[Some(a), Some(b)]`. Otherwise, `[None, None]` is returned.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<[number, string]> = some([1, 'hi']);\n\t * assert.equal(x.unzip(), [some(1), some('hi')]);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<[number, string]> = none;\n\t * assert.equal(x.unzip(), [none, none]);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.unzip}\n\t */\n\tpublic unzip<Value0, Value1, Exists extends boolean>(\n\t\tthis: Option<readonly [Value0, Value1], Exists>\n\t): [Option<Value0, Exists>, Option<Value1, Exists>] {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({\n\t\t\tsome: ([value0, value1]) => [some(value0), some(value1)],\n\t\t\tnone: () => [none, none]\n\t\t});\n\t}\n\n\t/**\n\t * Transposes an `Option` of a `Result` into a `Result` of an `Option`.\n\t *\n\t * `none` will be mapped to `ok(none)`. `some(ok(v))` and `some(err(e))` will be mapped to `ok(some(v))` and `err(e)`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<Result<number, Error>> = some(ok(5));\n\t * const y: Result<Option<number>, Error> = ok(some(5));\n\t * assert.equal(x.transpose(), y);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.transpose}\n\t */\n\tpublic transpose<ResultValue, ResultError, ResultSuccess extends boolean, Exists extends boolean>(\n\t\tthis: Option<Result<ResultValue, ResultError, ResultSuccess>, Exists>\n\t): If<Exists, Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>> {\n\t\treturn this.match<Result<Some<ResultValue>, ResultError, ResultSuccess>, Ok<None>>({\n\t\t\t// @ts-expect-error Complex types\n\t\t\tsome: (result) => result.map(some),\n\t\t\tnone: () => ok(none)\n\t\t});\n\t}\n\n\t/**\n\t * Converts from `Result<Result<T, E>, E>` to `Result<T, E>`.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = some(some(6));\n\t * assert.equal(x.flatten(), some(6));\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = some(none);\n\t * assert.equal(x.flatten(), none);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x: Option<Option<number>> = none;\n\t * assert.equal(x.flatten(), none);\n\t * ```\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/result/enum.Result.html#method.flatten}\n\t */\n\tpublic flatten<InnerOption extends AnyOption, Exists extends boolean>(this: Option<InnerOption, Exists>): If<Exists, InnerOption, None> {\n\t\treturn this.match({ some: (inner) => inner, none: returnThis });\n\t}\n\n\t/**\n\t * Returns a `Promise` object with the awaited value (if `Some`).\n\t *\n\t * @example\n\t * ```typescript\n\t * let x = some(Promise.resolve(3));\n\t * assert.equal(await x.intoPromise(), some(3));\n\t * ```\n\t *\n\t * @note This is an extension not supported in Rust\n\t */\n\tpublic intoPromise(): Promise<Option<Awaited<T>, Exists>> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.match({\n\t\t\tsome: async (value) => some(await value), // NOSONAR\n\t\t\tnone: () => Promise.resolve(none)\n\t\t});\n\t}\n\n\t/**\n\t * Checks whether or not `other` equals with self.\n\t * @param other The other option to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#tymethod.eq}\n\t */\n\tpublic eq<OtherValue extends T, OtherExists extends boolean>(other: Option<OtherValue, OtherExists>): this is Option<OtherValue, OtherExists> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() === other.isSome() && this[ValueProperty] === other[ValueProperty];\n\t}\n\n\t/**\n\t * Checks whether or not `other` doesn't equal with self.\n\t * @param other The other option to compare.\n\t *\n\t * @see {@link https://doc.rust-lang.org/std/cmp/trait.PartialEq.html#method.ne}\n\t */\n\tpublic ne(other: Option<T, boolean>): boolean {\n\t\treturn !this.eq(other);\n\t}\n\n\t/**\n\t * Runs `ok` function if self is `Ok`, otherwise runs `err` function.\n\t * @param branches The branches to match.\n\t *\n\t * @example\n\t * ```typescript\n\t * const option = some(4).match({\n\t *   some: (v) => v,\n\t *   none: () => 0\n\t * });\n\t * assert.equal(option, 4);\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const option = none.match({\n\t *   some: (v) => v,\n\t *   none: () => 0\n\t * });\n\t * assert.equal(option, 0);\n\t * ```\n\t */\n\tpublic match<SomeValue, NoneValue>(branches: {\n\t\tsome(this: Some<T>, value: T): SomeValue;\n\t\tnone(this: None): NoneValue;\n\t}): If<Exists, SomeValue, NoneValue> {\n\t\t// @ts-expect-error Complex types\n\t\treturn this.isSome() ? branches.some.call(this, this[ValueProperty]) : branches.none.call(this);\n\t}\n\n\t/**\n\t * Returns an iterator over the possibly contained value.\n\t *\n\t * The iterator yields one value if the result is `Some`, otherwise none.\n\t *\n\t * @example\n\t * ```typescript\n\t * const x = some(7);\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Logs 7\n\t * ```\n\t * @example\n\t * ```typescript\n\t * const x = none;\n\t * for (const value of x) {\n\t *   console.log(value);\n\t * }\n\t * // Doesn't log\n\t * ```\n\t *\n\t * @see {@link IOption.iter}\n\t * @see {@link https://doc.rust-lang.org/std/option/enum.Option.html#method.iter}\n\t */\n\tpublic [Symbol.iterator](): Generator<T> {\n\t\treturn this.iter();\n\t}\n\n\tpublic get [Symbol.toStringTag](): If<Exists, 'Some', 'None'> {\n\t\treturn this.match({ some: () => 'Some', none: () => 'None' });\n\t}\n\n\tpublic static readonly none = new Option<any, false>(null, false);\n\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static some<T = undefined>(this: void, value?: T): Some<T>;\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static some<T>(this: void, value: T): Some<T> {\n\t\treturn new Option<T, true>(value, true);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object. This override\n\t * exists to interoperate with other versions of this class, such as the one coming from another version of this\n\t * library or from a different build.\n\t *\n\t * @param instance The instance to check.\n\t * @returns Whether or not the instance is a `Option`.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * some(2) instanceof Option; // true\n\t * ```\n\t */\n\tpublic static [Symbol.hasInstance](instance: unknown): boolean {\n\t\treturn typeof instance === 'object' && instance !== null && ValueProperty in instance && ExistsProperty in instance;\n\t}\n\n\t/**\n\t * @deprecated Use {@link Option.isOption} instead.\n\t *\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * Option.isOption(some(2)); // true\n\t * ```\n\t */\n\tpublic static is(instance: unknown): instance is AnyOption {\n\t\treturn Option[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Checks if the `instance` object is an instance of `Option`, or if it is a `Option`-like object.\n\t *\n\t * @param instance The instance to check.\n\t * @returns true if the instance is a `Option` or a `Option`-like object, false otherwise.\n\t *\n\t * @example\n\t * ```typescript\n\t * import { Option } from '@sapphire/result';\n\t * const { some } = require('@sapphire/result');\n\t *\n\t * Option.isOption(some(2)); // true\n\t * ```\n\t */\n\tpublic static isOption(instance: unknown): instance is AnyOption {\n\t\treturn Option[Symbol.hasInstance](instance);\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static from<T>(this: void, op: OptionResolvable<T> | (() => OptionResolvable<T>)): Option<T> {\n\t\ttry {\n\t\t\treturn resolve(isFunction(op) ? op() : op);\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates a {@link Result} out of a promise or async callback.\n\t *\n\t * @typeparam T The result's type.\n\t * @typeparam E The error's type.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static async fromAsync<T>(this: void, op: Awaitable<OptionResolvable<T>> | (() => Awaitable<OptionResolvable<T>>)): Promise<Option<T>> {\n\t\ttry {\n\t\t\treturn resolve(await (isFunction(op) ? op() : op));\n\t\t} catch {\n\t\t\treturn none;\n\t\t}\n\t}\n\n\t/**\n\t * Creates an {@link Ok} that is the combination of all collected {@link Ok} values as an array, or the first\n\t * {@link Err} encountered.\n\t *\n\t * @param results An array of {@link Result}s.\n\t * @returns A new {@link Result}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static all<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSomeArray<Entries>> {\n\t\tconst values: unknown[] = [];\n\t\tfor (const result of results) {\n\t\t\tif (result.isNone()) return result;\n\n\t\t\tvalues.push(result[ValueProperty]);\n\t\t}\n\n\t\treturn some(values as UnwrapSomeArray<Entries>);\n\t}\n\n\t/**\n\t * Returns the first encountered {@link Some}, or a {@link None} if none was found.\n\t *\n\t * @param options An array of {@link Option}s.\n\t * @returns A new {@link Option}.\n\t */\n\t// eslint-disable-next-line @typescript-eslint/no-invalid-void-type\n\tpublic static any<const Entries extends readonly AnyOption[]>(this: void, results: Entries): Option<UnwrapSome<Entries[number]>> {\n\t\tfor (const result of results) {\n\t\t\tif (result.isSome()) return result;\n\t\t}\n\n\t\treturn none;\n\t}\n}\n\nexport namespace Option {\n\texport type Some<T> = Option<T, true>;\n\texport type None<T = any> = Option<T, false>;\n\texport type Any = Option<any>;\n\texport type Resolvable<T, Exists extends boolean = boolean> = T | null | undefined | Option<T, Exists>;\n\texport type UnwrapSome<T extends AnyOption> = T extends Some<infer S> ? S : never;\n\texport type UnwrapSomeArray<T extends readonly AnyOption[] | []> = {\n\t\t-readonly [P in keyof T]: UnwrapSome<T[P]>;\n\t};\n}\n\nexport const { some, none } = Option;\n\nfunction resolve<T>(value: Option.Resolvable<T>): Option<T> {\n\tif (value === null || value === undefined) return none;\n\tif (Option.isOption(value)) return value;\n\treturn some(value);\n}\n\nexport type OptionResolvable<T, Exists extends boolean = boolean> = Option.Resolvable<T, Exists>;\n\nexport type Some<T> = Option.Some<T>;\nexport type None<T = any> = Option.None<T>;\nexport type AnyOption = Option.Any;\n\nexport type UnwrapSome<T extends AnyOption> = Option.UnwrapSome<T>;\nexport type UnwrapSomeArray<T extends readonly AnyOption[] | []> = Option.UnwrapSomeArray<T>;\n","import { Option, Result } from '@sapphire/result';\nimport type { Parameter } from './lexer/streams/ParameterStream';\nimport type { ParserResult } from './parser/ParserResult';\n\nexport class ArgumentStream {\n\tpublic readonly results: ParserResult;\n\tpublic state: ArgumentStream.State;\n\n\tpublic constructor(results: ParserResult) {\n\t\tthis.results = results;\n\t\tthis.state = { used: new Set(), position: 0 };\n\t}\n\n\t/**\n\t * Whether or not all ordered parameters were used.\n\t */\n\tpublic get finished() {\n\t\treturn this.used === this.length;\n\t}\n\n\t/**\n\t * The amount of ordered parameters.\n\t */\n\tpublic get length() {\n\t\treturn this.results.ordered.length;\n\t}\n\n\t/**\n\t * The remaining amount of ordered parameters.\n\t */\n\tpublic get remaining() {\n\t\treturn this.length - this.used;\n\t}\n\n\t/**\n\t * The amount of ordered parameters that have been used.\n\t */\n\tpublic get used() {\n\t\treturn this.state.used.size;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '1' }\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '2' }\n\t *\n\t * console.log(args.single());\n\t * // Ok { value: '3' }\n\t *\n\t * console.log(args.single());\n\t * // None\n\t * ```\n\t *\n\t * @returns The value, if any.\n\t */\n\tpublic single(): Option<string> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tthis.state.used.add(this.state.position);\n\t\treturn Option.some(this.results.ordered[this.state.position++].value);\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link singleMapAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number) ? Option.none : Option.some(number);\n\t * };\n\t *\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 1 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 2 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // Some { value: 3 }\n\t *\n\t * console.log(args.singleMap(parse));\n\t * // None\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic singleMap<T>(predicate: (value: string) => Option<T>, useAnyways = false): Option<T> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isSome() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This is an asynchronous variant of {@link singleMap}.\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic async singleMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, useAnyways = false): Promise<Option<T>> {\n\t\tif (this.finished) return Option.none;\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = await predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isSome() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Finds and retrieves the next unused parameter and transforms it.\n\t *\n\t * @note This is a variant of {@link findMap} that returns the errors on failure.\n\t * @note This does not support asynchronous results, refer to {@link singleParseAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number)\n\t *     ? Result.err(`Could not parse ${value} to a number`)\n\t *     : Result.ok(number);\n\t * };\n\t *\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 1 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 2 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Ok { value: 3 }\n\t *\n\t * console.log(args.singleParse(parse));\n\t * // Err { error: null }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate The predicate that determines the parameter's transformed value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the transformation failed. Defaults to `false`.\n\t * @returns The transformed value, if any.\n\t */\n\tpublic singleParse<T, E>(predicate: (value: string) => Result<T, E>, useAnyways = false): Result<T, E | null> {\n\t\tif (this.finished) return Result.err(null);\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isOk() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Retrieves the value of the next unused ordered token, but only if it could be transformed.\n\t *\n\t * @note This is an asynchronous variant of {@link singleParse}.\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate The predicate that determines the parameter's mapped value, or nothing if failed.\n\t * @param useAnyways Whether to consider the parameter used even if the mapping failed. Defaults to `false`.\n\t * @returns The mapped value, if any.\n\t */\n\tpublic async singleParseAsync<T, E>(predicate: (value: string) => Promise<Result<T, E>>, useAnyways = false): Promise<Result<T, E | null>> {\n\t\tif (this.finished) return Result.err(null);\n\n\t\twhile (this.state.used.has(this.state.position)) {\n\t\t\t++this.state.position;\n\t\t}\n\n\t\tconst result = await predicate(this.results.ordered[this.state.position].value);\n\t\tif (result.isOk() || useAnyways) {\n\t\t\tthis.state.used.add(this.state.position);\n\t\t\t++this.state.position;\n\t\t}\n\n\t\treturn result;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link findAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`\n\t * with that element value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic find(predicate: (value: string) => boolean, from = this.state.position): Option<string> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn Option.some(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `true`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This is an asynchronous variant of {@link find}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `true`. If such an element is found, find immediately returns a `Option.some`\n\t * with that element value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findAsync(predicate: (value: string) => Promise<boolean>, from = this.state.position): Promise<Option<string>> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (await predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn Option.some(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This does not support asynchronous results, refer to {@link findMapAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned\n\t * value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic findMap<T>(predicate: (value: string) => Option<T>, from = this.state.position): Option<T> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tif (result.isSome()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Returns the value of the first element in the array within `Option.some` where `predicate` returns `Some`, and\n\t * `Option.none` otherwise.\n\t *\n\t * @note This is an asynchronous variant of {@link findMap}.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Suppose args are from 'ba aa cc'.\n\t *\n\t * console.log(args.find((value) => value.startsWith('a')));\n\t * // Some { value: 'aa' }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @param predicate find calls `predicate` once for each unused ordered parameter, in ascending order, until it\n\t * finds one where `predicate` returns `Some`. If such an element is found, find immediately returns the returned\n\t * value. Otherwise, find returns `Option.none`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, from = this.state.position): Promise<Option<T>> {\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tif (result.isSome()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result;\n\t\t\t}\n\t\t}\n\n\t\treturn Option.none;\n\t}\n\n\t/**\n\t * Finds and retrieves the first unused parameter that could be transformed.\n\t *\n\t * @note This is a variant of {@link findMap} that returns the errors on failure.\n\t * @note This does not support asynchronous results, refer to {@link findParseAsync}.\n\t *\n\t * @example\n\t * ```typescript\n\t * const parse = (value) => {\n\t *   const number = Number(value);\n\t *   return Number.isNaN(number)\n\t *     ? Result.err(`Could not parse ${value} to a number`)\n\t *     : Result.ok(number);\n\t * };\n\t *\n\t * // Suppose args are from 'ba 1 cc'.\n\t *\n\t * console.log(args.findParse(parse));\n\t * // Ok { value: 1 }\n\t *\n\t * console.log(args.findParse(parse));\n\t * // Err {\n\t * //   error: [\n\t * //     'Could not parse ba to a number',\n\t * //     'Could not parse cc to a number'\n\t * //   ]\n\t * // }\n\t * ```\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until\n\t * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the\n\t * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic findParse<T, E>(predicate: (value: string) => Result<T, E>, from = this.state.position): Result<T, E[]> {\n\t\tconst errors: E[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tif (result.isOk()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result as Result.Ok<T>;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn Result.err(errors);\n\t}\n\n\t/**\n\t * Finds and retrieves the first unused parameter that could be transformed.\n\t *\n\t * @note This is a variant of {@link findMapAsync} that returns the errors on failure.\n\t * @note This is an asynchronous variant of {@link findParse}.\n\t *\n\t * @typeparam T The output type.\n\t * @typeparam E The error type.\n\t * @param predicate `findParse` calls `predicate` once for each unused ordered parameter, in ascending order, until\n\t * it finds one where `predicate` returns `Ok`. If such an element is found, `findParse` immediately returns the\n\t * returned value. Otherwise, `findParse` returns `Result.Err` with all the returned errors.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The found parameter's value.\n\t */\n\tpublic async findParseAsync<T, E>(predicate: (value: string) => Promise<Result<T, E>>, from = this.state.position): Promise<Result<T, E[]>> {\n\t\tconst errors: E[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tif (result.isOk()) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\treturn result as Result.Ok<T>;\n\t\t\t}\n\n\t\t\terrors.push(result.unwrapErr());\n\t\t}\n\n\t\treturn Result.err(errors);\n\t}\n\n\t/**\n\t * Retrieves multiple unused parameters.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(join(args.many().unwrap()));\n\t * // '1 2 3'\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '1 2 3':\n\t *\n\t * console.log(join(args.many(2).unwrap()));\n\t * // '1 2'\n\t * ```\n\t *\n\t * @param limit The maximum amount of parameters to retrieve, defaults to `Infinity`.\n\t * @param from The position where to start looking for unused parameters, defaults to current position.\n\t * @returns The unused parameters within the range.\n\t */\n\tpublic many(limit = Infinity, from = this.state.position): Option<Parameter[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: Parameter[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\t// If the current parameter was already used, skip:\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\t// Mark current parameter as used, and push it to the resulting array:\n\t\t\tthis.state.used.add(i);\n\t\t\tparameters.push(this.results.ordered[i]);\n\n\t\t\t// If the parameters reached the limit, break the loop:\n\t\t\tif (parameters.length >= limit) break;\n\t\t}\n\n\t\treturn parameters.length ? Option.some(parameters) : Option.none;\n\t}\n\n\tpublic filter(predicate: (value: string) => boolean, from = this.state.position): Option<string[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: string[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic async filterAsync(predicate: (value: string) => Promise<boolean>, from = this.state.position): Promise<Option<string[]>> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: string[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tif (await predicate(parameter)) {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(parameter);\n\t\t\t}\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic filterMap<T>(predicate: (value: string) => Option<T>, from = this.state.position): Option<T[]> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: T[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = predicate(parameter);\n\t\t\tresult.inspect((value) => {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(value);\n\t\t\t});\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\tpublic async filterMapAsync<T>(predicate: (value: string) => Promise<Option<T>>, from = this.state.position): Promise<Option<T[]>> {\n\t\tif (this.finished) return Option.none;\n\n\t\tconst parameters: T[] = [];\n\t\tfor (let i = from; i < this.length; ++i) {\n\t\t\tif (this.state.used.has(i)) continue;\n\n\t\t\tconst parameter = this.results.ordered[i].value;\n\t\t\tconst result = await predicate(parameter);\n\t\t\tresult.inspect((value) => {\n\t\t\t\tthis.state.used.add(i);\n\t\t\t\tparameters.push(value);\n\t\t\t});\n\t\t}\n\n\t\treturn Option.some(parameters);\n\t}\n\n\t/**\n\t * Checks whether any of the flags were given.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--f --g':\n\t *\n\t * console.log(args.flag('f'));\n\t * // true\n\t *\n\t * console.log(args.flag('g', 'h'));\n\t * // true\n\t *\n\t * console.log(args.flag('h'));\n\t * // false\n\t * ```\n\t *\n\t * @param keys The names of the flags to check.\n\t * @returns Whether or not any of the flags were given.\n\t */\n\tpublic flag(...keys: readonly string[]): boolean {\n\t\treturn keys.some((key) => this.results.flags.has(key));\n\t}\n\n\t/**\n\t * Gets the last value of any option. When there are multiple names, the last value of the last found name is given.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--a=1 --b=2 --c=3'.\n\t * console.log(args.option('a'));\n\t * // Some { value: '1' }\n\t *\n\t * console.log(args.option('b', 'c'));\n\t * // Some { value: '3' }\n\t *\n\t * console.log(args.option('d'));\n\t * // None {}\n\t * ```\n\t *\n\t * @param keys The names of the options to check.\n\t * @returns The last value of the option, if any.\n\t */\n\tpublic option(...keys: readonly string[]): Option<string> {\n\t\treturn this.options(...keys).map((values) => values.at(-1)!);\n\t}\n\n\t/**\n\t * Gets all values from all options.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Assume args are '--a=1 --a=1 --b=2 --c=3'.\n\t * console.log(args.option('a'));\n\t * // Some { value: ['1', '1'] }\n\t *\n\t * console.log(args.option('b', 'c'));\n\t * // Some { value: ['2', '3'] }\n\t *\n\t * console.log(args.option('d'));\n\t * // None {}\n\t * ```\n\t *\n\t * @param keys The names of the options to check.\n\t * @returns The values from all the options concatenated, if any.\n\t */\n\tpublic options(...keys: readonly string[]): Option<readonly string[]> {\n\t\tconst entries: string[] = [];\n\t\tfor (const key of keys) {\n\t\t\tconst values = this.results.options.get(key);\n\t\t\tif (values) entries.push(...values);\n\t\t}\n\n\t\treturn entries.length ? Option.some(entries) : Option.none;\n\t}\n\n\tpublic save(): ArgumentStream.State {\n\t\treturn {\n\t\t\tused: new Set(this.state.used),\n\t\t\tposition: this.state.position\n\t\t};\n\t}\n\n\tpublic restore(state: ArgumentStream.State) {\n\t\tthis.state = state;\n\t}\n\n\tpublic reset() {\n\t\tthis.restore({ used: new Set(), position: 0 });\n\t}\n}\n\nexport namespace ArgumentStream {\n\texport interface State {\n\t\tused: Set<number>;\n\t\tposition: number;\n\t}\n}\n","export abstract class BaseParameter {\n\tpublic readonly separators: readonly string[];\n\n\tpublic constructor(separators: readonly string[]) {\n\t\tthis.separators = separators;\n\t}\n\n\tpublic get leading(): string {\n\t\treturn this.separators.join('');\n\t}\n\n\tpublic abstract get raw(): string;\n}\n","import type { QuotedToken } from '../raw/TokenStream';\nimport { BaseParameter } from './BaseParameter';\n\nexport class QuotedParameter extends BaseParameter {\n\tpublic readonly value: string;\n\tpublic readonly open: string;\n\tpublic readonly close: string;\n\n\tpublic constructor(separators: readonly string[], part: Omit<QuotedToken, 'type'>) {\n\t\tsuper(separators);\n\t\tthis.value = part.value;\n\t\tthis.open = part.open;\n\t\tthis.close = part.close;\n\t}\n\n\tpublic get raw() {\n\t\treturn `${this.open}${this.value}${this.close}`;\n\t}\n}\n","import type { WordToken } from '../raw/TokenStream';\nimport { BaseParameter } from './BaseParameter';\n\nexport class WordParameter extends BaseParameter {\n\tpublic readonly value: string;\n\n\tpublic constructor(separators: readonly string[], part: Omit<WordToken, 'type'>) {\n\t\tsuper(separators);\n\t\tthis.value = part.value;\n\t}\n\n\tpublic get raw() {\n\t\treturn this.value;\n\t}\n}\n","import type { Lexer } from '../../Lexer';\n\nexport class TokenStream implements Iterable<Token> {\n\tprivate readonly input: string;\n\tprivate readonly quotes: readonly [string, string][];\n\tprivate readonly separator: string;\n\tprivate position = 0;\n\n\tpublic constructor(lexer: Lexer, input: string) {\n\t\tthis.quotes = lexer.quotes;\n\t\tthis.separator = lexer.separator;\n\t\tthis.input = input;\n\t}\n\n\tpublic get finished() {\n\t\treturn this.position >= this.input.length;\n\t}\n\n\tpublic *[Symbol.iterator](): Iterator<Token> {\n\t\twhile (!this.finished) {\n\t\t\tyield this.getPossibleSeparator() ?? this.getPossibleQuotedArgument() ?? this.getParameter();\n\t\t}\n\t}\n\n\tprivate getPossibleSeparator(): SeparatorToken | null {\n\t\tif (this.input.startsWith(this.separator, this.position)) {\n\t\t\tthis.position += this.separator.length;\n\t\t\treturn { type: TokenType.Separator, value: this.separator };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getPossibleQuotedArgument(): QuotedToken | null {\n\t\tfor (const [open, close] of this.quotes) {\n\t\t\tif (!this.input.startsWith(open, this.position)) continue;\n\n\t\t\tconst end = this.input.indexOf(close, this.position + open.length);\n\t\t\tif (end === -1) continue;\n\n\t\t\tconst value = this.input.slice(this.position + open.length, end);\n\t\t\tthis.position = end + close.length;\n\n\t\t\treturn { type: TokenType.Quoted, value, open, close };\n\t\t}\n\n\t\treturn null;\n\t}\n\n\tprivate getParameter(): WordToken {\n\t\tconst index = this.input.indexOf(this.separator, this.position);\n\t\tconst value = index === -1 ? this.input.slice(this.position) : this.input.slice(this.position, index);\n\t\tthis.position += value.length;\n\t\treturn { type: TokenType.Parameter, value };\n\t}\n}\n\nexport enum TokenType {\n\tParameter,\n\tQuoted,\n\tSeparator\n}\n\nexport type Token = WordToken | QuotedToken | SeparatorToken;\n\nexport interface WordToken {\n\treadonly type: TokenType.Parameter;\n\treadonly value: string;\n}\n\nexport interface QuotedToken {\n\treadonly type: TokenType.Quoted;\n\treadonly value: string;\n\treadonly open: string;\n\treadonly close: string;\n}\n\nexport interface SeparatorToken {\n\treadonly type: TokenType.Separator;\n\treadonly value: string;\n}\n","import { QuotedParameter } from './parameters/QuotedParameter';\nimport { WordParameter } from './parameters/WordParameter';\nimport { TokenType, type Token } from './raw/TokenStream';\n\nexport class ParameterStream {\n\tprivate readonly stream: Iterable<Token>;\n\tprivate separators: string[] = [];\n\n\tpublic constructor(stream: Iterable<Token>) {\n\t\tthis.stream = stream;\n\t}\n\n\tpublic *[Symbol.iterator](): Iterator<Parameter, string[]> {\n\t\tfor (const part of this.stream) {\n\t\t\tif (part.type === TokenType.Separator) {\n\t\t\t\tthis.separators.push(part.value);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tyield part.type === TokenType.Quoted ? new QuotedParameter(this.separators, part) : new WordParameter(this.separators, part);\n\t\t\tthis.separators = [];\n\t\t}\n\n\t\treturn this.separators;\n\t}\n}\n\nexport type Parameter = QuotedParameter | WordParameter;\n","import { ParameterStream } from './streams/ParameterStream';\nimport { TokenStream } from './streams/raw/TokenStream';\n\nexport class Lexer {\n\tpublic readonly quotes: readonly [open: string, close: string][];\n\tpublic readonly separator: string;\n\n\tpublic constructor(options: Lexer.Options = {}) {\n\t\tthis.quotes = options.quotes ?? [];\n\t\tthis.separator = options.separator ?? ' ';\n\t}\n\n\tpublic run(input: string) {\n\t\treturn new ParameterStream(this.raw(input));\n\t}\n\n\tpublic raw(input: string) {\n\t\treturn new TokenStream(this, input);\n\t}\n}\n\nexport namespace Lexer {\n\texport interface Options {\n\t\tseparator?: string;\n\t\tquotes?: readonly [open: string, close: string][];\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\nimport type { Parser } from './Parser';\nimport type { IUnorderedStrategy } from './strategies/IUnorderedStrategy';\n\nexport class ParserResult {\n\tpublic readonly ordered: Parameter[] = [];\n\tpublic readonly flags = new Set<string>();\n\tpublic readonly options = new Map<string, string[]>();\n\tprivate readonly strategy: IUnorderedStrategy;\n\n\tpublic constructor(parser: Parser) {\n\t\tthis.strategy = parser.strategy;\n\t}\n\n\tpublic parse(parameters: Iterable<Parameter>) {\n\t\tfor (const parameter of parameters) {\n\t\t\tthis.parsePossibleFlag(parameter) || this.parsePossibleOptions(parameter) || this.parseOrdered(parameter);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprivate parsePossibleFlag(parameter: Parameter): boolean {\n\t\treturn this.strategy\n\t\t\t.matchFlag(parameter.value)\n\t\t\t.inspect((value) => this.flags.add(value))\n\t\t\t.isSome();\n\t}\n\n\tprivate parsePossibleOptions(parameter: Parameter): boolean {\n\t\treturn this.strategy\n\t\t\t.matchOption(parameter.value)\n\t\t\t.inspect(([key, value]) => {\n\t\t\t\tconst existing = this.options.get(key);\n\t\t\t\tif (existing) existing.push(value);\n\t\t\t\telse this.options.set(key, [value]);\n\t\t\t})\n\t\t\t.isSome();\n\t}\n\n\tprivate parseOrdered(parameter: Parameter): boolean {\n\t\tthis.ordered.push(parameter);\n\t\treturn true;\n\t}\n}\n","import { Option } from '@sapphire/result';\nimport type { IUnorderedStrategy } from './IUnorderedStrategy';\n\nexport class EmptyStrategy implements IUnorderedStrategy {\n\tpublic matchFlag(): Option<string> {\n\t\treturn Option.none;\n\t}\n\n\tpublic matchOption(): Option<readonly [key: string, value: string]> {\n\t\treturn Option.none;\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\nimport type { IUnorderedStrategy } from './strategies/IUnorderedStrategy';\nimport { ParserResult } from './ParserResult';\nimport { EmptyStrategy } from './strategies/EmptyStrategy';\n\nexport class Parser {\n\tpublic strategy: IUnorderedStrategy;\n\n\tpublic constructor(strategy?: IUnorderedStrategy) {\n\t\tthis.strategy = strategy ?? new EmptyStrategy();\n\t}\n\n\tpublic setUnorderedStrategy(strategy: IUnorderedStrategy) {\n\t\tthis.strategy = strategy;\n\t\treturn this;\n\t}\n\n\tpublic run(input: Iterable<Parameter>): ParserResult {\n\t\treturn new ParserResult(this).parse(input);\n\t}\n}\n","import { Option } from '@sapphire/result';\nimport type { IUnorderedStrategy } from './IUnorderedStrategy';\n\nexport class PrefixedStrategy implements IUnorderedStrategy {\n\tpublic readonly prefixes: readonly string[];\n\tpublic readonly separators: readonly string[];\n\n\tpublic constructor(prefixes: readonly string[], separators: readonly string[]) {\n\t\tthis.prefixes = prefixes;\n\t\tthis.separators = separators;\n\t}\n\n\tpublic matchFlag(input: string): Option<string> {\n\t\tconst prefix = this.prefixes.find((x) => input.startsWith(x));\n\n\t\t// If the prefix is missing, return None:\n\t\tif (!prefix) return Option.none;\n\n\t\t// If the separator is present, return None:\n\t\tif (this.separators.some((x) => input.includes(x, prefix.length))) return Option.none;\n\n\t\treturn Option.some(input.slice(prefix.length));\n\t}\n\n\tpublic matchOption(input: string): Option<readonly [key: string, value: string]> {\n\t\tconst prefix = this.prefixes.find((x) => input.startsWith(x));\n\n\t\t// If the prefix is missing, return None:\n\t\tif (!prefix) return Option.none;\n\n\t\tfor (const separator of this.separators) {\n\t\t\tconst index = input.indexOf(separator, prefix.length + 1);\n\n\t\t\t// If the separator is missing, skip:\n\t\t\tif (index === -1) continue;\n\n\t\t\t// If the separator is present, but has no value, return None:\n\t\t\tif (index + separator.length === input.length) return Option.none;\n\n\t\t\tconst key = input.slice(prefix.length, index);\n\t\t\tconst value = input.slice(index + separator.length);\n\t\t\treturn Option.some([key, value] as const);\n\t\t}\n\n\t\treturn Option.none;\n\t}\n}\n","import type { Parameter } from '../lexer/streams/ParameterStream';\n\n/**\n * Joins the parameters by their `leading` value, using the `value` property.\n * @seealso {@link joinRaw} for the version using `raw` instead of `value`.\n * @param parameters The parameters to join.\n * @returns The result of joining the parameters.\n */\nexport function join(parameters: readonly Parameter[]) {\n\tif (parameters.length === 0) return '';\n\tif (parameters.length === 1) return parameters[0].value;\n\n\tlet output = parameters[0].value;\n\tfor (let i = 1; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\t\toutput += parameter.leading + parameter.value;\n\t}\n\n\treturn output;\n}\n\n/**\n * Joins the parameters by their `leading` value, using the `raw` property.\n * @seealso {@link join} for the version using `value` instead of `raw`.\n * @param parameters The parameters to join.\n * @returns The result of joining the parameters.\n */\nexport function joinRaw(parameters: readonly Parameter[]) {\n\tif (parameters.length === 0) return '';\n\tif (parameters.length === 1) return parameters[0].raw;\n\n\tlet output = parameters[0].raw;\n\tfor (let i = 1; i < parameters.length; i++) {\n\t\tconst parameter = parameters[i];\n\t\toutput += parameter.leading + parameter.raw;\n\t}\n\n\treturn output;\n}\n"]}