import { __name } from '../../../chunk-PAWJFY3S.mjs';
import { container } from '@sapphire/pieces';
import { retry } from '@sapphire/utilities';
import { ApplicationCommandType } from 'discord.js';
import { RegisterBehavior, InternalRegistryAPIType } from '../../types/Enums.mjs';
import { Events } from '../../types/Events.mjs';
import { ApplicationCommandRegistry } from './ApplicationCommandRegistry.mjs';
import { getNeededRegistryParameters } from './getNeededParameters.mjs';
import { emitPerRegistryError, emitBulkOverwriteError } from './registriesErrors.mjs';
import { bulkOverwriteDebug, bulkOverwriteWarn, bulkOverwriteInfo } from './registriesLog.mjs';

var defaultBehaviorWhenNotIdentical = RegisterBehavior.Overwrite;
var defaultGuildIds = void 0;
var bulkOVerwriteRetries = 1;
var registries = /* @__PURE__ */ new Map();
var allGuildIdsToFetchCommandsFor = /* @__PURE__ */ new Set();
function acquire(commandName) {
  const existing = registries.get(commandName);
  if (existing) {
    return existing;
  }
  const newRegistry = new ApplicationCommandRegistry(commandName);
  registries.set(commandName, newRegistry);
  return newRegistry;
}
__name(acquire, "acquire");
function setDefaultBehaviorWhenNotIdentical(behavior) {
  defaultBehaviorWhenNotIdentical = behavior ?? RegisterBehavior.Overwrite;
}
__name(setDefaultBehaviorWhenNotIdentical, "setDefaultBehaviorWhenNotIdentical");
function getDefaultBehaviorWhenNotIdentical() {
  return defaultBehaviorWhenNotIdentical;
}
__name(getDefaultBehaviorWhenNotIdentical, "getDefaultBehaviorWhenNotIdentical");
function setDefaultGuildIds(guildIds) {
  defaultGuildIds = guildIds ?? void 0;
}
__name(setDefaultGuildIds, "setDefaultGuildIds");
function getDefaultGuildIds() {
  return defaultGuildIds;
}
__name(getDefaultGuildIds, "getDefaultGuildIds");
function setBulkOverwriteRetries(newAmountOfRetries) {
  newAmountOfRetries ??= 1;
  if (newAmountOfRetries <= 0) throw new RangeError("The amount of retries must be greater than 0");
  bulkOVerwriteRetries = newAmountOfRetries;
}
__name(setBulkOverwriteRetries, "setBulkOverwriteRetries");
function getBulkOverwriteRetries() {
  return bulkOVerwriteRetries;
}
__name(getBulkOverwriteRetries, "getBulkOverwriteRetries");
async function handleRegistryAPICalls() {
  container.client.emit(Events.ApplicationCommandRegistriesInitialising);
  const commandStore = container.stores.get("commands");
  for (const command of commandStore.values()) {
    if (command.registerApplicationCommands) {
      try {
        await command.registerApplicationCommands(command.applicationCommandRegistry);
      } catch (error) {
        emitPerRegistryError(error, command);
      }
    }
  }
  if (getDefaultBehaviorWhenNotIdentical() === RegisterBehavior.BulkOverwrite) {
    await handleBulkOverwrite(commandStore, container.client.application.commands);
    return;
  }
  const params = await getNeededRegistryParameters(allGuildIdsToFetchCommandsFor);
  await handleAppendOrUpdate(commandStore, params);
}
__name(handleRegistryAPICalls, "handleRegistryAPICalls");
async function handleBulkOverwrite(commandStore, applicationCommands) {
  const now = Date.now();
  const foundGlobalCommands = [];
  const foundGuildCommands = {};
  for (const command of commandStore.values()) {
    const registry = command.applicationCommandRegistry;
    for (const call of registry["apiCalls"]) {
      if (call.registerOptions.guildIds?.length) {
        for (const guildId of call.registerOptions.guildIds) {
          foundGuildCommands[guildId] ??= [];
          foundGuildCommands[guildId].push({ piece: command, data: call.builtData });
        }
        continue;
      }
      foundGlobalCommands.push({ piece: command, data: call.builtData });
    }
  }
  await retry(() => handleBulkOverwriteGlobalCommands(commandStore, applicationCommands, foundGlobalCommands), bulkOVerwriteRetries);
  for (const [guildId, guildCommands] of Object.entries(foundGuildCommands)) {
    await retry(() => handleBulkOverwriteGuildCommands(commandStore, applicationCommands, guildId, guildCommands), bulkOVerwriteRetries);
  }
  container.client.emit(Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);
}
__name(handleBulkOverwrite, "handleBulkOverwrite");
async function handleBulkOverwriteGlobalCommands(commandStore, applicationCommands, foundGlobalCommands) {
  try {
    bulkOverwriteDebug(`Overwriting global application commands, now at ${foundGlobalCommands.length} commands`);
    const result = await applicationCommands.set(foundGlobalCommands.map((x) => x.data));
    for (const [id, globalCommand] of result.entries()) {
      const piece = foundGlobalCommands.find((x) => x.data.name === globalCommand.name)?.piece;
      if (piece) {
        const registry = piece.applicationCommandRegistry;
        switch (globalCommand.type) {
          case ApplicationCommandType.ChatInput: {
            registry["handleIdAddition"](InternalRegistryAPIType.ChatInput, id);
            break;
          }
          case ApplicationCommandType.User:
          case ApplicationCommandType.Message: {
            registry["handleIdAddition"](InternalRegistryAPIType.ContextMenu, id);
            break;
          }
        }
        commandStore.aliases.set(id, piece);
      } else {
        bulkOverwriteWarn(
          `Registered global command "${globalCommand.name}" (${id}) but failed to find the piece in the command store. This should not happen`
        );
      }
    }
    bulkOverwriteInfo(`Successfully overwrote global application commands. The application now has ${result.size} global commands`);
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") throw error;
    emitBulkOverwriteError(error, null);
  }
}
__name(handleBulkOverwriteGlobalCommands, "handleBulkOverwriteGlobalCommands");
async function handleBulkOverwriteGuildCommands(commandStore, applicationCommands, guildId, guildCommands) {
  try {
    bulkOverwriteDebug(`Overwriting guild application commands for guild ${guildId}, now at ${guildCommands.length} commands`);
    const result = await applicationCommands.set(
      guildCommands.map((x) => x.data),
      guildId
    );
    for (const [id, guildCommand] of result.entries()) {
      const piece = guildCommands.find((x) => x.data.name === guildCommand.name)?.piece;
      if (piece) {
        const registry = piece.applicationCommandRegistry;
        switch (guildCommand.type) {
          case ApplicationCommandType.ChatInput: {
            registry["handleIdAddition"](InternalRegistryAPIType.ChatInput, id, guildId);
            break;
          }
          case ApplicationCommandType.User:
          case ApplicationCommandType.Message: {
            registry["handleIdAddition"](InternalRegistryAPIType.ContextMenu, id, guildId);
            break;
          }
        }
        commandStore.aliases.set(id, piece);
      } else {
        bulkOverwriteWarn(
          `Registered guild command "${guildCommand.name}" (${id}) but failed to find the piece in the command store. This should not happen`
        );
      }
    }
    bulkOverwriteInfo(
      `Successfully overwrote guild application commands for guild ${guildId}. The application now has ${result.size} guild commands for guild ${guildId}`
    );
  } catch (error) {
    if (error instanceof Error && error.name === "AbortError") throw error;
    emitBulkOverwriteError(error, guildId);
  }
}
__name(handleBulkOverwriteGuildCommands, "handleBulkOverwriteGuildCommands");
async function handleAppendOrUpdate(commandStore, { applicationCommands, globalCommands, guildCommands }) {
  const now = Date.now();
  for (const registry of registries.values()) {
    await registry["runAPICalls"](applicationCommands, globalCommands, guildCommands);
    const piece = registry.command;
    if (piece) {
      for (const nameOrId of piece.applicationCommandRegistry.chatInputCommands) {
        commandStore.aliases.set(nameOrId, piece);
      }
      for (const nameOrId of piece.applicationCommandRegistry.contextMenuCommands) {
        commandStore.aliases.set(nameOrId, piece);
      }
    }
  }
  container.client.emit(Events.ApplicationCommandRegistriesRegistered, registries, Date.now() - now);
}
__name(handleAppendOrUpdate, "handleAppendOrUpdate");

export { acquire, allGuildIdsToFetchCommandsFor, defaultBehaviorWhenNotIdentical, defaultGuildIds, getBulkOverwriteRetries, getDefaultBehaviorWhenNotIdentical, getDefaultGuildIds, handleBulkOverwrite, handleRegistryAPICalls, registries, setBulkOverwriteRetries, setDefaultBehaviorWhenNotIdentical, setDefaultGuildIds };
//# sourceMappingURL=ApplicationCommandRegistries.mjs.map
//# sourceMappingURL=ApplicationCommandRegistries.mjs.map