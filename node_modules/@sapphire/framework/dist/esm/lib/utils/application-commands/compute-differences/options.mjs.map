{"version":3,"sources":["../../../../../../src/lib/utils/application-commands/compute-differences/options.ts"],"names":[],"mappings":"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","file":"options.mjs","sourcesContent":["import {\n\tApplicationCommandOptionType,\n\ttype APIApplicationCommandBasicOption,\n\ttype APIApplicationCommandChannelOption,\n\ttype APIApplicationCommandOption\n} from 'discord-api-types/v10';\nimport {\n\thasChannelTypesSupport,\n\thasChoicesAndAutocompleteSupport,\n\thasMinMaxLengthSupport,\n\thasMinMaxValueSupport,\n\toptionTypeToPrettyName,\n\tsubcommandTypes,\n\ttype APIApplicationCommandChoosableAndAutocompletableTypes,\n\ttype APIApplicationCommandMinAndMaxValueTypes,\n\ttype APIApplicationCommandMinMaxLengthTypes,\n\ttype APIApplicationCommandSubcommandTypes,\n\ttype CommandDifference\n} from './_shared';\nimport { checkDescription } from './description';\nimport { checkLocalizations } from './localizations';\nimport { checkName } from './name';\nimport { handleAutocomplete } from './option/autocomplete';\nimport { checkChannelTypes } from './option/channelTypes';\nimport { handleMinMaxLengthOptions } from './option/minMaxLength';\nimport { handleMinMaxValueOptions } from './option/minMaxValue';\nimport { checkOptionRequired } from './option/required';\nimport { checkOptionType } from './option/type';\n\nexport function* checkOptions(\n\texistingOptions?: APIApplicationCommandOption[],\n\tnewOptions?: APIApplicationCommandOption[]\n): Generator<CommandDifference> {\n\t// 0. No existing options and now we have options\n\tif (!existingOptions?.length && newOptions?.length) {\n\t\tyield {\n\t\t\tkey: 'options',\n\t\t\toriginal: 'no options present',\n\t\t\texpected: 'options present'\n\t\t};\n\t}\n\t// 1. Existing options and now we have no options\n\telse if (existingOptions?.length && !newOptions?.length) {\n\t\tyield {\n\t\t\tkey: 'options',\n\t\t\toriginal: 'options present',\n\t\t\texpected: 'no options present'\n\t\t};\n\t}\n\t// 2. Iterate over each option if we have any and see what's different\n\telse if (newOptions?.length) {\n\t\tlet index = 0;\n\t\tfor (const option of newOptions) {\n\t\t\tconst currentIndex = index++;\n\t\t\tconst existingOption = existingOptions![currentIndex];\n\t\t\tyield* reportOptionDifferences({ currentIndex, option, existingOption });\n\t\t}\n\n\t\t// If we went through less options than we previously had, report that\n\t\tif (index < existingOptions!.length) {\n\t\t\tlet option: APIApplicationCommandOption;\n\t\t\twhile ((option = existingOptions![index]) !== undefined) {\n\t\t\t\tconst expectedType =\n\t\t\t\t\toptionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\t\t\tyield {\n\t\t\t\t\tkey: `existing command option at index ${index}`,\n\t\t\t\t\texpected: 'no option present',\n\t\t\t\t\toriginal: `${expectedType} with name ${option.name}`\n\t\t\t\t};\n\n\t\t\t\tindex++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nfunction* reportOptionDifferences({\n\toption,\n\texistingOption,\n\tcurrentIndex,\n\tkeyPath = (index: number) => `options[${index}]`\n}: {\n\toption: APIApplicationCommandOption;\n\tcurrentIndex: number;\n\texistingOption?: APIApplicationCommandOption;\n\tkeyPath?: (index: number) => string;\n}): Generator<CommandDifference> {\n\t// If current option doesn't exist, report and return\n\tif (!existingOption) {\n\t\tconst expectedType = optionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\tyield {\n\t\t\tkey: keyPath(currentIndex),\n\t\t\texpected: `${expectedType} with name ${option.name}`,\n\t\t\toriginal: 'no option present'\n\t\t};\n\n\t\treturn;\n\t}\n\n\t// Check type\n\tyield* checkOptionType({\n\t\tkey: `${keyPath(currentIndex)}.type`,\n\t\toriginalType: existingOption.type,\n\t\texpectedType: option.type\n\t});\n\n\t// Check name\n\tyield* checkName({\n\t\tkey: `${keyPath(currentIndex)}.name`,\n\t\toldName: existingOption.name,\n\t\tnewName: option.name\n\t});\n\n\t// Check localized names\n\tconst originalLocalizedNames = existingOption.name_localizations;\n\tconst expectedLocalizedNames = option.name_localizations;\n\n\tyield* checkLocalizations({\n\t\tlocaleMapName: `${keyPath(currentIndex)}.nameLocalizations`,\n\t\tlocalePresentMessage: 'localized names',\n\t\tlocaleMissingMessage: 'no localized names',\n\t\toriginalLocalizedDescriptions: originalLocalizedNames,\n\t\texpectedLocalizedDescriptions: expectedLocalizedNames\n\t});\n\n\t// Check description\n\tyield* checkDescription({\n\t\tkey: `${keyPath(currentIndex)}.description`,\n\t\toldDescription: existingOption.description,\n\t\tnewDescription: option.description\n\t});\n\n\t// Check localized descriptions\n\tconst originalLocalizedDescriptions = existingOption.description_localizations;\n\tconst expectedLocalizedDescriptions = option.description_localizations;\n\n\tyield* checkLocalizations({\n\t\tlocaleMapName: `${keyPath(currentIndex)}.descriptionLocalizations`,\n\t\tlocalePresentMessage: 'localized descriptions',\n\t\tlocaleMissingMessage: 'no localized descriptions',\n\t\toriginalLocalizedDescriptions,\n\t\texpectedLocalizedDescriptions\n\t});\n\n\t// Check required\n\tyield* checkOptionRequired({\n\t\tkey: `${keyPath(currentIndex)}.required`,\n\t\toldRequired: existingOption.required,\n\t\tnewRequired: option.required\n\t});\n\n\t// Check for subcommands\n\tif (subcommandTypes.includes(existingOption.type) && subcommandTypes.includes(option.type)) {\n\t\tconst castedExisting = existingOption as APIApplicationCommandSubcommandTypes;\n\t\tconst castedExpected = option as APIApplicationCommandSubcommandTypes;\n\n\t\tif (\n\t\t\tcastedExisting.type === ApplicationCommandOptionType.SubcommandGroup &&\n\t\t\tcastedExpected.type === ApplicationCommandOptionType.SubcommandGroup\n\t\t) {\n\t\t\t// We know we have options in this case, because they are both groups\n\t\t\tfor (const [subcommandIndex, subcommandOption] of castedExpected.options!.entries()) {\n\t\t\t\tyield* reportOptionDifferences({\n\t\t\t\t\tcurrentIndex: subcommandIndex,\n\t\t\t\t\toption: subcommandOption,\n\t\t\t\t\texistingOption: castedExisting.options?.[subcommandIndex],\n\t\t\t\t\tkeyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`\n\t\t\t\t});\n\t\t\t}\n\t\t} else if (\n\t\t\tcastedExisting.type === ApplicationCommandOptionType.Subcommand &&\n\t\t\tcastedExpected.type === ApplicationCommandOptionType.Subcommand\n\t\t) {\n\t\t\tyield* handleSubcommandOptions({\n\t\t\t\texpectedOptions: castedExpected.options,\n\t\t\t\texistingOptions: castedExisting.options,\n\t\t\t\tcurrentIndex,\n\t\t\t\tkeyPath\n\t\t\t});\n\t\t}\n\t}\n\n\tif (hasMinMaxValueSupport(option)) {\n\t\t// Check min and max_value\n\t\tconst existingCasted = existingOption as APIApplicationCommandMinAndMaxValueTypes;\n\n\t\tyield* handleMinMaxValueOptions({\n\t\t\tcurrentIndex,\n\t\t\texistingOption: existingCasted,\n\t\t\texpectedOption: option,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasChoicesAndAutocompleteSupport(option)) {\n\t\tconst existingCasted = existingOption as APIApplicationCommandChoosableAndAutocompletableTypes;\n\n\t\tyield* handleAutocomplete({\n\t\t\texpectedOption: option,\n\t\t\texistingOption: existingCasted,\n\t\t\tcurrentIndex,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasMinMaxLengthSupport(option)) {\n\t\t// Check min and max_value\n\t\tconst existingCasted = existingOption as APIApplicationCommandMinMaxLengthTypes;\n\n\t\tyield* handleMinMaxLengthOptions({\n\t\t\tcurrentIndex,\n\t\t\texistingOption: existingCasted,\n\t\t\texpectedOption: option,\n\t\t\tkeyPath\n\t\t});\n\t}\n\n\tif (hasChannelTypesSupport(option)) {\n\t\t// Check channel_types\n\t\tconst existingCasted = existingOption as APIApplicationCommandChannelOption;\n\n\t\tyield* checkChannelTypes({\n\t\t\tcurrentIndex,\n\t\t\texistingChannelTypes: existingCasted.channel_types,\n\t\t\tkeyPath,\n\t\t\tnewChannelTypes: option.channel_types\n\t\t});\n\t}\n}\n\nfunction* handleSubcommandOptions({\n\texpectedOptions,\n\texistingOptions,\n\tcurrentIndex,\n\tkeyPath\n}: {\n\texpectedOptions?: APIApplicationCommandBasicOption[];\n\texistingOptions?: APIApplicationCommandBasicOption[];\n\tcurrentIndex: number;\n\tkeyPath: (index: number) => string;\n}): Generator<CommandDifference> {\n\t// 0. No existing options and now we have options\n\tif (!existingOptions?.length && expectedOptions?.length) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.options`,\n\t\t\texpected: 'options present',\n\t\t\toriginal: 'no options present'\n\t\t};\n\t}\n\n\t// 1. Existing options and now we have no options\n\telse if (existingOptions?.length && !expectedOptions?.length) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.options`,\n\t\t\texpected: 'no options present',\n\t\t\toriginal: 'options present'\n\t\t};\n\t}\n\n\t// 2. Iterate over each option if we have any and see what's different\n\telse if (expectedOptions?.length) {\n\t\tlet processedIndex = 0;\n\t\tfor (const subcommandOption of expectedOptions) {\n\t\t\tconst currentSubCommandOptionIndex = processedIndex++;\n\t\t\tconst existingSubcommandOption = existingOptions![currentSubCommandOptionIndex];\n\n\t\t\tyield* reportOptionDifferences({\n\t\t\t\tcurrentIndex: currentSubCommandOptionIndex,\n\t\t\t\toption: subcommandOption,\n\t\t\t\texistingOption: existingSubcommandOption,\n\t\t\t\tkeyPath: (index) => `${keyPath(currentIndex)}.options[${index}]`\n\t\t\t});\n\t\t}\n\n\t\t// If we went through less options than we previously had, report that\n\t\tif (processedIndex < existingOptions!.length) {\n\t\t\tlet option: APIApplicationCommandOption;\n\t\t\twhile ((option = existingOptions![processedIndex]) !== undefined) {\n\t\t\t\tconst expectedType =\n\t\t\t\t\toptionTypeToPrettyName.get(option.type) ?? `unknown (${option.type}); please contact Sapphire developers about this!`;\n\n\t\t\t\tyield {\n\t\t\t\t\tkey: `existing command option at path ${keyPath(currentIndex)}.options[${processedIndex}]`,\n\t\t\t\t\texpected: 'no option present',\n\t\t\t\t\toriginal: `${expectedType} with name ${option.name}`\n\t\t\t\t};\n\n\t\t\t\tprocessedIndex++;\n\t\t\t}\n\t\t}\n\t}\n}\n"]}