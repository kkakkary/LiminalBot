{"version":3,"sources":["../../../../../../../src/lib/utils/application-commands/compute-differences/option/autocomplete.ts"],"names":[],"mappings":"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","file":"autocomplete.mjs","sourcesContent":["import type { APIApplicationCommandOptionChoice } from 'discord-api-types/v10';\nimport type { APIApplicationCommandChoosableAndAutocompletableTypes, CommandDifference } from '../_shared';\nimport { checkLocalizations } from '../localizations';\n\nexport function* handleAutocomplete({\n\tcurrentIndex,\n\texistingOption,\n\texpectedOption,\n\tkeyPath\n}: {\n\tcurrentIndex: number;\n\tkeyPath: (index: number) => string;\n\texpectedOption: APIApplicationCommandChoosableAndAutocompletableTypes;\n\texistingOption: APIApplicationCommandChoosableAndAutocompletableTypes;\n}): Generator<CommandDifference> {\n\t// 0. No autocomplete and now it should autocomplete\n\tif (!existingOption.autocomplete && expectedOption.autocomplete) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.autocomplete`,\n\t\t\texpected: 'autocomplete enabled',\n\t\t\toriginal: 'autocomplete disabled'\n\t\t};\n\t}\n\t// 1. Have autocomplete and now it shouldn't\n\telse if (existingOption.autocomplete && !expectedOption.autocomplete) {\n\t\tyield {\n\t\t\tkey: `${keyPath(currentIndex)}.autocomplete`,\n\t\t\texpected: 'autocomplete disabled',\n\t\t\toriginal: 'autocomplete enabled'\n\t\t};\n\t}\n\n\tif (!expectedOption.autocomplete && !existingOption.autocomplete) {\n\t\t// 0. No choices and now we have choices\n\t\tif (!existingOption.choices?.length && expectedOption.choices?.length) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.choices`,\n\t\t\t\texpected: 'choices present',\n\t\t\t\toriginal: 'no choices present'\n\t\t\t};\n\t\t}\n\t\t// 1. Have choices and now we don't\n\t\telse if (existingOption.choices?.length && !expectedOption.choices?.length) {\n\t\t\tyield {\n\t\t\t\tkey: `${keyPath(currentIndex)}.choices`,\n\t\t\t\texpected: 'no choices present',\n\t\t\t\toriginal: 'choices present'\n\t\t\t};\n\t\t}\n\t\t// 2. Check every choice to see differences\n\t\telse if (expectedOption.choices?.length && existingOption.choices?.length) {\n\t\t\tlet index = 0;\n\t\t\tfor (const choice of expectedOption.choices) {\n\t\t\t\tconst currentChoiceIndex = index++;\n\t\t\t\tconst existingChoice = existingOption.choices[currentChoiceIndex];\n\n\t\t\t\t// If this choice never existed, return the difference\n\t\t\t\tif (existingChoice === undefined) {\n\t\t\t\t\tyield {\n\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}]`,\n\t\t\t\t\t\toriginal: 'no choice present',\n\t\t\t\t\t\texpected: 'choice present'\n\t\t\t\t\t};\n\t\t\t\t} else {\n\t\t\t\t\tif (choice.name !== existingChoice.name) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].name`,\n\t\t\t\t\t\t\toriginal: existingChoice.name,\n\t\t\t\t\t\t\texpected: choice.name\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Check localized names\n\t\t\t\t\tconst originalLocalizedNames = existingChoice.name_localizations;\n\t\t\t\t\tconst expectedLocalizedNames = choice.name_localizations;\n\n\t\t\t\t\tyield* checkLocalizations({\n\t\t\t\t\t\tlocaleMapName: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].nameLocalizations`,\n\t\t\t\t\t\tlocalePresentMessage: 'localized names',\n\t\t\t\t\t\tlocaleMissingMessage: 'no localized names',\n\t\t\t\t\t\toriginalLocalizedDescriptions: originalLocalizedNames,\n\t\t\t\t\t\texpectedLocalizedDescriptions: expectedLocalizedNames\n\t\t\t\t\t});\n\n\t\t\t\t\tif (choice.value !== existingChoice.value) {\n\t\t\t\t\t\tyield {\n\t\t\t\t\t\t\tkey: `${keyPath(currentIndex)}.choices[${currentChoiceIndex}].value`,\n\t\t\t\t\t\t\toriginal: String(existingChoice.value),\n\t\t\t\t\t\t\texpected: String(choice.value)\n\t\t\t\t\t\t};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// If there are more choices than the expected ones, return the difference\n\t\t\tif (index < existingOption.choices.length) {\n\t\t\t\tlet choice: APIApplicationCommandOptionChoice;\n\t\t\t\twhile ((choice = existingOption.choices[index]) !== undefined) {\n\t\t\t\t\tyield {\n\t\t\t\t\t\tkey: `existing choice at path ${keyPath(currentIndex)}.choices[${index}]`,\n\t\t\t\t\t\texpected: 'no choice present',\n\t\t\t\t\t\toriginal: `choice with name \"${choice.name}\" and value ${\n\t\t\t\t\t\t\ttypeof choice.value === 'number' ? choice.value : `\"${choice.value}\"`\n\t\t\t\t\t\t} present`\n\t\t\t\t\t};\n\n\t\t\t\t\tindex++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]}