{"version":3,"sources":["../../../../../../src/lib/utils/preconditions/conditions/PreconditionConditionAnd.ts"],"names":[],"mappings":";;;AAOO,IAAM,wBAAmD,GAAA;AAAA,EAC/D,MAAM,iBAAA,CAAkB,OAAS,EAAA,OAAA,EAAS,SAAS,OAAS,EAAA;AAC3D,IAAA,KAAA,MAAW,SAAS,OAAS,EAAA;AAC5B,MAAA,MAAM,SAAS,MAAM,KAAA,CAAM,UAAW,CAAA,OAAA,EAAS,SAAS,OAAO,CAAA;AAC/D,MAAI,IAAA,MAAA,CAAO,KAAM,EAAA,EAAU,OAAA,MAAA;AAAA;AAG5B,IAAA,OAAO,OAAO,EAAG,EAAA;AAAA,GAClB;AAAA,EACA,MAAM,eAAA,CAAgB,OAAS,EAAA,OAAA,EAAS,SAAS,OAAS,EAAA;AACzD,IAAA,MAAM,OAAU,GAAA,MAAM,OAAQ,CAAA,GAAA,CAAI,QAAQ,GAAI,CAAA,CAAC,KAAU,KAAA,KAAA,CAAM,UAAW,CAAA,OAAA,EAAS,OAAS,EAAA,OAAO,CAAC,CAAC,CAAA;AAGrG,IAAO,OAAA,OAAA,CAAQ,KAAK,CAAC,GAAA,KAAQ,IAAI,KAAM,EAAC,CAAK,IAAA,MAAA,CAAO,EAAG,EAAA;AAAA,GACxD;AAAA,EACA,MAAM,mBAAA,CAAoB,WAAa,EAAA,OAAA,EAAS,SAAS,OAAS,EAAA;AACjE,IAAA,KAAA,MAAW,SAAS,OAAS,EAAA;AAC5B,MAAA,MAAM,SAAS,MAAM,KAAA,CAAM,YAAa,CAAA,WAAA,EAAa,SAAS,OAAO,CAAA;AACrE,MAAI,IAAA,MAAA,CAAO,KAAM,EAAA,EAAU,OAAA,MAAA;AAAA;AAG5B,IAAA,OAAO,OAAO,EAAG,EAAA;AAAA,GAClB;AAAA,EACA,MAAM,iBAAA,CAAkB,WAAa,EAAA,OAAA,EAAS,SAAS,OAAS,EAAA;AAC/D,IAAA,MAAM,OAAU,GAAA,MAAM,OAAQ,CAAA,GAAA,CAAI,QAAQ,GAAI,CAAA,CAAC,KAAU,KAAA,KAAA,CAAM,YAAa,CAAA,WAAA,EAAa,OAAS,EAAA,OAAO,CAAC,CAAC,CAAA;AAG3G,IAAO,OAAA,OAAA,CAAQ,KAAK,CAAC,GAAA,KAAQ,IAAI,KAAM,EAAC,CAAK,IAAA,MAAA,CAAO,EAAG,EAAA;AAAA,GACxD;AAAA,EACA,MAAM,qBAAA,CAAsB,WAAa,EAAA,OAAA,EAAS,SAAS,OAAS,EAAA;AACnE,IAAA,KAAA,MAAW,SAAS,OAAS,EAAA;AAC5B,MAAA,MAAM,SAAS,MAAM,KAAA,CAAM,cAAe,CAAA,WAAA,EAAa,SAAS,OAAO,CAAA;AACvE,MAAI,IAAA,MAAA,CAAO,KAAM,EAAA,EAAU,OAAA,MAAA;AAAA;AAG5B,IAAA,OAAO,OAAO,EAAG,EAAA;AAAA,GAClB;AAAA,EACA,MAAM,mBAAA,CAAoB,WAAa,EAAA,OAAA,EAAS,SAAS,OAAS,EAAA;AACjE,IAAA,MAAM,OAAU,GAAA,MAAM,OAAQ,CAAA,GAAA,CAAI,QAAQ,GAAI,CAAA,CAAC,KAAU,KAAA,KAAA,CAAM,cAAe,CAAA,WAAA,EAAa,OAAS,EAAA,OAAO,CAAC,CAAC,CAAA;AAG7G,IAAO,OAAA,OAAA,CAAQ,KAAK,CAAC,GAAA,KAAQ,IAAI,KAAM,EAAC,CAAK,IAAA,MAAA,CAAO,EAAG,EAAA;AAAA;AAEzD","file":"PreconditionConditionAnd.mjs","sourcesContent":["import { Result } from '@sapphire/result';\nimport type { IPreconditionCondition } from './IPreconditionCondition';\n\n/**\n * An {@link IPreconditionCondition} which runs all containers similarly to doing (V0 && V1 [&& V2 [&& V3 ...]]).\n * @since 1.0.0\n */\nexport const PreconditionConditionAnd: IPreconditionCondition = {\n\tasync messageSequential(message, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.messageRun(message, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync messageParallel(message, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.messageRun(message, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t},\n\tasync chatInputSequential(interaction, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.chatInputRun(interaction, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync chatInputParallel(interaction, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.chatInputRun(interaction, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t},\n\tasync contextMenuSequential(interaction, command, entries, context) {\n\t\tfor (const child of entries) {\n\t\t\tconst result = await child.contextMenuRun(interaction, command, context);\n\t\t\tif (result.isErr()) return result;\n\t\t}\n\n\t\treturn Result.ok();\n\t},\n\tasync contextMenuParallel(interaction, command, entries, context) {\n\t\tconst results = await Promise.all(entries.map((entry) => entry.contextMenuRun(interaction, command, context)));\n\t\t// This is simplified compared to PreconditionContainerAny, because we're looking for the first error.\n\t\t// However, the base implementation short-circuits with the first Ok.\n\t\treturn results.find((res) => res.isErr()) ?? Result.ok();\n\t}\n};\n"]}