{"version":3,"sources":["../../../../../src/lib/utils/preconditions/PreconditionContainerArray.ts"],"names":["PreconditionRunMode","PreconditionRunCondition"],"mappings":"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","file":"PreconditionContainerArray.mjs","sourcesContent":["import { Collection, type ChatInputCommandInteraction, type ContextMenuCommandInteraction, type Message } from 'discord.js';\nimport type { PreconditionContext, PreconditionKeys, SimplePreconditionKeys } from '../../structures/Precondition';\nimport type { ChatInputCommand, ContextMenuCommand, MessageCommand } from '../../types/CommandTypes';\nimport type { IPreconditionContainer, PreconditionContainerReturn } from './IPreconditionContainer';\nimport {\n\tPreconditionContainerSingle,\n\ttype PreconditionSingleResolvable,\n\ttype PreconditionSingleResolvableDetails,\n\ttype SimplePreconditionSingleResolvableDetails\n} from './PreconditionContainerSingle';\nimport type { IPreconditionCondition } from './conditions/IPreconditionCondition';\nimport { PreconditionConditionAnd } from './conditions/PreconditionConditionAnd';\nimport { PreconditionConditionOr } from './conditions/PreconditionConditionOr';\n\n/**\n * The run mode for a {@link PreconditionContainerArray}.\n * @since 1.0.0\n */\nexport enum PreconditionRunMode {\n\t/**\n\t * The entries are run sequentially, this is the default behaviour and can be slow when doing long asynchronous\n\t * tasks, but is performance savvy.\n\t * @since 1.0.0\n\t */\n\tSequential,\n\n\t/**\n\t * All entries are run in parallel using `Promise.all`, then the results are processed after all of them have\n\t * completed.\n\t * @since 1.0.0\n\t */\n\tParallel\n}\n\n/**\n * The condition for a {@link PreconditionContainerArray}.\n */\nexport enum PreconditionRunCondition {\n\t/**\n\t * Defines a condition where all the entries must pass. This uses {@link PreconditionConditionAnd}.\n\t * @since 1.0.0\n\t */\n\tAnd,\n\n\t/**\n\t * Defines a condition where at least one entry must pass. This uses {@link PreconditionConditionOr}.\n\t * @since 1.0.0\n\t */\n\tOr\n}\n\n/**\n * Defines the detailed options for the {@link PreconditionContainerArray}, where both the {@link PreconditionRunMode} and the\n * entries can be defined.\n * @since 1.0.0\n */\nexport interface PreconditionArrayResolvableDetails {\n\t/**\n\t * The data that will be used to resolve {@link IPreconditionContainer} dependent of this one.\n\t * @since 1.0.0\n\t */\n\tentries: readonly PreconditionEntryResolvable[];\n\n\t/**\n\t * The mode the {@link PreconditionContainerArray} will run.\n\t * @since 1.0.0\n\t */\n\tmode: PreconditionRunMode;\n}\n\n/**\n * Defines the data accepted by {@link PreconditionContainerArray}'s constructor.\n * @since 1.0.0\n */\nexport type PreconditionArrayResolvable = readonly PreconditionEntryResolvable[] | PreconditionArrayResolvableDetails;\n\n/**\n * Defines the data accepted for each entry of the array.\n * @since 1.0.0\n * @seealso {@link PreconditionArrayResolvable}\n * @seealso {@link PreconditionArrayResolvableDetails.entries}\n */\nexport type PreconditionEntryResolvable = PreconditionSingleResolvable | PreconditionArrayResolvable;\n\nfunction isSingle(entry: PreconditionEntryResolvable): entry is PreconditionSingleResolvable {\n\treturn typeof entry === 'string' || Reflect.has(entry, 'name');\n}\n\n/**\n * An {@link IPreconditionContainer} that defines an array of multiple {@link IPreconditionContainer}s.\n *\n * By default, array containers run either of two conditions: AND and OR ({@link PreconditionRunCondition}), the top level\n * will always default to AND, where the nested one flips the logic (OR, then children arrays are AND, then OR...).\n *\n * This allows `['Connect', ['Moderator', ['DJ', 'SongAuthor']]]` to become a thrice-nested precondition container, where:\n * - Level 1: [Single(Connect), Array] runs AND, both containers must return a successful value.\n * - Level 2: [Single(Moderator), Array] runs OR, either container must return a successful value.\n * - Level 3: [Single(DJ), Single(SongAuthor)] runs AND, both containers must return a successful value.\n *\n * In other words, it is identical to doing:\n * ```typescript\n * Connect && (Moderator || (DJ && SongAuthor));\n * ```\n * @remark More advanced logic can be accomplished by adding more {@link IPreconditionCondition}s (e.g. other operators),\n * see {@link PreconditionContainerArray.conditions} for more information.\n * @since 1.0.0\n */\nexport class PreconditionContainerArray implements IPreconditionContainer {\n\t/**\n\t * The mode at which this precondition will run.\n\t * @since 1.0.0\n\t */\n\tpublic readonly mode: PreconditionRunMode;\n\n\t/**\n\t * The {@link IPreconditionContainer}s the array holds.\n\t * @since 1.0.0\n\t */\n\tpublic readonly entries: IPreconditionContainer[];\n\n\t/**\n\t * The {@link PreconditionRunCondition} that defines how entries must be handled.\n\t * @since 1.0.0\n\t */\n\tpublic readonly runCondition: PreconditionRunCondition;\n\n\tpublic constructor(data: PreconditionArrayResolvable = [], parent: PreconditionContainerArray | null = null) {\n\t\tthis.entries = [];\n\t\tthis.runCondition = parent?.runCondition === PreconditionRunCondition.And ? PreconditionRunCondition.Or : PreconditionRunCondition.And;\n\n\t\tif (Array.isArray(data)) {\n\t\t\tconst casted = data as readonly PreconditionEntryResolvable[];\n\n\t\t\tthis.mode = parent?.mode ?? PreconditionRunMode.Sequential;\n\t\t\tthis.parse(casted);\n\t\t} else {\n\t\t\tconst casted = data as PreconditionArrayResolvableDetails;\n\n\t\t\tthis.mode = casted.mode;\n\t\t\tthis.parse(casted.entries);\n\t\t}\n\t}\n\n\t/**\n\t * Adds a new entry to the array.\n\t * @since 1.0.0\n\t * @param entry The value to add to the entries.\n\t */\n\tpublic add(entry: IPreconditionContainer): this {\n\t\tthis.entries.push(entry);\n\t\treturn this;\n\t}\n\n\tpublic append(keyOrEntries: SimplePreconditionSingleResolvableDetails | SimplePreconditionKeys | PreconditionContainerArray): this;\n\tpublic append<K extends PreconditionKeys>(entry: PreconditionSingleResolvableDetails<K>): this;\n\tpublic append(entry: PreconditionContainerArray | PreconditionSingleResolvable): this {\n\t\tthis.entries.push(entry instanceof PreconditionContainerArray ? entry : new PreconditionContainerSingle(entry));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 1.0.0\n\t * @param message The message that ran this precondition.\n\t * @param command The command the message invoked.\n\t * @param context The context for the message command precondition.\n\t */\n\tpublic messageRun(message: Message, command: MessageCommand, context: PreconditionContext = {}): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.messageSequential(message, command, this.entries, context)\n\t\t\t: this.condition.messageParallel(message, command, this.entries, context);\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 3.0.0\n\t * @param interaction The interaction that ran this precondition.\n\t * @param command The command the interaction invoked.\n\t * @param context The context for the chat input precondition.\n\t */\n\tpublic chatInputRun(\n\t\tinteraction: ChatInputCommandInteraction,\n\t\tcommand: ChatInputCommand,\n\t\tcontext: PreconditionContext = {}\n\t): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.chatInputSequential(interaction, command, this.entries, context)\n\t\t\t: this.condition.chatInputParallel(interaction, command, this.entries, context);\n\t}\n\n\t/**\n\t * Runs the container.\n\t * @since 3.0.0\n\t * @param interaction The interaction that ran this precondition.\n\t * @param command The command the interaction invoked.\n\t * @param context  The context for the context menu precondition.\n\t */\n\tpublic contextMenuRun(\n\t\tinteraction: ContextMenuCommandInteraction,\n\t\tcommand: ContextMenuCommand,\n\t\tcontext: PreconditionContext = {}\n\t): PreconditionContainerReturn {\n\t\treturn this.mode === PreconditionRunMode.Sequential\n\t\t\t? this.condition.contextMenuSequential(interaction, command, this.entries, context)\n\t\t\t: this.condition.contextMenuParallel(interaction, command, this.entries, context);\n\t}\n\n\t/**\n\t * Parses the precondition entry resolvables, and adds them to the entries.\n\t * @since 1.0.0\n\t * @param entries The entries to parse.\n\t */\n\tprotected parse(entries: Iterable<PreconditionEntryResolvable>): this {\n\t\tfor (const entry of entries) {\n\t\t\tthis.add(\n\t\t\t\tisSingle(entry) //\n\t\t\t\t\t? new PreconditionContainerSingle(entry)\n\t\t\t\t\t: new PreconditionContainerArray(entry, this)\n\t\t\t);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Retrieves a condition from {@link PreconditionContainerArray.conditions}, assuming existence.\n\t * @since 1.0.0\n\t */\n\tprotected get condition(): IPreconditionCondition {\n\t\treturn PreconditionContainerArray.conditions.get(this.runCondition)!;\n\t}\n\n\t/**\n\t * The preconditions to be run. Extra ones can be added by augmenting {@link PreconditionRunCondition} and then\n\t * inserting {@link IPreconditionCondition}s.\n\t * @since 1.0.0\n\t * @example\n\t * ```typescript\n\t * // Adding more kinds of conditions\n\t *\n\t * // Set the new condition:\n\t * PreconditionContainerArray.conditions.set(2, PreconditionConditionRandom);\n\t *\n\t * // Augment Sapphire to add the new condition, in case of a JavaScript\n\t * // project, this can be moved to an `Augments.d.ts` (or any other name)\n\t * // file somewhere:\n\t * declare module '@sapphire/framework' {\n\t *   export enum PreconditionRunCondition {\n\t *     Random = 2\n\t *   }\n\t * }\n\t * ```\n\t */\n\tpublic static readonly conditions = new Collection<PreconditionRunCondition, IPreconditionCondition>([\n\t\t[PreconditionRunCondition.And, PreconditionConditionAnd],\n\t\t[PreconditionRunCondition.Or, PreconditionConditionOr]\n\t]);\n}\n"]}