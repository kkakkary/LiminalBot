{"version":3,"sources":["../../../../../src/lib/utils/logger/Logger.ts"],"names":[],"mappings":";;;AAEO,IAAM,OAAA,GAAN,MAAM,OAA0B,CAAA;AAAA,EAG/B,YAAY,KAAiB,EAAA;AACnC,IAAA,IAAA,CAAK,KAAQ,GAAA,KAAA;AAAA;AACd,EAEO,IAAI,KAA0B,EAAA;AACpC,IAAA,OAAO,SAAS,IAAK,CAAA,KAAA;AAAA;AACtB,EAEO,SAAS,MAAkC,EAAA;AACjD,IAAA,IAAA,CAAK,KAAM,CAAA,QAAA,CAAS,KAAO,EAAA,GAAG,MAAM,CAAA;AAAA;AACrC,EAEO,SAAS,MAAkC,EAAA;AACjD,IAAA,IAAA,CAAK,KAAM,CAAA,QAAA,CAAS,KAAO,EAAA,GAAG,MAAM,CAAA;AAAA;AACrC,EAEO,QAAQ,MAAkC,EAAA;AAChD,IAAA,IAAA,CAAK,KAAM,CAAA,QAAA,CAAS,IAAM,EAAA,GAAG,MAAM,CAAA;AAAA;AACpC,EAEO,QAAQ,MAAkC,EAAA;AAChD,IAAA,IAAA,CAAK,KAAM,CAAA,QAAA,CAAS,IAAM,EAAA,GAAG,MAAM,CAAA;AAAA;AACpC,EAEO,SAAS,MAAkC,EAAA;AACjD,IAAA,IAAA,CAAK,KAAM,CAAA,QAAA,CAAS,KAAO,EAAA,GAAG,MAAM,CAAA;AAAA;AACrC,EAEO,SAAS,MAAkC,EAAA;AACjD,IAAA,IAAA,CAAK,KAAM,CAAA,QAAA,CAAS,KAAO,EAAA,GAAG,MAAM,CAAA;AAAA;AACrC,EAEO,KAAA,CAAM,UAAoB,MAAkC,EAAA;AAClE,IAAA,IAAI,CAAC,IAAA,CAAK,GAAI,CAAA,KAAK,CAAG,EAAA;AACtB,IAAA,MAAM,MAAS,GAAA,OAAA,CAAO,MAAO,CAAA,GAAA,CAAI,KAAK,CAAA;AACtC,IAAA,IAAI,OAAO,MAAA,KAAW,QAAU,EAAA,OAAA,CAAQ,MAAM,CAAA,CAAE,CAAI,CAAA,EAAA,MAAA,CAAO,WAAY,EAAC,CAAK,CAAA,CAAA,EAAA,GAAG,MAAM,CAAA;AAAA;AAWxF,CAAA;AAjDuC,MAAA,CAAA,OAAA,EAAA,QAAA,CAAA;AAA1B,OAyCc,CAAA,MAAA,uBAAa,GAA0B,CAAA;AAAA,EAChE,CAAC,QAAS,CAAA,KAAA,EAAO,OAAO,CAAA;AAAA,EACxB,CAAC,QAAS,CAAA,KAAA,EAAO,OAAO,CAAA;AAAA,EACxB,CAAC,QAAS,CAAA,IAAA,EAAM,MAAM,CAAA;AAAA,EACtB,CAAC,QAAS,CAAA,IAAA,EAAM,MAAM,CAAA;AAAA,EACtB,CAAC,QAAS,CAAA,KAAA,EAAO,OAAO,CAAA;AAAA,EACxB,CAAC,QAAS,CAAA,KAAA,EAAO,OAAO;AACzB,CAAC,CAAA;AAhDK,IAAM,MAAN,GAAA","file":"Logger.mjs","sourcesContent":["import { LogLevel, type ILogger } from './ILogger';\n\nexport class Logger implements ILogger {\n\tpublic level: LogLevel;\n\n\tpublic constructor(level: LogLevel) {\n\t\tthis.level = level;\n\t}\n\n\tpublic has(level: LogLevel): boolean {\n\t\treturn level >= this.level;\n\t}\n\n\tpublic trace(...values: readonly unknown[]): void {\n\t\tthis.write(LogLevel.Trace, ...values);\n\t}\n\n\tpublic debug(...values: readonly unknown[]): void {\n\t\tthis.write(LogLevel.Debug, ...values);\n\t}\n\n\tpublic info(...values: readonly unknown[]): void {\n\t\tthis.write(LogLevel.Info, ...values);\n\t}\n\n\tpublic warn(...values: readonly unknown[]): void {\n\t\tthis.write(LogLevel.Warn, ...values);\n\t}\n\n\tpublic error(...values: readonly unknown[]): void {\n\t\tthis.write(LogLevel.Error, ...values);\n\t}\n\n\tpublic fatal(...values: readonly unknown[]): void {\n\t\tthis.write(LogLevel.Fatal, ...values);\n\t}\n\n\tpublic write(level: LogLevel, ...values: readonly unknown[]): void {\n\t\tif (!this.has(level)) return;\n\t\tconst method = Logger.levels.get(level);\n\t\tif (typeof method === 'string') console[method](`[${method.toUpperCase()}]`, ...values);\n\t}\n\n\tprotected static readonly levels = new Map<LogLevel, LogMethods>([\n\t\t[LogLevel.Trace, 'trace'],\n\t\t[LogLevel.Debug, 'debug'],\n\t\t[LogLevel.Info, 'info'],\n\t\t[LogLevel.Warn, 'warn'],\n\t\t[LogLevel.Error, 'error'],\n\t\t[LogLevel.Fatal, 'error']\n\t]);\n}\n\nexport type LogMethods = 'trace' | 'debug' | 'info' | 'warn' | 'error';\n"]}