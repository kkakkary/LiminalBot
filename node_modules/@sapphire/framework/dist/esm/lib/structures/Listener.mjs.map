{"version":3,"sources":["../../../../src/lib/structures/Listener.ts"],"names":[],"mappings":";;;;;AA6CO,IAAe,SAAA,GAAf,MAAe,SAAA,SAAkH,KAGtI,CAAA;AAAA,EAqBM,WAAY,CAAA,OAAA,EAAiC,OAAmB,GAAA,EAAe,EAAA;AACrF,IAAA,KAAA,CAAM,SAAS,OAAO,CAAA;AAEtB,IAAK,IAAA,CAAA,OAAA,GACJ,OAAO,OAAQ,CAAA,OAAA,KAAY,cACxB,IAAK,CAAA,SAAA,CAAU,UACb,OAAO,OAAA,CAAQ,YAAY,QAC1B,GAAA,OAAA,CAAQ,IAAI,IAAK,CAAA,SAAA,CAAU,QAAQ,OAAQ,CAAA,OAAO,CAClD,GAAA,OAAA,CAAQ,OAA6B,KAAA,IAAA;AAC5C,IAAK,IAAA,CAAA,KAAA,GAAQ,OAAQ,CAAA,KAAA,IAAS,IAAK,CAAA,IAAA;AACnC,IAAK,IAAA,CAAA,IAAA,GAAO,QAAQ,IAAQ,IAAA,KAAA;AAE5B,IAAA,IAAA,CAAK,YAAY,IAAK,CAAA,OAAA,IAAW,IAAK,CAAA,KAAA,GAAS,KAAK,IAAO,GAAA,IAAA,CAAK,QAAS,CAAA,IAAA,CAAK,IAAI,CAAI,GAAA,IAAA,CAAK,IAAK,CAAA,IAAA,CAAK,IAAI,CAAK,GAAA,IAAA;AAG9G,IAAA,IAAI,KAAK,OAAY,KAAA,IAAA,IAAQ,KAAK,SAAc,KAAA,IAAA,OAAW,OAAU,GAAA,KAAA;AAAA;AACtE,EAIgB,MAAuB,GAAA;AACtC,IAAO,OAAA;AAAA,MACN,GAAG,MAAM,MAAO,EAAA;AAAA,MAChB,MAAM,IAAK,CAAA,IAAA;AAAA,MACX,OAAO,IAAK,CAAA;AAAA,KACb;AAAA;AACD,EAEA,MAAc,QAAQ,IAAiB,EAAA;AACtC,IAAM,MAAA,MAAA,GAAS,MAAM,MAAO,CAAA,SAAA,CAAU,MAAM,IAAK,CAAA,GAAA,CAAI,GAAI,IAAmE,CAAC,CAAA;AAC7H,IAAA,MAAA,CAAO,UAAW,CAAA,CAAC,KAAU,KAAA,IAAA,CAAK,UAAU,MAAO,CAAA,IAAA,CAAK,MAAO,CAAA,aAAA,EAAe,KAAO,EAAA,EAAE,KAAO,EAAA,IAAA,EAAM,CAAC,CAAA;AAAA;AACtG,EAEA,MAAc,YAAY,IAAiB,EAAA;AAC1C,IAAM,MAAA,IAAA,CAAK,IAAK,CAAA,GAAG,IAAI,CAAA;AACvB,IAAA,MAAM,KAAK,MAAO,EAAA;AAAA;AAEpB,CAAA;AA1DE,MAAA,CAAA,SAAA,EAAA,UAAA,CAAA;AAHK,IAAe,QAAf,GAAA","file":"Listener.mjs","sourcesContent":["import { Piece } from '@sapphire/pieces';\nimport { Result } from '@sapphire/result';\nimport type { Client, ClientEvents } from 'discord.js';\nimport type { EventEmitter } from 'node:events';\nimport { Events } from '../types/Events';\n\n/**\n * The base event class. This class is abstract and is to be extended by subclasses, which should implement the methods. In\n * Sapphire's workflow, listeners are called when the emitter they listen on emits a new message with the same event name.\n *\n * @example\n * ```typescript\n * // TypeScript:\n * import { Events, Listener } from '@sapphire/framework';\n *\n * // Define a class extending `Listener`, then export it.\n * // NOTE: You can use `export default` or `export =` too.\n * export class CoreListener extends Listener<typeof Events.ClientReady> {\n *   public constructor(context: Listener.LoaderContext) {\n *     super(context, { event: Events.ClientReady, once: true });\n *   }\n *\n *   public run() {\n *     this.container.client.id ??= this.container.client.user?.id ?? null;\n *   }\n * }\n * ```\n *\n * @example\n * ```javascript\n * // JavaScript:\n * const { Events, Listener } = require('@sapphire/framework');\n *\n * // Define a class extending `Listener`, then export it.\n * module.exports = class CoreListener extends Listener {\n *   constructor(context) {\n *     super(context, { event: Events.ClientReady, once: true });\n *   }\n *\n *   run() {\n *     this.container.client.id ??= this.container.client.user?.id ?? null;\n *   }\n * }\n * ```\n */\nexport abstract class Listener<E extends keyof ClientEvents | symbol = '', Options extends Listener.Options = Listener.Options> extends Piece<\n\tOptions,\n\t'listeners'\n> {\n\t/**\n\t * The emitter, if any.\n\t * @since 2.0.0\n\t */\n\tpublic readonly emitter: EventEmitter | null;\n\n\t/**\n\t * The name of the event the listener listens to.\n\t * @since 2.0.0\n\t */\n\tpublic readonly event: string | symbol;\n\n\t/**\n\t * Whether the listener will be unloaded after the first run.\n\t * @since 2.0.0\n\t */\n\tpublic readonly once: boolean;\n\n\tprivate _listener: ((...args: any[]) => void) | null;\n\n\tpublic constructor(context: Listener.LoaderContext, options: Options = {} as Options) {\n\t\tsuper(context, options);\n\n\t\tthis.emitter =\n\t\t\ttypeof options.emitter === 'undefined'\n\t\t\t\t? this.container.client\n\t\t\t\t: ((typeof options.emitter === 'string'\n\t\t\t\t\t\t? (Reflect.get(this.container.client, options.emitter) as EventEmitter)\n\t\t\t\t\t\t: (options.emitter as EventEmitter)) ?? null);\n\t\tthis.event = options.event ?? this.name;\n\t\tthis.once = options.once ?? false;\n\n\t\tthis._listener = this.emitter && this.event ? (this.once ? this._runOnce.bind(this) : this._run.bind(this)) : null;\n\n\t\t// If there's no emitter or no listener, disable:\n\t\tif (this.emitter === null || this._listener === null) this.enabled = false;\n\t}\n\n\tpublic abstract run(...args: E extends keyof ClientEvents ? ClientEvents[E] : unknown[]): unknown;\n\n\tpublic override toJSON(): ListenerJSON {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tonce: this.once,\n\t\t\tevent: this.event\n\t\t};\n\t}\n\n\tprivate async _run(...args: unknown[]) {\n\t\tconst result = await Result.fromAsync(() => this.run(...(args as E extends keyof ClientEvents ? ClientEvents[E] : unknown[])));\n\t\tresult.inspectErr((error) => this.container.client.emit(Events.ListenerError, error, { piece: this }));\n\t}\n\n\tprivate async _runOnce(...args: unknown[]) {\n\t\tawait this._run(...args);\n\t\tawait this.unload();\n\t}\n}\n\nexport interface ListenerOptions extends Piece.Options {\n\treadonly emitter?: keyof Client | EventEmitter;\n\treadonly event?: string | symbol;\n\treadonly once?: boolean;\n}\n\nexport interface ListenerJSON extends Piece.JSON {\n\tevent: string | symbol;\n\tonce: boolean;\n}\n\nexport namespace Listener {\n\texport type Options = ListenerOptions;\n\texport type JSON = ListenerJSON;\n\t/** @deprecated Use {@linkcode LoaderContext} instead. */\n\texport type Context = LoaderContext;\n\texport type LoaderContext = Piece.LoaderContext<'listeners'>;\n}\n"]}