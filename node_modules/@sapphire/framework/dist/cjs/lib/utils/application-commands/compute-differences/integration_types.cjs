'use strict';

var __defProp = Object.defineProperty;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });

// src/lib/utils/application-commands/compute-differences/integration_types.ts
function* checkIntegrationTypes(existingIntegrationTypes, newIntegrationTypes) {
  if (!existingIntegrationTypes?.length && newIntegrationTypes?.length) {
    yield {
      key: "integrationTypes",
      original: "no integration types present",
      expected: "integration types present"
    };
  } else if (existingIntegrationTypes?.length && !newIntegrationTypes?.length) {
    yield {
      key: "integrationTypes",
      original: "integration types present",
      expected: "no integration types present"
    };
  } else if (newIntegrationTypes?.length) {
    let index = 0;
    for (const newIntegrationType of newIntegrationTypes) {
      const currentIndex = index++;
      if (existingIntegrationTypes[currentIndex] !== newIntegrationType) {
        yield {
          key: `integrationTypes[${currentIndex}]`,
          original: `integration type ${existingIntegrationTypes?.[currentIndex]}`,
          expected: `integration type ${newIntegrationType}`
        };
      }
    }
    if (index < existingIntegrationTypes.length) {
      let type;
      while ((type = existingIntegrationTypes[index]) !== void 0) {
        yield {
          key: `integrationTypes[${index}]`,
          original: `integration type ${type} present`,
          expected: "no integration type present"
        };
        index++;
      }
    }
  }
}
__name(checkIntegrationTypes, "checkIntegrationTypes");

exports.checkIntegrationTypes = checkIntegrationTypes;
//# sourceMappingURL=integration_types.cjs.map
//# sourceMappingURL=integration_types.cjs.map