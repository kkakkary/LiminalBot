{"version":3,"sources":["../../../../../src/lib/utils/strategies/FlagUnorderedStrategy.ts"],"names":["Option","PrefixedStrategy","result"],"mappings":";;;;;;;AAoCA,IAAM,KAAA,mBAAc,MAAA,CAAA,MAAAA,aAAA,CAAO,IAAb,EAAA,OAAA,CAAA;AACd,IAAM,MAAA,gCAAe,IAAN,EAAA,QAAA,CAAA;AAER,IAAM,sBAAA,GAAN,MAAM,sBAAA,SAA8BC,uBAAiB,CAAA;AAAA,EAIpD,YAAY,EAAE,KAAA,EAAO,OAAS,EAAA,QAAA,GAAW,CAAC,IAAM,EAAA,GAAA,EAAK,QAAG,CAAA,EAAG,aAAa,CAAC,GAAA,EAAK,GAAG,CAAE,EAAA,GAAyB,EAAI,EAAA;AACtH,IAAA,KAAA,CAAM,UAAU,UAAU,CAAA;AAC1B,IAAK,IAAA,CAAA,KAAA,GAAQ,SAAS,EAAC;AACvB,IAAK,IAAA,CAAA,OAAA,GAAU,WAAW,EAAC;AAE3B,IAAA,IAAI,IAAK,CAAA,KAAA,KAAU,IAAM,EAAA,IAAA,CAAK,WAAc,GAAA,MAAA;AAAA,SAAA,IACnC,IAAK,CAAA,KAAA,CAAM,MAAW,KAAA,CAAA,OAAQ,SAAY,GAAA,KAAA;AAEnD,IAAI,IAAA,IAAA,CAAK,YAAY,IAAM,EAAA;AAC1B,MAAA,IAAA,CAAK,aAAgB,GAAA,MAAA;AAAA,KACX,MAAA,IAAA,IAAA,CAAK,OAAQ,CAAA,MAAA,KAAW,CAAG,EAAA;AACrC,MAAA,IAAA,CAAK,WAAc,GAAA,KAAA;AAAA;AACpB;AACD,EAEgB,UAAU,CAA2B,EAAA;AACpD,IAAM,MAAAC,QAAA,GAAS,KAAM,CAAA,SAAA,CAAU,CAAC,CAAA;AAGhC,IAAI,IAAAA,QAAA,CAAO,UAAU,CAAC,KAAA,KAAU,KAAK,WAAY,CAAA,KAAK,CAAC,CAAA,EAAU,OAAAA,QAAA;AAGjE,IAAA,OAAOF,aAAO,CAAA,IAAA;AAAA;AACf,EAEgB,YAAY,CAA0D,EAAA;AACrF,IAAM,MAAAE,QAAA,GAAS,KAAM,CAAA,WAAA,CAAY,CAAC,CAAA;AAElC,IAAI,IAAAA,QAAA,CAAO,SAAU,CAAA,CAAC,MAAW,KAAA,IAAA,CAAK,aAAc,CAAA,MAAA,CAAO,CAAC,CAAC,CAAC,CAAA,EAAU,OAAAA,QAAA;AAExE,IAAA,OAAOF,aAAO,CAAA,IAAA;AAAA;AACf,EAEQ,YAAY,CAAW,EAAA;AAC9B,IAAQ,OAAA,IAAA,CAAK,KAA4B,CAAA,QAAA,CAAS,CAAC,CAAA;AAAA;AACpD,EAEQ,cAAc,CAAW,EAAA;AAChC,IAAQ,OAAA,IAAA,CAAK,OAA8B,CAAA,QAAA,CAAS,CAAC,CAAA;AAAA;AAEvD,CAAA;AA5C4D,MAAA,CAAA,sBAAA,EAAA,uBAAA,CAAA;AAArD,IAAM,qBAAN,GAAA","file":"FlagUnorderedStrategy.cjs","sourcesContent":["import { PrefixedStrategy } from '@sapphire/lexure';\nimport { Option } from '@sapphire/result';\n\n/**\n * The strategy options used in Sapphire.\n */\nexport interface FlagStrategyOptions {\n\t/**\n\t * The accepted flags. Flags are key-only identifiers that can be placed anywhere in the command. Two different types are accepted:\n\t * * An array of strings, e.g. [`silent`].\n\t * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).\n\t * @default []\n\t */\n\tflags?: readonly string[] | boolean;\n\n\t/**\n\t * The accepted options. Options are key-value identifiers that can be placed anywhere in the command. Two different types are accepted:\n\t * * An array of strings, e.g. [`silent`].\n\t * * A boolean defining whether the strategy should accept all keys (`true`) or none at all (`false`).\n\t * @default []\n\t */\n\toptions?: readonly string[] | boolean;\n\n\t/**\n\t * The prefixes for both flags and options.\n\t * @default ['--', '-', '—']\n\t */\n\tprefixes?: string[];\n\n\t/**\n\t * The flag separators.\n\t * @default ['=', ':']\n\t */\n\tseparators?: string[];\n}\n\nconst never = () => Option.none;\nconst always = () => true;\n\nexport class FlagUnorderedStrategy extends PrefixedStrategy {\n\tpublic readonly flags: readonly string[] | true;\n\tpublic readonly options: readonly string[] | true;\n\n\tpublic constructor({ flags, options, prefixes = ['--', '-', '—'], separators = ['=', ':'] }: FlagStrategyOptions = {}) {\n\t\tsuper(prefixes, separators);\n\t\tthis.flags = flags || [];\n\t\tthis.options = options || [];\n\n\t\tif (this.flags === true) this.allowedFlag = always;\n\t\telse if (this.flags.length === 0) this.matchFlag = never;\n\n\t\tif (this.options === true) {\n\t\t\tthis.allowedOption = always;\n\t\t} else if (this.options.length === 0) {\n\t\t\tthis.matchOption = never;\n\t\t}\n\t}\n\n\tpublic override matchFlag(s: string): Option<string> {\n\t\tconst result = super.matchFlag(s);\n\n\t\t// The flag must be an allowed one.\n\t\tif (result.isSomeAnd((value) => this.allowedFlag(value))) return result;\n\n\t\t// If it did not match a flag, return null.\n\t\treturn Option.none;\n\t}\n\n\tpublic override matchOption(s: string): Option<readonly [key: string, value: string]> {\n\t\tconst result = super.matchOption(s);\n\n\t\tif (result.isSomeAnd((option) => this.allowedOption(option[0]))) return result;\n\n\t\treturn Option.none;\n\t}\n\n\tprivate allowedFlag(s: string) {\n\t\treturn (this.flags as readonly string[]).includes(s);\n\t}\n\n\tprivate allowedOption(s: string) {\n\t\treturn (this.options as readonly string[]).includes(s);\n\t}\n}\n"]}