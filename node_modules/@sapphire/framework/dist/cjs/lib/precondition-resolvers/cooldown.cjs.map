{"version":3,"sources":["../../../../src/lib/precondition-resolvers/cooldown.ts"],"names":["container","BucketScope","CommandPreConditions"],"mappings":";;;;;;;;AAgBO,SAAS,sCACf,OACA,EAAA,aAAA,EACA,aACA,EAAA,aAAA,EACA,uBACA,0BACC,EAAA;AACD,EAAA,MAAM,EAAE,eAAA,EAAoB,GAAAA,gBAAA,CAAU,MAAO,CAAA,OAAA;AAK7C,EAAA,MAAM,WAAW,eAAiB,EAAA,gBAAA,EAAkB,QAAS,CAAA,OAAA,CAAQ,IAAI,CAAK,IAAA,KAAA;AAC9E,EAAA,MAAM,KAAQ,GAAA,aAAA,KAAkB,QAAW,GAAA,CAAA,GAAK,iBAAiB,KAAS,IAAA,CAAA,CAAA;AAC1E,EAAA,MAAM,KAAQ,GAAA,aAAA,KAAkB,QAAW,GAAA,CAAA,GAAK,iBAAiB,KAAS,IAAA,CAAA,CAAA;AAE1E,EAAA,IAAI,SAAS,KAAO,EAAA;AACnB,IAAA,MAAM,KAAQ,GAAA,aAAA,IAAiB,eAAiB,EAAA,KAAA,IAASC,qBAAY,CAAA,IAAA;AACrE,IAAM,MAAA,aAAA,GAAgB,yBAAyB,eAAiB,EAAA,aAAA;AAChE,IAAA,0BAAA,CAA2B,MAAO,CAAA;AAAA,MACjC,MAAMC,8BAAqB,CAAA,QAAA;AAAA,MAC3B,OAAS,EAAA,EAAE,KAAO,EAAA,KAAA,EAAO,OAAO,aAAc;AAAA,KAC9C,CAAA;AAAA;AAEH;AAzBgB,MAAA,CAAA,qCAAA,EAAA,uCAAA,CAAA","file":"cooldown.cjs","sourcesContent":["import { container } from '@sapphire/pieces';\nimport type { Command } from '../structures/Command';\nimport { BucketScope, CommandPreConditions } from '../types/Enums';\nimport { type PreconditionContainerArray } from '../utils/preconditions/PreconditionContainerArray';\n\n/**\n * Appends the `Cooldown` precondition when {@link Command.Options.cooldownLimit} and\n * {@link Command.Options.cooldownDelay} are both non-zero.\n *\n * @param command The command to parse cooldowns for.\n * @param cooldownLimit The cooldown limit to use.\n * @param cooldownDelay The cooldown delay to use.\n * @param cooldownScope The cooldown scope to use.\n * @param cooldownFilteredUsers The cooldown filtered users to use.\n * @param preconditionContainerArray The precondition container array to append the precondition to.\n */\nexport function parseConstructorPreConditionsCooldown<P, O extends Command.Options>(\n\tcommand: Command<P, O>,\n\tcooldownLimit: number | undefined,\n\tcooldownDelay: number | undefined,\n\tcooldownScope: BucketScope | undefined,\n\tcooldownFilteredUsers: string[] | undefined,\n\tpreconditionContainerArray: PreconditionContainerArray\n) {\n\tconst { defaultCooldown } = container.client.options;\n\n\t// We will check for whether the command is filtered from the defaults, but we will allow overridden values to\n\t// be set. If an overridden value is passed, it will have priority. Otherwise, it will default to 0 if filtered\n\t// (causing the precondition to not be registered) or the default value with a fallback to a single-use cooldown.\n\tconst filtered = defaultCooldown?.filteredCommands?.includes(command.name) ?? false;\n\tconst limit = cooldownLimit ?? (filtered ? 0 : (defaultCooldown?.limit ?? 1));\n\tconst delay = cooldownDelay ?? (filtered ? 0 : (defaultCooldown?.delay ?? 0));\n\n\tif (limit && delay) {\n\t\tconst scope = cooldownScope ?? defaultCooldown?.scope ?? BucketScope.User;\n\t\tconst filteredUsers = cooldownFilteredUsers ?? defaultCooldown?.filteredUsers;\n\t\tpreconditionContainerArray.append({\n\t\t\tname: CommandPreConditions.Cooldown,\n\t\t\tcontext: { scope, limit, delay, filteredUsers }\n\t\t});\n\t}\n}\n"]}