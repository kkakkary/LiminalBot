{"version":3,"sources":["../../../../src/lib/structures/InteractionHandler.ts"],"names":["Piece","Option","InteractionHandlerTypes"],"mappings":";;;;;;;AAKO,IAAe,mBAAA,GAAf,MAAe,mBAAA,SAAoGA,YAGxH,CAAA;AAAA,EAOM,WAAA,CAAY,SAA2C,OAAkB,EAAA;AAC/E,IAAA,KAAA,CAAM,SAAS,OAAO,CAAA;AAEtB,IAAA,IAAA,CAAK,yBAAyB,OAAQ,CAAA,sBAAA;AAAA;AACvC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EA+CO,MAAM,YAAuD,EAAA;AACnE,IAAA,OAAO,KAAK,IAAK,EAAA;AAAA;AAClB,EAIO,KAAQ,IAAsC,EAAA;AACpD,IAAO,OAAAC,aAAA,CAAO,KAAK,IAAI,CAAA;AAAA;AACxB,EAEO,IAAoB,GAAA;AAC1B,IAAA,OAAOA,aAAO,CAAA,IAAA;AAAA;AACf,EAEgB,MAAiC,GAAA;AAChD,IAAO,OAAA;AAAA,MACN,GAAG,MAAM,MAAO,EAAA;AAAA,MAChB,wBAAwB,IAAK,CAAA;AAAA,KAC9B;AAAA;AAEF,CAAA;AA9EE,MAAA,CAAA,mBAAA,EAAA,oBAAA,CAAA;AAHK,IAAe,kBAAf,GAAA;AAyGK,IAAA,uBAAA,qBAAAC,wBAAL,KAAA;AAEN,EAAAA,wBAAA,CAAA,wBAAA,CAAA,QAAA,CAAA,GAAA,CAAA,CAAA,GAAA,QAAA;AACA,EAAAA,wBAAA,CAAA,wBAAA,CAAA,YAAA,CAAA,GAAA,CAAA,CAAA,GAAA,YAAA;AACA,EAAAA,wBAAA,CAAA,wBAAA,CAAA,aAAA,CAAA,GAAA,CAAA,CAAA,GAAA,aAAA;AAGA,EAAAA,wBAAA,CAAA,wBAAA,CAAA,kBAAA,CAAA,GAAA,CAAA,CAAA,GAAA,kBAAA;AAEA,EAAAA,wBAAA,CAAA,wBAAA,CAAA,cAAA,CAAA,GAAA,CAAA,CAAA,GAAA,cAAA;AATW,EAAAA,OAAAA,wBAAAA;AAAA,CAAA,EAAA,uBAAA,IAAA,EAAA","file":"InteractionHandler.cjs","sourcesContent":["import { Piece } from '@sapphire/pieces';\nimport { Option } from '@sapphire/result';\nimport type { Awaitable } from '@sapphire/utilities';\nimport type { Interaction } from 'discord.js';\n\nexport abstract class InteractionHandler<Options extends InteractionHandler.Options = InteractionHandler.Options> extends Piece<\n\tOptions,\n\t'interaction-handlers'\n> {\n\t/**\n\t * The type for this handler\n\t * @since 3.0.0\n\t */\n\tpublic readonly interactionHandlerType: InteractionHandlerTypes;\n\n\tpublic constructor(context: InteractionHandler.LoaderContext, options: Options) {\n\t\tsuper(context, options);\n\n\t\tthis.interactionHandlerType = options.interactionHandlerType;\n\t}\n\n\tpublic abstract run(interaction: Interaction, parsedData?: unknown): unknown;\n\n\t/**\n\t * A custom function that will be called when checking if an interaction should be passed to this handler.\n\t * You can use this method to not only filter by ids, but also pre-parse the data from the id for use in the run method.\n\t *\n\t * By default, all interactions of the type you specified will run in a handler. You should override this method\n\t * to change that behavior.\n\t *\n\t * @example\n\t * ```typescript\n\t * // Parsing a button handler\n\t * public override parse(interaction: ButtonInteraction) {\n\t *   if (interaction.customId.startsWith('my-awesome-clicky-button')) {\n\t * \t   // Returning a `some` here means that the run method should be called next!\n\t *     return this.some({ isMyBotAwesome: true, awesomenessLevel: 9001 });\n\t *   }\n\t *\n\t *   // Returning a `none` means this interaction shouldn't run in this handler\n\t *   return this.none();\n\t * }\n\t * ```\n\t *\n\t * @example\n\t * ```typescript\n\t * // Getting data from a database based on the custom id\n\t * public override async parse(interaction: ButtonInteraction) {\n\t *   // This code is purely for demonstration purposes only!\n\t *   if (interaction.customId.startsWith('example-data')) {\n\t *     const [, userId, channelId] = interaction.customId.split('.');\n\t *\n\t * \t   const dataFromDatabase = await container.prisma.exampleData.findFirst({ where: { userId, channelId } });\n\t *\n\t *     // Returning a `some` here means that the run method should be called next!\n\t *     return this.some(dataFromDatabase);\n\t *   }\n\t *\n\t *   // Returning a `none` means this interaction shouldn't run in this handler\n\t *   return this.none();\n\t * }\n\t * ```\n\t *\n\t * @returns An {@link Option} (or a {@link Promise Promised} {@link Option}) that indicates if this interaction should be\n\t * handled by this handler, and any extra data that should be passed to the {@link InteractionHandler.run run method}\n\t */\n\tpublic parse(_interaction: Interaction): Awaitable<Option<unknown>> {\n\t\treturn this.some();\n\t}\n\n\tpublic some(): Option.Some<never>;\n\tpublic some<T>(data: T): Option.Some<T>;\n\tpublic some<T>(data?: T): Option.Some<T | undefined> {\n\t\treturn Option.some(data);\n\t}\n\n\tpublic none(): Option.None {\n\t\treturn Option.none;\n\t}\n\n\tpublic override toJSON(): InteractionHandlerJSON {\n\t\treturn {\n\t\t\t...super.toJSON(),\n\t\t\tinteractionHandlerType: this.interactionHandlerType\n\t\t};\n\t}\n}\n\nexport interface InteractionHandlerOptions extends Piece.Options {\n\t/**\n\t * The type of interaction this handler is for. Must be one of {@link InteractionHandlerTypes}.\n\t */\n\treadonly interactionHandlerType: InteractionHandlerTypes;\n}\n\nexport interface InteractionHandlerJSON extends Piece.JSON {\n\tinteractionHandlerType: InteractionHandlerTypes;\n}\n\nexport type InteractionHandlerParseResult<Instance extends InteractionHandler> = Option.UnwrapSome<Awaited<ReturnType<Instance['parse']>>>;\n\nexport namespace InteractionHandler {\n\t/** @deprecated Use {@linkcode LoaderContext} instead. */\n\texport type Context = LoaderContext;\n\texport type LoaderContext = Piece.LoaderContext<'interaction-handlers'>;\n\texport type Options = InteractionHandlerOptions;\n\texport type JSON = InteractionHandlerJSON;\n\texport type ParseResult<Instance extends InteractionHandler> = InteractionHandlerParseResult<Instance>;\n}\n\nexport enum InteractionHandlerTypes {\n\t// Specifically focused types\n\tButton,\n\tSelectMenu,\n\tModalSubmit,\n\n\t// More free-falling handlers, for 1 shared handler between buttons and select menus (someone will have a use for this >,>)\n\tMessageComponent,\n\t// Optional autocompletes, you can use this or in-command\n\tAutocomplete\n}\n"]}